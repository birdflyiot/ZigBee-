###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.60.1.40026 for 8051             24/Dec/2016  13:07:32 #
# Copyright (C) 2004-2010 IAR Systems AB.                                     #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  DHT11      #
#                          Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë                   #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Components\h #
#                          al\target\CC2530EB\hal_key.c                       #
#    Command line       =  -f "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  DHT11  #
#                          Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë                   #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC25 #
#                          30DB\f8wEndev.cfg" (-DCPU32MHZ -DROOT=__near_func  #
#                          -DBLINK_LEDS) -f "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbe #
#                          e\¿ª¹Ø  DHT11 Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë     #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC25 #
#                          30DB\f8wConfig.cfg" (-DSECURE=0                    #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x02000000                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=TRUE      #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  DHT11     #
#                          Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë                   #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Components\h #
#                          al\target\CC2530EB\hal_key.c" -D ZIGBEEPRO -D      #
#                          NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D            #
#                          MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG  #
#                          -D xSensor01 -D xSensor02 -D xSensor03 -D          #
#                          xSensor04 -D xSensor05 -D xSensor06 -D xSensor07   #
#                          -D xSensor08 -D xSensor09 -D Sensor10 -D           #
#                          xController01 -D xController02 -D xController03    #
#                          -D xController4 -D xController05 -D xController06  #
#                          -D xController07 -D xController08 -D               #
#                          xController09 -D Controller10 -lC                  #
#                          "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  DHT11     #
#                          Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë                   #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\EndDeviceEB-Pro\Lis #
#                          t\" -lA "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø    #
#                          DHT11 Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë             #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\EndDeviceEB-Pro\Lis #
#                          t\" --diag_suppress Pe001,Pa010 -o                 #
#                          "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  DHT11     #
#                          Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë                   #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\EndDeviceEB-Pro\Obj #
#                          \" -e --require_prototypes --debug --core=plain    #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 8 -I "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü #
#                          \ZIgbee\¿ª¹Ø  DHT11 Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷        #
#                          ¾«¼ò´úÂë Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Pro #
#                          jects\zstack\Samples\SampleApp\CC2530DB\" -I       #
#                          "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  DHT11     #
#                          Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë                   #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\..\SOURCE\" -I      #
#                          "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  DHT11     #
#                          Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë                   #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\..\..\..\ZMAIN\TI25 #
#                          30DB\" -I "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  #
#                           DHT11 Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë            #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMP #
#                          ONENTS\MT\" -I "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\ #
#                          ¿ª¹Ø  DHT11 Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë       #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMP #
#                          ONENTS\HAL\INCLUDE\" -I "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈ #
#                          ü\ZIgbee\¿ª¹Ø  DHT11 Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷       #
#                          ¾«¼ò´úÂë Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Pro #
#                          jects\zstack\Samples\SampleApp\CC2530DB\..\..\..\. #
#                          .\..\COMPONENTS\HAL\TARGET\CC2530EB\" -I           #
#                          "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  DHT11     #
#                          Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë                   #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMP #
#                          ONENTS\OSAL\MCU\CCSOC\" -I                         #
#                          "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  DHT11     #
#                          Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë                   #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMP #
#                          ONENTS\OSAL\INCLUDE\" -I                           #
#                          "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  DHT11     #
#                          Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë                   #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMP #
#                          ONENTS\STACK\AF\" -I "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\Z #
#                          Igbee\¿ª¹Ø  DHT11 Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷          #
#                          ¾«¼ò´úÂë Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Pro #
#                          jects\zstack\Samples\SampleApp\CC2530DB\..\..\..\. #
#                          .\..\COMPONENTS\STACK\NWK\" -I                     #
#                          "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  DHT11     #
#                          Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë                   #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMP #
#                          ONENTS\STACK\SEC\" -I "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ #
#                          ZIgbee\¿ª¹Ø  DHT11 Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷         #
#                          ¾«¼ò´úÂë Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Pro #
#                          jects\zstack\Samples\SampleApp\CC2530DB\..\..\..\. #
#                          .\..\COMPONENTS\STACK\SAPI\" -I                    #
#                          "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  DHT11     #
#                          Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë                   #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMP #
#                          ONENTS\STACK\SYS\" -I "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ #
#                          ZIgbee\¿ª¹Ø  DHT11 Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷         #
#                          ¾«¼ò´úÂë Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Pro #
#                          jects\zstack\Samples\SampleApp\CC2530DB\..\..\..\. #
#                          .\..\COMPONENTS\STACK\ZDO\" -I                     #
#                          "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  DHT11     #
#                          Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë                   #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMP #
#                          ONENTS\ZMAC\F8W\" -I "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\Z #
#                          Igbee\¿ª¹Ø  DHT11 Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷          #
#                          ¾«¼ò´úÂë Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Pro #
#                          jects\zstack\Samples\SampleApp\CC2530DB\..\..\..\. #
#                          .\..\COMPONENTS\ZMAC\" -I                          #
#                          "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  DHT11     #
#                          Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë                   #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMP #
#                          ONENTS\SERVICES\SADDR\" -I                         #
#                          "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  DHT11     #
#                          Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë                   #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMP #
#                          ONENTS\SERVICES\SDATA\" -I                         #
#                          "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  DHT11     #
#                          Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë                   #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMP #
#                          ONENTS\MAC\INCLUDE\" -I "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈ #
#                          ü\ZIgbee\¿ª¹Ø  DHT11 Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷       #
#                          ¾«¼ò´úÂë Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Pro #
#                          jects\zstack\Samples\SampleApp\CC2530DB\..\..\..\. #
#                          .\..\COMPONENTS\MAC\HIGH_LEVEL\" -I                #
#                          "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  DHT11     #
#                          Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë                   #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMP #
#                          ONENTS\MAC\LOW_LEVEL\srf04\" -I                    #
#                          "J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  DHT11     #
#                          Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë                   #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMP #
#                          ONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\" -I        #
#                          "D:\Program Files (x86)\IAR Systems\Embedded       #
#                          Workbench 5.4\8051\INC\" -I "D:\Program Files      #
#                          (x86)\IAR Systems\Embedded Workbench               #
#                          5.4\8051\INC\CLIB\" -Ohz                           #
#    List file          =  J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  DHT11      #
#                          Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë                   #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\EndDeviceEB-Pro\Lis #
#                          t\hal_key.lst                                      #
#    Object file        =  J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  DHT11      #
#                          Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë                   #
#                          Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2530DB\EndDeviceEB-Pro\Obj #
#                          \hal_key.r51                                       #
#                                                                             #
#                                                                             #
###############################################################################

J:\ÏîÄ¿Á·Ï°\ÑÐ¾¿Éúµç×Ó´óÈü\ZIgbee\¿ª¹Ø  DHT11 Ê÷Ý®ÅÉ Ôö¼Ó10½Úµã´«¸ÐÆ÷ ¾«¼ò´úÂë Ôö¼Ó½Úµã123\ZStack-CC2530-2.2.0-1.3.0\Components\hal\target\CC2530EB\hal_key.c
      1          /**************************************************************************************************
      2            Filename:       hal_key.c
      3            Revised:        $Date: 2008-12-15 07:19:03 -0800 (Mon, 15 Dec 2008) $
      4            Revision:       $Revision: 18611 $
      5          
      6            Description:    This file contains the interface to the HAL KEY Service.
      7          
      8          
      9            Copyright 2006-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          /*********************************************************************
     40           NOTE: If polling is used, the hal_driver task schedules the KeyRead()
     41                 to occur every 100ms.  This should be long enough to naturally
     42                 debounce the keys.  The KeyRead() function remembers the key
     43                 state of the previous poll and will only return a non-zero
     44                 value if the key state changes.
     45          
     46           NOTE: If interrupts are used, the KeyRead() function is scheduled
     47                 25ms after the interrupt occurs by the ISR.  This delay is used
     48                 for key debouncing.  The ISR disables any further Key interrupt
     49                 until KeyRead() is executed.  KeyRead() will re-enable Key
     50                 interrupts after executing.  Unlike polling, when interrupts
     51                 are enabled, the previous key state is not remembered.  This
     52                 means that KeyRead() will return the current state of the keys
     53                 (not a change in state of the keys).
     54          
     55           NOTE: If interrupts are used, the KeyRead() fucntion is scheduled by
     56                 the ISR.  Therefore, the joystick movements will only be detected
     57                 during a pushbutton interrupt caused by S1 or the center joystick
     58                 pushbutton.
     59          
     60           NOTE: When a switch like S1 is pushed, the S1 signal goes from a normally
     61                 high state to a low state.  This transition is typically clean.  The
     62                 duration of the low state is around 200ms.  When the signal returns
     63                 to the high state, there is a high likelihood of signal bounce, which
     64                 causes a unwanted interrupts.  Normally, we would set the interrupt
     65                 edge to falling edge to generate an interrupt when S1 is pushed, but
     66                 because of the signal bounce, it is better to set the edge to rising
     67                 edge to generate an interrupt when S1 is released.  The debounce logic
     68                 can then filter out the signal bounce.  The result is that we typically
     69                 get only 1 interrupt per button push.  This mechanism is not totally
     70                 foolproof because occasionally, signal bound occurs during the falling
     71                 edge as well.  A similar mechanism is used to handle the joystick
     72                 pushbutton on the DB.  For the EB, we do not have independent control
     73                 of the interrupt edge for the S1 and center joystick pushbutton.  As
     74                 a result, only one or the other pushbuttons work reasonably well with
     75                 interrupts.  The default is the make the S1 switch on the EB work more
     76                 reliably.
     77          
     78          *********************************************************************/
     79          
     80          /**************************************************************************************************
     81           *                                            INCLUDES
     82           **************************************************************************************************/
     83          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x89
   \   unsigned char volatile __sfr P0IFG
   \                     P0IFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8b
   \   unsigned char volatile __sfr P2IFG
   \                     P2IFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8c
   \   unsigned char volatile __sfr PICTL
   \                     PICTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa0
   \   union <unnamed> volatile __sfr _A_P2
   \                     _A_P2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xab
   \   unsigned char volatile __sfr P0IEN
   \                     P0IEN:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc0
   \   union <unnamed> volatile __sfr _A_IRCON
   \                     _A_IRCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe8
   \   union <unnamed> volatile __sfr _A_IRCON2
   \                     _A_IRCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1
     84          #include "hal_defs.h"
     85          #include "hal_types.h"
     86          #include "hal_drivers.h"
     87          #include "hal_adc.h"
     88          #include "hal_key.h"
     89          #include "osal.h"
     90          
     91          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
     92          
     93          /**************************************************************************************************
     94           *                                              MACROS
     95           **************************************************************************************************/
     96          
     97          /**************************************************************************************************
     98           *                                            CONSTANTS
     99           **************************************************************************************************/
    100          #define HAL_KEY_RISING_EDGE   0
    101          #define HAL_KEY_FALLING_EDGE  1
    102          
    103          #define HAL_KEY_DEBOUNCE_VALUE  25
    104          #define HAL_KEY_POLLING_VALUE   100
    105          
    106          /* CPU port interrupt */
    107          #define HAL_KEY_CPU_PORT_0_IF P0IF
    108          #define HAL_KEY_CPU_PORT_2_IF P2IF
    109          
    110          /* SW_6 is at P0.5 */
    111          #define HAL_KEY_SW_6_PORT   P0
    112          #define HAL_KEY_SW_6_BIT    BV(5)
    113          #define HAL_KEY_SW_6_SEL    P0SEL
    114          #define HAL_KEY_SW_6_DIR    P0DIR
    115          
    116          /* edge interrupt */
    117          #define HAL_KEY_SW_6_EDGEBIT  BV(0) //P0ICON
    118          #define HAL_KEY_SW_6_EDGE     HAL_KEY_FALLING_EDGE
    119          
    120          
    121          /* SW_6 interrupts */
    122          #define HAL_KEY_SW_6_IEN      IEN1  /* CPU interrupt mask register */
    123          #define HAL_KEY_SW_6_IENBIT   BV(5) /* Mask bit for all of Port_0 */
    124          #define HAL_KEY_SW_6_ICTL     P0IEN /* Port Interrupt Control register */
    125          #define HAL_KEY_SW_6_ICTLBIT  BV(5) /* P0IEN - P0.1 enable/disable bit */
    126          #define HAL_KEY_SW_6_PXIFG    P0IFG /* Interrupt flag at source */
    127          
    128          #define HAL_KEY_SW_7_EN     TRUE
    129          
    130          /* SW_7 is at P0.4 */
    131          #define HAL_KEY_SW_7_PORT   P0
    132          #define HAL_KEY_SW_7_BIT    BV(4)
    133          #define HAL_KEY_SW_7_SEL    P0SEL
    134          #define HAL_KEY_SW_7_DIR    P0DIR
    135          
    136          /* edge interrupt */
    137          #define HAL_KEY_SW_7_EDGEBIT  BV(0) //P0ICON
    138          #define HAL_KEY_SW_7_EDGE     HAL_KEY_FALLING_EDGE
    139          
    140          
    141          /* SW_7 interrupts */
    142          #define HAL_KEY_SW_7_IEN      IEN1  /* CPU interrupt mask register */
    143          #define HAL_KEY_SW_7_IENBIT   BV(5) /* Mask bit for all of Port_0 */
    144          #define HAL_KEY_SW_7_ICTL     P0IEN /* Port Interrupt Control register */
    145          #define HAL_KEY_SW_7_ICTLBIT  BV(4) /* P0IEN - P0.1 enable/disable bit */
    146          #define HAL_KEY_SW_7_PXIFG    P0IFG /* Interrupt flag at source */
    147          
    148          /* SW_5 is at P0.6 */
    149          #define HAL_KEY_SW_5_PORT   P0
    150          #define HAL_KEY_SW_5_BIT    BV(6)
    151          #define HAL_KEY_SW_5_SEL    P0SEL
    152          #define HAL_KEY_SW_5_DIR    P0DIR
    153          
    154          /* edge interrupt */
    155          #define HAL_KEY_SW_5_EDGEBIT  BV(0)
    156          #define HAL_KEY_SW_5_EDGE     HAL_KEY_FALLING_EDGE
    157          
    158          /* SW_5 interrupts */
    159          #define HAL_KEY_SW_5_IEN      IEN1  /* CPU interrupt mask register */
    160          #define HAL_KEY_SW_5_IENBIT   BV(5) /* Mask bit for all of Port_0 */
    161          #define HAL_KEY_SW_5_ICTL     P0IEN /* Port Interrupt Control register */
    162          #define HAL_KEY_SW_5_ICTLBIT  BV(6) /* P0IEN - P0.1 enable/disable bit */
    163          #define HAL_KEY_SW_5_PXIFG    P0IFG /* Interrupt flag at source */
    164          
    165          /* SW_4 is at P0.6 */
    166          #define HAL_KEY_SW_4_PORT   P0
    167          #define HAL_KEY_SW_4_BIT    BV(6)
    168          #define HAL_KEY_SW_4_SEL    P0SEL
    169          #define HAL_KEY_SW_4_DIR    P0DIR
    170          
    171          /* edge interrupt */
    172          #define HAL_KEY_SW_4_EDGEBIT  BV(0)
    173          #define HAL_KEY_SW_4_EDGE     HAL_KEY_FALLING_EDGE
    174          
    175          /* SW_4 interrupts */
    176          #define HAL_KEY_SW_4_IEN      IEN1  /* CPU interrupt mask register */
    177          #define HAL_KEY_SW_4_IENBIT   BV(5) /* Mask bit for all of Port_0 */
    178          #define HAL_KEY_SW_4_ICTL     P0IEN /* Port Interrupt Control register */
    179          #define HAL_KEY_SW_4_ICTLBIT  BV(6) /* P0IEN - P0.1 enable/disable bit */
    180          #define HAL_KEY_SW_4_PXIFG    P0IFG /* Interrupt flag at source */
    181          
    182          
    183          
    184          
    185          /* Joy stick move at P2.0 */
    186          #define HAL_KEY_JOY_MOVE_PORT   P2
    187          #define HAL_KEY_JOY_MOVE_BIT    BV(0)
    188          #define HAL_KEY_JOY_MOVE_SEL    P2SEL
    189          #define HAL_KEY_JOY_MOVE_DIR    P2DIR
    190          
    191          /* edge interrupt */
    192          #define HAL_KEY_JOY_MOVE_EDGEBIT  BV(3)
    193          #define HAL_KEY_JOY_MOVE_EDGE     HAL_KEY_FALLING_EDGE
    194          
    195          /* Joy move interrupts */
    196          #define HAL_KEY_JOY_MOVE_IEN      IEN2  /* CPU interrupt mask register */
    197          #define HAL_KEY_JOY_MOVE_IENBIT   BV(1) /* Mask bit for all of Port_2 */
    198          #define HAL_KEY_JOY_MOVE_ICTL     P2IEN /* Port Interrupt Control register */
    199          #define HAL_KEY_JOY_MOVE_ICTLBIT  BV(0) /* P2IENL - P2.0<->P2.3 enable/disable bit */
    200          #define HAL_KEY_JOY_MOVE_PXIFG    P2IFG /* Interrupt flag at source */
    201          
    202          #define HAL_KEY_JOY_CHN   HAL_ADC_CHANNEL_6
    203          
    204          
    205          /**************************************************************************************************
    206           *                                            TYPEDEFS
    207           **************************************************************************************************/
    208          
    209          
    210          /**************************************************************************************************
    211           *                                        GLOBAL VARIABLES
    212           **************************************************************************************************/

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    213          static uint8 halKeySavedKeys;     /* used to store previous key state in polling mode */
   \                     halKeySavedKeys:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    214          static halKeyCBack_t pHalKeyProcessFunction;
   \                     pHalKeyProcessFunction:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    215          static uint8 HalKeyConfigured;
   \                     HalKeyConfigured:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    216          bool Hal_KeyIntEnable;            /* interrupt enable/disable flag */
   \                     Hal_KeyIntEnable:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    217          
    218          /**************************************************************************************************
    219           *                                        FUNCTIONS - Local
    220           **************************************************************************************************/
    221          void halProcessKeyInterrupt(void);
    222          uint8 halGetJoyKeyInput(void);
    223          
    224          
    225          
    226          /**************************************************************************************************
    227           *                                        FUNCTIONS - API
    228           **************************************************************************************************/
    229          
    230          
    231          /**************************************************************************************************
    232           * @fn      HalKeyInit
    233           *
    234           * @brief   Initilize Key Service
    235           *
    236           * @param   none
    237           *
    238           * @return  None
    239           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    240          void HalKeyInit( void )
   \                     HalKeyInit:
    241          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    242            /* Initialize previous key to 0 */
    243            halKeySavedKeys = 0;
   \   000004   E4           CLR     A
   \   000005   90....       MOV     DPTR,#halKeySavedKeys
   \   000008   F0           MOVX    @DPTR,A
    244          
    245            HAL_KEY_SW_6_SEL &= ~(HAL_KEY_SW_6_BIT);    /* Set pin function to GPIO */
   \   000009   53F3DF       ANL     0xf3,#0xdf
    246            HAL_KEY_SW_6_DIR &= ~(HAL_KEY_SW_6_BIT);    /* Set pin direction to Input */
   \   00000C   53FDDF       ANL     0xfd,#0xdf
    247            
    248            HAL_KEY_SW_7_SEL &= ~(HAL_KEY_SW_7_BIT);    /* Set pin function to GPIO */
   \   00000F   53F3EF       ANL     0xf3,#0xef
    249            HAL_KEY_SW_7_DIR &= ~(HAL_KEY_SW_7_BIT);    /* Set pin direction to Input */
   \   000012   53FDEF       ANL     0xfd,#0xef
    250            
    251            
    252            HAL_KEY_SW_5_SEL &= ~(HAL_KEY_SW_5_BIT);    /* Set pin function to GPIO */
   \   000015   53F3BF       ANL     0xf3,#0xbf
    253            HAL_KEY_SW_5_DIR &= ~(HAL_KEY_SW_5_BIT);    /* Set pin direction to Input */
   \   000018   53FDBF       ANL     0xfd,#0xbf
    254            
    255            
    256            HAL_KEY_SW_4_SEL &= ~(HAL_KEY_SW_4_BIT);    /* Set pin function to GPIO */
   \   00001B   53F3BF       ANL     0xf3,#0xbf
    257            HAL_KEY_SW_4_DIR &= ~(HAL_KEY_SW_4_BIT);    /* Set pin direction to Input */
   \   00001E   53FDBF       ANL     0xfd,#0xbf
    258          
    259           // HAL_KEY_JOY_MOVE_SEL &= ~(HAL_KEY_JOY_MOVE_BIT); /* Set pin function to GPIO */
    260          //  HAL_KEY_JOY_MOVE_DIR &= ~(HAL_KEY_JOY_MOVE_BIT); /* Set pin direction to Input */
    261          
    262          
    263            /* Initialize callback function */
    264            pHalKeyProcessFunction  = NULL;
   \   000021   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   F0           MOVX    @DPTR,A
    265          
    266            /* Start with key is not configured */
    267            HalKeyConfigured = FALSE;
   \   000027   90....       MOV     DPTR,#HalKeyConfigured
   \   00002A   F0           MOVX    @DPTR,A
    268          }
   \   00002B                REQUIRE ?Subroutine0
   \   00002B                REQUIRE P0SEL
   \   00002B                REQUIRE P0DIR
   \   00002B                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    269          
    270          
    271          /**************************************************************************************************
    272           * @fn      HalKeyConfig
    273           *
    274           * @brief   Configure the Key serivce
    275           *
    276           * @param   interruptEnable - TRUE/FALSE, enable/disable interrupt
    277           *          cback - pointer to the CallBack function
    278           *
    279           * @return  None
    280           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    281          void HalKeyConfig (bool interruptEnable, halKeyCBack_t cback)
   \                     HalKeyConfig:
    282          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
    283            /* Enable/Disable Interrupt or */
    284            Hal_KeyIntEnable = interruptEnable;
   \   000006   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   000009   F0           MOVX    @DPTR,A
    285          
    286            /* Register the callback fucntion */
    287            pHalKeyProcessFunction = cback;
   \   00000A   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   00000D   EA           MOV     A,R2
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   EB           MOV     A,R3
   \   000011   F0           MOVX    @DPTR,A
    288          
    289            /* Determine if interrupt is enable or not */
    290            if (Hal_KeyIntEnable)
   \   000012   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   000015   E0           MOVX    A,@DPTR
   \   000016   6044         JZ      ??HalKeyConfig_0
    291            {
    292              /* Rising/Falling edge configuratinn */
    293          
    294              PICTL &= ~(HAL_KEY_SW_6_EDGEBIT);    /* Clear the edge bit */
   \   000018   538CFE       ANL     0x8c,#0xfe
    295              PICTL &= ~(HAL_KEY_SW_7_EDGEBIT);    /* Clear the edge bit */
   \   00001B   538CFE       ANL     0x8c,#0xfe
    296              PICTL &= ~(HAL_KEY_SW_5_EDGEBIT);    /* Clear the edge bit */
   \   00001E   538CFE       ANL     0x8c,#0xfe
    297              PICTL &= ~(HAL_KEY_SW_4_EDGEBIT);    /* Clear the edge bit */
   \   000021   538CFE       ANL     0x8c,#0xfe
    298              
    299              /* For falling edge, the bit must be set. */
    300            #if (HAL_KEY_SW_6_EDGE == HAL_KEY_FALLING_EDGE)
    301              PICTL |= HAL_KEY_SW_6_EDGEBIT;
   \   000024   438C01       ORL     0x8c,#0x1
    302            #endif
    303          //    PICTL &= ~(HAL_KEY_SW_7_EDGEBIT);    /* Clear the edge bit */
    304              /* For falling edge, the bit must be set. */
    305            #if (HAL_KEY_SW_7_EDGE == HAL_KEY_FALLING_EDGE)
    306              PICTL |= HAL_KEY_SW_7_EDGEBIT;
   \   000027   438C01       ORL     0x8c,#0x1
    307            #endif
    308              
    309            #if (HAL_KEY_SW_5_EDGE == HAL_KEY_FALLING_EDGE)
    310              PICTL |= HAL_KEY_SW_5_EDGEBIT;
   \   00002A   438C01       ORL     0x8c,#0x1
    311            #endif
    312              
    313            #if (HAL_KEY_SW_4_EDGE == HAL_KEY_FALLING_EDGE)
    314              PICTL |= HAL_KEY_SW_4_EDGEBIT;
   \   00002D   438C01       ORL     0x8c,#0x1
    315            #endif
    316          
    317          
    318          
    319              /* Interrupt configuration:
    320               * - Enable interrupt generation at the port
    321               * - Enable CPU interrupt
    322               * - Clear any pending interrupt
    323               */
    324              HAL_KEY_SW_6_ICTL |= HAL_KEY_SW_6_ICTLBIT;
   \   000030   43AB20       ORL     0xab,#0x20
    325              HAL_KEY_SW_6_IEN |= HAL_KEY_SW_6_IENBIT;
   \   000033   D2BD         SETB    0xb8.5
    326              HAL_KEY_SW_6_PXIFG = ~(HAL_KEY_SW_6_BIT);
   \   000035   7589DF       MOV     0x89,#-0x21
    327          
    328              HAL_KEY_SW_7_ICTL |= HAL_KEY_SW_7_ICTLBIT;
   \   000038   43AB10       ORL     0xab,#0x10
    329              HAL_KEY_SW_7_IEN |= HAL_KEY_SW_7_IENBIT;
   \   00003B   D2BD         SETB    0xb8.5
    330              HAL_KEY_SW_7_PXIFG = ~(HAL_KEY_SW_7_BIT);
   \   00003D   7589EF       MOV     0x89,#-0x11
    331              
    332              
    333              HAL_KEY_SW_5_ICTL |= HAL_KEY_SW_5_ICTLBIT;
   \   000040   12....       LCALL   ?Subroutine3 & 0xFFFF
    334              HAL_KEY_SW_5_IEN |= HAL_KEY_SW_5_IENBIT;
    335              HAL_KEY_SW_5_PXIFG = ~(HAL_KEY_SW_5_BIT);
    336              
    337              HAL_KEY_SW_4_ICTL |= HAL_KEY_SW_4_ICTLBIT;
   \                     ??CrossCallReturnLabel_0:
   \   000043   12....       LCALL   ?Subroutine3 & 0xFFFF
    338              HAL_KEY_SW_4_IEN |= HAL_KEY_SW_4_IENBIT;
    339              HAL_KEY_SW_4_PXIFG = ~(HAL_KEY_SW_4_BIT);
    340          
    341          
    342              /* Rising/Falling edge configuratinn */
    343          
    344            //  HAL_KEY_JOY_MOVE_ICTL &= ~(HAL_KEY_JOY_MOVE_EDGEBIT);    /* Clear the edge bit */
    345              /* For falling edge, the bit must be set. */
    346            #if (HAL_KEY_JOY_MOVE_EDGE == HAL_KEY_FALLING_EDGE)
    347            //  HAL_KEY_JOY_MOVE_ICTL |= HAL_KEY_JOY_MOVE_EDGEBIT;
    348            #endif
    349          
    350          
    351              /* Interrupt configuration:
    352               * - Enable interrupt generation at the port
    353               * - Enable CPU interrupt
    354               * - Clear any pending interrupt
    355               */
    356             // HAL_KEY_JOY_MOVE_ICTL |= HAL_KEY_JOY_MOVE_ICTLBIT;
    357            //  HAL_KEY_JOY_MOVE_IEN |= HAL_KEY_JOY_MOVE_IENBIT;
    358            //  HAL_KEY_JOY_MOVE_PXIFG = ~(HAL_KEY_JOY_MOVE_BIT);
    359          
    360          
    361              /* Do this only after the hal_key is configured - to work with sleep stuff */
    362              if (HalKeyConfigured == TRUE)
   \                     ??CrossCallReturnLabel_1:
   \   000046   90....       MOV     DPTR,#HalKeyConfigured
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   6401         XRL     A,#0x1
   \   00004C   7032         JNZ     ??HalKeyConfig_1
    363              {
    364                osal_stop_timerEx( Hal_TaskID, HAL_KEY_EVENT);  /* Cancel polling if active */
   \   00004E                ; Setup parameters for call to function osal_stop_timerEx
   \   00004E   7A01         MOV     R2,#0x1
   \   000050   7B00         MOV     R3,#0x0
   \   000052   90....       MOV     DPTR,#Hal_TaskID
   \   000055   E0           MOVX    A,@DPTR
   \   000056   F9           MOV     R1,A
   \   000057   12....       LCALL   ??osal_stop_timerEx?relay
   \   00005A   8024         SJMP    ??HalKeyConfig_1
    365              }
    366            }
    367            else    /* Interrupts NOT enabled */
    368            {
    369              HAL_KEY_SW_6_ICTL &= ~(HAL_KEY_SW_6_ICTLBIT); /* don't generate interrupt   */
   \                     ??HalKeyConfig_0:
   \   00005C   53ABDF       ANL     0xab,#0xdf
    370              HAL_KEY_SW_6_IEN &= ~(HAL_KEY_SW_6_IENBIT);   /* Clear interrupt enable bit */
   \   00005F   C2BD         CLR     0xb8.5
    371              HAL_KEY_SW_7_ICTL &= ~(HAL_KEY_SW_7_ICTLBIT); /* don't generate interrupt   */
   \   000061   53ABEF       ANL     0xab,#0xef
    372              HAL_KEY_SW_7_IEN &= ~(HAL_KEY_SW_7_IENBIT);   /* Clear interrupt enable bit */
   \   000064   C2BD         CLR     0xb8.5
    373              
    374              HAL_KEY_SW_5_ICTL &= ~(HAL_KEY_SW_5_ICTLBIT); /* don't generate interrupt */
   \   000066   53ABBF       ANL     0xab,#0xbf
    375              HAL_KEY_SW_5_IEN &= ~(HAL_KEY_SW_5_IENBIT);   /* Clear interrupt enable bit */
   \   000069   C2BD         CLR     0xb8.5
    376              
    377              HAL_KEY_SW_4_ICTL &= ~(HAL_KEY_SW_4_ICTLBIT); /* don't generate interrupt */
   \   00006B   53ABBF       ANL     0xab,#0xbf
    378              HAL_KEY_SW_4_IEN &= ~(HAL_KEY_SW_4_IENBIT);   /* Clear interrupt enable bit */
   \   00006E   C2BD         CLR     0xb8.5
    379          
    380              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_POLLING_VALUE);    /* Kick off polling */
   \   000070                ; Setup parameters for call to function osal_start_timerEx
   \   000070   7C64         MOV     R4,#0x64
   \   000072   7D00         MOV     R5,#0x0
   \   000074   7A01         MOV     R2,#0x1
   \   000076   7B00         MOV     R3,#0x0
   \   000078   90....       MOV     DPTR,#Hal_TaskID
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   F9           MOV     R1,A
   \   00007D   12....       LCALL   ??osal_start_timerEx?relay
    381            }
    382          
    383            /* Key now is configured */
    384            HalKeyConfigured = TRUE;
   \                     ??HalKeyConfig_1:
   \   000080   7401         MOV     A,#0x1
   \   000082   90....       MOV     DPTR,#HalKeyConfigured
   \   000085   F0           MOVX    @DPTR,A
    385          }
   \   000086   FF           MOV     R7,A
   \   000087   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00008A                REQUIRE P0IFG
   \   00008A                REQUIRE P0IEN
   \   00008A                REQUIRE _A_IEN1
   \   00008A                REQUIRE PICTL

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   43AB40       ORL     0xab,#0x40
   \   000003   D2BD         SETB    0xb8.5
   \   000005   7589BF       MOV     0x89,#-0x41
   \   000008   22           RET
    386          
    387          
    388          /**************************************************************************************************
    389           * @fn      HalKeyRead
    390           *
    391           * @brief   Read the current value of a key
    392           *
    393           * @param   None
    394           *
    395           * @return  keys - current keys status
    396           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    397          uint8 HalKeyRead ( void )
   \                     HalKeyRead:
    398          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    399            uint8 keys = 0;
   \   000005   7E00         MOV     R6,#0x0
    400          
    401          #ifdef HAL_BOARD_CC2530EB_REV17
    402            if ( (HAL_KEY_SW_6_PORT & HAL_KEY_SW_6_BIT))    /* Key is active high */
    403          #elif defined (HAL_BOARD_CC2530EB_REV13)
    404            if (!(HAL_KEY_SW_6_PORT & HAL_KEY_SW_6_BIT))    /* Key is active low */
   \   000007   A285         MOV     C,0x80.5
   \   000009   4002         JC      ??HalKeyRead_0
    405          #endif
    406            {
    407              keys |= HAL_KEY_SW_6;
   \   00000B   7E20         MOV     R6,#0x20
    408            }
    409          #ifdef HAL_BOARD_CC2530EB_REV17
    410            if ( (HAL_KEY_SW_7_PORT & HAL_KEY_SW_7_BIT))    /* Key is active high */
    411          #elif defined (HAL_BOARD_CC2530EB_REV13)
    412            if (!(HAL_KEY_SW_7_PORT & HAL_KEY_SW_7_BIT))    /* Key is active low */
   \                     ??HalKeyRead_0:
   \   00000D   A284         MOV     C,0x80.4
   \   00000F   4004         JC      ??HalKeyRead_1
    413          #endif
    414            {
    415              keys |= HAL_KEY_SW_7;
   \   000011   EE           MOV     A,R6
   \   000012   D2E6         SETB    0xE0 /* A   */.6
   \   000014   FE           MOV     R6,A
    416            }
    417          
    418          
    419           // if ((HAL_KEY_JOY_MOVE_PORT & HAL_KEY_JOY_MOVE_BIT))  /* Key is active low */
    420            {
    421              keys |= halGetJoyKeyInput();
    422            }
    423          
    424            return keys;
   \                     ??HalKeyRead_1:
   \   000015                ; Setup parameters for call to function halGetJoyKeyInput
   \   000015   12....       LCALL   ??halGetJoyKeyInput?relay
   \   000018   E9           MOV     A,R1
   \   000019   4E           ORL     A,R6
   \   00001A                REQUIRE ?Subroutine1
   \   00001A                REQUIRE _A_P0
   \   00001A                ; // Fall through to label ?Subroutine1
    425          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   F9           MOV     R1,A
   \   000001                REQUIRE ??Subroutine5_0
   \   000001                ; // Fall through to label ??Subroutine5_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine5_0:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    426          
    427          
    428          /**************************************************************************************************
    429           * @fn      HalKeyPoll
    430           *
    431           * @brief   Called by hal_driver to poll the keys
    432           *
    433           * @param   None
    434           *
    435           * @return  None
    436           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    437          void HalKeyPoll (void)
   \                     HalKeyPoll:
    438          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    439            uint8 keys = 0;
   \   000005   75..00       MOV     ?V0 + 0,#0x0
    440          
    441            if (!(HAL_KEY_SW_6_PORT & HAL_KEY_SW_6_BIT))    /* Key is active low */
   \   000008   A285         MOV     C,0x80.5
   \   00000A   4003         JC      ??HalKeyPoll_0
    442            {
    443              keys |= HAL_KEY_SW_6;
   \   00000C   75..20       MOV     ?V0 + 0,#0x20
    444            }
    445            if (!(HAL_KEY_SW_7_PORT & HAL_KEY_SW_7_BIT))    /* Key is active low */
   \                     ??HalKeyPoll_0:
   \   00000F   A284         MOV     C,0x80.4
   \   000011   4006         JC      ??HalKeyPoll_1
    446            {
    447              keys |= HAL_KEY_SW_7;
   \   000013   E5..         MOV     A,?V0 + 0
   \   000015   D2E6         SETB    0xE0 /* A   */.6
   \   000017   F5..         MOV     ?V0 + 0,A
    448            }
    449          
    450           // if ((HAL_KEY_JOY_MOVE_PORT & HAL_KEY_JOY_MOVE_BIT))  /* Key is active HIGH */
    451            {
    452              keys |= halGetJoyKeyInput();
   \                     ??HalKeyPoll_1:
   \   000019                ; Setup parameters for call to function halGetJoyKeyInput
   \   000019   12....       LCALL   ??halGetJoyKeyInput?relay
   \   00001C   E9           MOV     A,R1
   \   00001D   42..         ORL     ?V0 + 0,A
    453            }
    454          
    455            /* If interrupts are not enabled, previous key status and current key status
    456             * are compared to find out if a key has changed status.
    457             */
    458            if (!Hal_KeyIntEnable)
   \   00001F   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   000022   E0           MOVX    A,@DPTR
   \   000023   700B         JNZ     ??HalKeyPoll_2
    459            {
    460              if (keys == halKeySavedKeys)
   \   000025   90....       MOV     DPTR,#halKeySavedKeys
   \   000028   E0           MOVX    A,@DPTR
   \   000029   65..         XRL     A,?V0 + 0
   \   00002B   604B         JZ      ??HalKeyPoll_3
    461              {
    462                /* Exit - since no keys have changed */
    463                return;
    464              }
    465              /* Store the current keys for comparation next time */
    466              halKeySavedKeys = keys;
   \   00002D   E5..         MOV     A,?V0 + 0
   \   00002F   F0           MOVX    @DPTR,A
    467            }
    468            else
    469            {
    470              /* Key interrupt handled here */
    471            }
    472          
    473            
    474             if (HAL_PUSH_BUTTON1())
   \                     ??HalKeyPoll_2:
   \   000030   A2A1         MOV     C,0xa0.1
   \   000032   4006         JC      ??HalKeyPoll_4
    475            {
    476              keys |= HAL_KEY_SW_6;
   \   000034   E5..         MOV     A,?V0 + 0
   \   000036   D2E5         SETB    0xE0 /* A   */.5
   \   000038   F5..         MOV     ?V0 + 0,A
    477            }
    478            
    479            if (HAL_PUSH_BUTTON2())
   \                     ??HalKeyPoll_4:
   \   00003A   A284         MOV     C,0x80.4
   \   00003C   4006         JC      ??HalKeyPoll_5
    480            {
    481              keys |= HAL_KEY_SW_7;
   \   00003E   E5..         MOV     A,?V0 + 0
   \   000040   D2E6         SETB    0xE0 /* A   */.6
   \   000042   F5..         MOV     ?V0 + 0,A
    482            }
    483            
    484            if (HAL_PUSH_BUTTON3())
   \                     ??HalKeyPoll_5:
   \   000044   A286         MOV     C,0x80.6
   \   000046   4006         JC      ??HalKeyPoll_6
    485            {
    486              keys |= HAL_KEY_SW_5;
   \   000048   E5..         MOV     A,?V0 + 0
   \   00004A   D2E2         SETB    0xE0 /* A   */.2
   \   00004C   F5..         MOV     ?V0 + 0,A
    487            }
    488            
    489            if (HAL_PUSH_BUTTON4())
   \                     ??HalKeyPoll_6:
   \   00004E   A286         MOV     C,0x80.6
   \   000050   4006         JC      ??HalKeyPoll_7
    490            {
    491              keys |= HAL_KEY_SW_4;
   \   000052   E5..         MOV     A,?V0 + 0
   \   000054   D2E3         SETB    0xE0 /* A   */.3
   \   000056   F5..         MOV     ?V0 + 0,A
    492            }
    493            
    494            
    495            /* Invoke Callback if new keys were depressed */
    496            if (keys && (pHalKeyProcessFunction))
   \                     ??HalKeyPoll_7:
   \   000058   E5..         MOV     A,?V0 + 0
   \   00005A   601C         JZ      ??HalKeyPoll_3
   \   00005C   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   7002         JNZ     ??HalKeyPoll_8
   \   000062   A3           INC     DPTR
   \   000063   E0           MOVX    A,@DPTR
   \                     ??HalKeyPoll_8:
   \   000064   6012         JZ      ??HalKeyPoll_3
    497            {
    498              (pHalKeyProcessFunction) (keys, HAL_KEY_STATE_NORMAL);
   \   000066                ; Setup parameters for indirect call
   \   000066   7A00         MOV     R2,#0x0
   \   000068   A9..         MOV     R1,?V0 + 0
   \   00006A   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   F8           MOV     R0,A
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   F583         MOV     DPH,A
   \   000073   8882         MOV     DPL,R0
   \   000075   12....       LCALL   ?CALL_IND
    499            }
   \                     ??HalKeyPoll_3:
   \   000078   80..         SJMP    ??Subroutine5_0
   \   00007A                REQUIRE _A_P0
   \   00007A                REQUIRE _A_P2
    500          }
    501          
    502          /**************************************************************************************************
    503           * @fn      halGetJoyKeyInput
    504           *
    505           * @brief   Map the ADC value to its corresponding key.
    506           *
    507           * @param   None
    508           *
    509           * @return  keys - current joy key status
    510           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    511          uint8 halGetJoyKeyInput(void)
   \                     halGetJoyKeyInput:
    512          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    513            /* The joystick control is encoded as an analog voltage.
    514             * Read the JOY_LEVEL analog value and map it to joy movement.
    515             */
    516            uint8 adc;
    517            uint8 ksave0 = 0;
   \   000005   7E00         MOV     R6,#0x0
    518            uint8 ksave1;
    519          
    520            /* Keep on reading the ADC until two consecutive key decisions are the same. */
    521            do
    522            {
    523              ksave1 = ksave0;    /* save previouse key reading */
   \                     ??halGetJoyKeyInput_0:
   \   000007   EE           MOV     A,R6
   \   000008   FF           MOV     R7,A
    524          
    525              adc = HalAdcRead (HAL_KEY_JOY_CHN, HAL_ADC_RESOLUTION_8);
   \   000009                ; Setup parameters for call to function HalAdcRead
   \   000009   7A01         MOV     R2,#0x1
   \   00000B   7906         MOV     R1,#0x6
   \   00000D   12....       LCALL   ??HalAdcRead?relay
    526          
    527              if ((adc >= 28) && (adc <= 38))
   \   000010   74E4         MOV     A,#-0x1c
   \   000012   2A           ADD     A,R2
   \   000013   C3           CLR     C
   \   000014   940B         SUBB    A,#0xb
   \   000016   5005         JNC     ??halGetJoyKeyInput_1
    528              {
    529                 ksave0 |= HAL_KEY_LEFT;//HAL_KEY_UP;
   \   000018   EE           MOV     A,R6
   \   000019   D2E3         SETB    0xE0 /* A   */.3
   \   00001B   8023         SJMP    ??halGetJoyKeyInput_2
    530              }
    531              else if ((adc < 28))
   \                     ??halGetJoyKeyInput_1:
   \   00001D   EA           MOV     A,R2
   \   00001E   C3           CLR     C
   \   00001F   941C         SUBB    A,#0x1c
   \   000021   5005         JNC     ??halGetJoyKeyInput_3
    532              {
    533                ksave0 |= HAL_KEY_RIGHT;
   \   000023   EE           MOV     A,R6
   \   000024   D2E1         SETB    0xE0 /* A   */.1
   \   000026   8018         SJMP    ??halGetJoyKeyInput_2
    534              }
    535              else if ((adc >= 60) && (adc <= 73))
   \                     ??halGetJoyKeyInput_3:
   \   000028   74C4         MOV     A,#-0x3c
   \   00002A   2A           ADD     A,R2
   \   00002B   C3           CLR     C
   \   00002C   940E         SUBB    A,#0xe
   \   00002E   5005         JNC     ??halGetJoyKeyInput_4
    536              {
    537                ksave0 |= HAL_KEY_DOWN;//HAL_KEY_LEFT;
   \   000030   EE           MOV     A,R6
   \   000031   D2E4         SETB    0xE0 /* A   */.4
   \   000033   800B         SJMP    ??halGetJoyKeyInput_2
    538              }
    539              else if ((adc >= 89) && (adc <= 100))
   \                     ??halGetJoyKeyInput_4:
   \   000035   74A7         MOV     A,#-0x59
   \   000037   2A           ADD     A,R2
   \   000038   C3           CLR     C
   \   000039   940C         SUBB    A,#0xc
   \   00003B   5004         JNC     ??halGetJoyKeyInput_5
    540              {
    541                ksave0 |= HAL_KEY_UP;//HAL_KEY_CENTER;
   \   00003D   EE           MOV     A,R6
   \   00003E   D2E0         SETB    0xE0 /* A   */.0
   \                     ??halGetJoyKeyInput_2:
   \   000040   FE           MOV     R6,A
    542              }
    543            } while (ksave0 != ksave1);
   \                     ??halGetJoyKeyInput_5:
   \   000041   EF           MOV     A,R7
   \   000042   6E           XRL     A,R6
   \   000043   70C2         JNZ     ??halGetJoyKeyInput_0
    544          
    545            return ksave0;
   \   000045   EE           MOV     A,R6
   \   000046   02....       LJMP    ?Subroutine1 & 0xFFFF
    546          }
    547          
    548          
    549          
    550          
    551          
    552          /**************************************************************************************************
    553           * @fn      halProcessKeyInterrupt
    554           *
    555           * @brief   Checks to see if it's a valid key interrupt, saves interrupt driven key states for
    556           *          processing by HalKeyRead(), and debounces keys by scheduling HalKeyRead() 25ms later.
    557           *
    558           * @param
    559           *
    560           * @return
    561           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    562          void halProcessKeyInterrupt (void)
   \                     halProcessKeyInterrupt:
    563          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    564            bool valid=FALSE;
   \   000004   7A00         MOV     R2,#0x0
    565          
    566            if (HAL_KEY_SW_6_PXIFG & HAL_KEY_SW_6_BIT)  /* Interrupt Flag has been set */
   \   000006   E589         MOV     A,0x89
   \   000008   A2E5         MOV     C,0xE0 /* A   */.5
   \   00000A   5004         JNC     ??halProcessKeyInterrupt_0
    567            {
    568              HAL_KEY_SW_6_PXIFG = ~(HAL_KEY_SW_6_BIT); /* Clear Interrupt Flag */
   \   00000C   7589DF       MOV     0x89,#-0x21
    569              valid = TRUE;
   \   00000F   0A           INC     R2
    570            }
    571            if (HAL_KEY_SW_7_PXIFG & HAL_KEY_SW_7_BIT)  /* Interrupt Flag has been set */
   \                     ??halProcessKeyInterrupt_0:
   \   000010   E589         MOV     A,0x89
   \   000012   A2E4         MOV     C,0xE0 /* A   */.4
   \   000014   5005         JNC     ??halProcessKeyInterrupt_1
    572            {
    573              HAL_KEY_SW_7_PXIFG = ~(HAL_KEY_SW_7_BIT); /* Clear Interrupt Flag */
   \   000016   7589EF       MOV     0x89,#-0x11
    574              valid = TRUE;
   \   000019   7A01         MOV     R2,#0x1
    575            }
    576            
    577            if (HAL_KEY_SW_5_PXIFG & HAL_KEY_SW_5_BIT)  /* Interrupt Flag has been set */
   \                     ??halProcessKeyInterrupt_1:
   \   00001B   E589         MOV     A,0x89
   \   00001D   A2E6         MOV     C,0xE0 /* A   */.6
   \   00001F   5005         JNC     ??halProcessKeyInterrupt_2
    578            {
    579              HAL_KEY_SW_5_PXIFG = ~(HAL_KEY_SW_5_BIT); /* Clear Interrupt Flag */
   \   000021   7589BF       MOV     0x89,#-0x41
    580              valid = TRUE;
   \   000024   7A01         MOV     R2,#0x1
    581            }
    582            
    583            if (HAL_KEY_SW_4_PXIFG & HAL_KEY_SW_4_BIT)  /* Interrupt Flag has been set */
   \                     ??halProcessKeyInterrupt_2:
   \   000026   E589         MOV     A,0x89
   \   000028   A2E6         MOV     C,0xE0 /* A   */.6
   \   00002A   5005         JNC     ??halProcessKeyInterrupt_3
    584            {
    585              HAL_KEY_SW_4_PXIFG = ~(HAL_KEY_SW_4_BIT); /* Clear Interrupt Flag */
   \   00002C   7589BF       MOV     0x89,#-0x41
    586              valid = TRUE;
   \   00002F   7A01         MOV     R2,#0x1
    587            }
    588          
    589          
    590            if (HAL_KEY_JOY_MOVE_PXIFG & HAL_KEY_JOY_MOVE_BIT)  /* Interrupt Flag has been set */
   \                     ??halProcessKeyInterrupt_3:
   \   000031   E58B         MOV     A,0x8b
   \   000033   A2E0         MOV     C,0xE0 /* A   */.0
   \   000035   5005         JNC     ??halProcessKeyInterrupt_4
    591            {
    592              HAL_KEY_JOY_MOVE_PXIFG = ~(HAL_KEY_JOY_MOVE_BIT); /* Clear Interrupt Flag */
   \   000037   758BFE       MOV     0x8b,#-0x2
    593              valid = TRUE;
   \   00003A   8003         SJMP    ??halProcessKeyInterrupt_5
    594            }
    595          
    596            if (valid)
   \                     ??halProcessKeyInterrupt_4:
   \   00003C   EA           MOV     A,R2
   \   00003D   6010         JZ      ??halProcessKeyInterrupt_6
    597            {
    598              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_DEBOUNCE_VALUE);
   \                     ??halProcessKeyInterrupt_5:
   \   00003F                ; Setup parameters for call to function osal_start_timerEx
   \   00003F   7C19         MOV     R4,#0x19
   \   000041   7D00         MOV     R5,#0x0
   \   000043   7A01         MOV     R2,#0x1
   \   000045   7B00         MOV     R3,#0x0
   \   000047   90....       MOV     DPTR,#Hal_TaskID
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   F9           MOV     R1,A
   \   00004C   12....       LCALL   ??osal_start_timerEx?relay
    599            }
    600          }
   \                     ??halProcessKeyInterrupt_6:
   \   00004F   02....       LJMP    ?Subroutine0 & 0xFFFF
   \   000052                REQUIRE P0IFG
   \   000052                REQUIRE P2IFG
    601          
    602          /**************************************************************************************************
    603           * @fn      HalKeyEnterSleep
    604           *
    605           * @brief  - Get called to enter sleep mode
    606           *
    607           * @param
    608           *
    609           * @return
    610           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    611          void HalKeyEnterSleep ( void )
   \                     HalKeyEnterSleep:
    612          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    613          }
   \   000000   02....       LJMP    ?BRET
    614          
    615          /**************************************************************************************************
    616           * @fn      HalKeyExitSleep
    617           *
    618           * @brief   - Get called when sleep is over
    619           *
    620           * @param
    621           *
    622           * @return  - return saved keys
    623           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    624          uint8 HalKeyExitSleep ( void )
   \                     HalKeyExitSleep:
    625          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    626            /* Wake up and read keys */
    627            return ( HalKeyRead () );
   \   000004                ; Setup parameters for call to function HalKeyRead
   \   000004   12....       LCALL   ??HalKeyRead?relay
   \   000007   02....       LJMP    ?Subroutine0 & 0xFFFF
    628          }
    629          
    630          /***************************************************************************************************
    631           *                                    INTERRUPT SERVICE ROUTINE
    632           ***************************************************************************************************/
    633          
    634          /**************************************************************************************************
    635           * @fn      halKeyPort0Isr
    636           *
    637           * @brief   Port0 ISR
    638           *
    639           * @param
    640           *
    641           * @return
    642           **************************************************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    643          HAL_ISR_FUNCTION( halKeyPort0Isr, P0INT_VECTOR )
   \                     halKeyPort0Isr:
    644          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    645            if (HAL_KEY_SW_6_PXIFG & HAL_KEY_SW_6_BIT)
   \   000007   E589         MOV     A,0x89
   \   000009   A2E5         MOV     C,0xE0 /* A   */.5
   \   00000B   5003         JNC     ??CrossCallReturnLabel_2
    646            {
    647              halProcessKeyInterrupt();
   \   00000D                ; Setup parameters for call to function halProcessKeyInterrupt
   \   00000D   12....       LCALL   ?Subroutine4
    648              HAL_KEY_SW_6_PXIFG = 0;
    649            }
    650            
    651            if (HAL_KEY_SW_7_PXIFG & HAL_KEY_SW_7_BIT)
   \                     ??CrossCallReturnLabel_2:
   \   000010   E589         MOV     A,0x89
   \   000012   A2E4         MOV     C,0xE0 /* A   */.4
   \   000014   5003         JNC     ??CrossCallReturnLabel_3
    652            {
    653              halProcessKeyInterrupt();
   \   000016                ; Setup parameters for call to function halProcessKeyInterrupt
   \   000016   12....       LCALL   ?Subroutine4
    654              HAL_KEY_SW_7_PXIFG = 0;
    655            }
    656            
    657             if (HAL_KEY_SW_5_PXIFG & HAL_KEY_SW_5_BIT)
   \                     ??CrossCallReturnLabel_3:
   \   000019   E589         MOV     A,0x89
   \   00001B   A2E6         MOV     C,0xE0 /* A   */.6
   \   00001D   5003         JNC     ??CrossCallReturnLabel_4
    658            {
    659              halProcessKeyInterrupt();
   \   00001F                ; Setup parameters for call to function halProcessKeyInterrupt
   \   00001F   12....       LCALL   ?Subroutine4
    660              HAL_KEY_SW_5_PXIFG = 0;
    661            }
    662            
    663             if (HAL_KEY_SW_4_PXIFG & HAL_KEY_SW_4_BIT)
   \                     ??CrossCallReturnLabel_4:
   \   000022   E589         MOV     A,0x89
   \   000024   A2E6         MOV     C,0xE0 /* A   */.6
   \   000026   5003         JNC     ??CrossCallReturnLabel_5
    664            {
    665              halProcessKeyInterrupt();
   \   000028                ; Setup parameters for call to function halProcessKeyInterrupt
   \   000028   12....       LCALL   ?Subroutine4
    666              HAL_KEY_SW_4_PXIFG = 0;
    667            }
    668          
    669          
    670            /*
    671              Clear the CPU interrupt flag for Port_0
    672              PxIFG has to be cleared before PxIF
    673            */
    674            
    675            HAL_KEY_CPU_PORT_0_IF = 0;
   \                     ??CrossCallReturnLabel_5:
   \   00002B   C2C5         CLR     0xc0.5
    676            
    677            CLEAR_SLEEP_MODE();
    678          }
   \   00002D                REQUIRE ?Subroutine2
   \   00002D                REQUIRE P0IFG
   \   00002D                REQUIRE _A_IRCON
   \   00002D                ; // Fall through to label ?Subroutine2

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?INTERRUPT_LEAVE_XSP

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL   ??halProcessKeyInterrupt?relay
   \   000003   758900       MOV     0x89,#0x0
   \   000006   22           RET
    679          
    680          
    681          /**************************************************************************************************
    682           * @fn      halKeyPort2Isr
    683           *
    684           * @brief   Port2 ISR
    685           *
    686           * @param
    687           *
    688           * @return
    689           **************************************************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    690          HAL_ISR_FUNCTION( halKeyPort2Isr, P2INT_VECTOR )
   \                     halKeyPort2Isr:
    691          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    692            if (HAL_KEY_JOY_MOVE_PXIFG & HAL_KEY_JOY_MOVE_BIT)
   \   000007   E58B         MOV     A,0x8b
   \   000009   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000B   5003         JNC     ??halKeyPort2Isr_0
    693            {
    694              halProcessKeyInterrupt();
   \   00000D                ; Setup parameters for call to function halProcessKeyInterrupt
   \   00000D   12....       LCALL   ??halProcessKeyInterrupt?relay
    695            }
    696          
    697            /*
    698              Clear the CPU interrupt flag for Port_2
    699              PxIFG has to be cleared before PxIF
    700              Notes: P2_1 and P2_2 are debug lines.
    701            */
    702            HAL_KEY_JOY_MOVE_PXIFG = 0;
   \                     ??halKeyPort2Isr_0:
   \   000010   758B00       MOV     0x8b,#0x0
    703            HAL_KEY_CPU_PORT_2_IF = 0;
   \   000013   C2E8         CLR     0xe8.0
    704          }
   \   000015   80..         SJMP    ?Subroutine2
   \   000017                REQUIRE P2IFG
   \   000017                REQUIRE _A_IRCON2

   \                                 In  segment INTVEC, offset 0x33, root
   \                     `??halKeyPort2Isr??INTVEC 51`:
   \   000033   02....       LJMP       (halKeyPort2Isr)

   \                                 In  segment INTVEC, offset 0x6b, root
   \                     `??halKeyPort0Isr??INTVEC 107`:
   \   00006B   02....       LJMP       (halKeyPort0Isr)

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyPoll?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyPoll

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halGetJoyKeyInput?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halGetJoyKeyInput

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halProcessKeyInterrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halProcessKeyInterrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyEnterSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyEnterSleep

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyExitSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyExitSleep
    705          
    706          #else
    707          
    708          
    709          void HalKeyInit(void){}
    710          void HalKeyConfig(bool interruptEnable, halKeyCBack_t cback){}
    711          uint8 HalKeyRead(void){ return 0;}
    712          void HalKeyPoll(void){}
    713          
    714          #endif /* HAL_KEY */
    715          
    716          
    717          
    718          
    719          
    720          /**************************************************************************************************
    721          **************************************************************************************************/
    722          
    723          
    724          

   Maximum stack usage in bytes:

     Function                    ISTACK PSTACK XSTACK
     --------                    ------ ------ ------
     HalKeyConfig                    0      0      9
       -> osal_stop_timerEx          0      0     18
       -> osal_start_timerEx         0      0     18
     HalKeyEnterSleep                0      0      0
     HalKeyExitSleep                 2      0      0
       -> HalKeyRead                 4      0      0
     HalKeyInit                      2      0      0
     HalKeyPoll                      0      0      9
       -> halGetJoyKeyInput          0      0     18
     HalKeyRead                      0      0      9
       -> halGetJoyKeyInput          0      0     18
     halGetJoyKeyInput               0      0     18
       -> HalAdcRead                 0      0     18
     halKeyPort0Isr                 15      0      0
       -> halProcessKeyInterrupt    30      0      0
       -> halProcessKeyInterrupt    30      0      0
       -> halProcessKeyInterrupt    30      0      0
       -> halProcessKeyInterrupt    30      0      0
     halKeyPort2Isr                 15      0      0
       -> halProcessKeyInterrupt    30      0      0
     halProcessKeyInterrupt          2      0      0
       -> osal_start_timerEx         4      0      0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     _A_P0                             1
     P0IFG                             1
     P2IFG                             1
     PICTL                             1
     _A_P2                             1
     P0IEN                             1
     _A_IEN1                           1
     _A_IRCON                          1
     _A_IRCON2                         1
     P0SEL                             1
     P0DIR                             1
     halKeySavedKeys                   1
     pHalKeyProcessFunction            2
     HalKeyConfigured                  1
     Hal_KeyIntEnable                  1
     HalKeyInit                       43
     ?Subroutine0                      7
     HalKeyConfig                    138
     ?Subroutine3                      9
     HalKeyRead                       26
     ?Subroutine1                      1
     ??Subroutine5_0                   5
     HalKeyPoll                      122
     halGetJoyKeyInput                73
     halProcessKeyInterrupt           82
     HalKeyEnterSleep                  3
     HalKeyExitSleep                  10
     halKeyPort0Isr                   45
     ?Subroutine2                      5
     ?Subroutine4                      7
     halKeyPort2Isr                   23
     ??halKeyPort2Isr??INTVEC 51       3
     ??halKeyPort0Isr??INTVEC 107      3
     ??HalKeyInit?relay                6
     ??HalKeyConfig?relay              6
     ??HalKeyRead?relay                6
     ??HalKeyPoll?relay                6
     ??halGetJoyKeyInput?relay         6
     ??halProcessKeyInterrupt?relay    6
     ??HalKeyEnterSleep?relay          6
     ??HalKeyExitSleep?relay           6

 
 519 bytes in segment BANKED_CODE
  48 bytes in segment BANK_RELAYS
   6 bytes in segment INTVEC
  80 bytes in segment NEAR_CODE
  11 bytes in segment SFR_AN
   5 bytes in segment XDATA_Z
 
 647 bytes of CODE  memory (+  6 bytes shared)
   0 bytes of DATA  memory (+ 11 bytes shared)
   5 bytes of XDATA memory

Errors: none
Warnings: none
