###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                07/Jun/2011  16:44:40 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Tex #
#                          as Instruments\ZStack-CC2530-2.2.0-1.3.0\Component #
#                          s\stack\zcl\zcl.c                                  #
#    Command line       =  -f "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò #
#                          \Texas Instruments\ZStack-CC2530-2.2.0-1.3.0\Proje #
#                          cts\zstack\HomeAutomation\SampleSwitch\CC2530DB\.. #
#                          \..\..\Tools\CC2530DB\f8wRouter.cfg" (-DCPU32MHZ   #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DRTR_NWK -DBLINK_LEDS) -f                       #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\..\.. #
#                          \..\Tools\CC2530DB\f8wConfig.cfg" (-DSECURE=0      #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x04000000                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440)   #
#                          -f "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò #
#                          \Texas Instruments\ZStack-CC2530-2.2.0-1.3.0\Proje #
#                          cts\zstack\HomeAutomation\SampleSwitch\CC2530DB\.. #
#                          \..\..\Tools\CC2530DB\f8wZCL.cfg" (-DZCL_READ      #
#                          -DZCL_WRITE -DZCL_BASIC -DZCL_IDENTIFY             #
#                          -DZCL_ON_OFF -DZCL_KEY_ESTABLISH                   #
#                          -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING           #
#                          -DZCL_PRICING) -DZCL_MESSAGE                       #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Componen #
#                          ts\stack\zcl\zcl.c" -D ZIGBEEPRO -D ZTOOL_P1 -D    #
#                          MT_TASK -D MT_APP_FUNC -D MT_SYS_FUNC -D           #
#                          MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG -lC             #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\Route #
#                          rEB-Pro\List\" -lA "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí #
#                          )\ZigBee2007³ÌÐò\Texas Instruments\ZStack-CC2530-2 #
#                          .2.0-1.3.0\Projects\zstack\HomeAutomation\SampleSw #
#                          itch\CC2530DB\RouterEB-Pro\List\" --diag_suppress  #
#                          Pe001,Pa010 -o "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\Zi #
#                          gBee2007³ÌÐò\Texas Instruments\ZStack-CC2530-2.2.0 #
#                          -1.3.0\Projects\zstack\HomeAutomation\SampleSwitch #
#                          \CC2530DB\RouterEB-Pro\Obj\" -e                    #
#                          --require_prototypes --debug --core=plain          #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 8 -I "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ý #
#                          ÕûÀí)\ZigBee2007³ÌÐò\Texas                         #
#                          Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\HomeAutomation\SampleSwitch\CC2530DB\" -I      #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\..\SO #
#                          URCE\" -I "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2 #
#                          007³ÌÐò\Texas Instruments\ZStack-CC2530-2.2.0-1.3. #
#                          0\Projects\zstack\HomeAutomation\SampleSwitch\CC25 #
#                          30DB\..\..\SOURCE\" -I "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ý #
#                          ÕûÀí)\ZigBee2007³ÌÐò\Texas                         #
#                          Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects\zst #
#                          ack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\ #
#                          ZMAIN\TI2530DB\" -I "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀ #
#                          í)\ZigBee2007³ÌÐò\Texas Instruments\ZStack-CC2530- #
#                          2.2.0-1.3.0\Projects\zstack\HomeAutomation\SampleS #
#                          witch\CC2530DB\..\..\..\..\..\COMPONENTS\MT\" -I   #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\HAL\INCLUDE\" -I              #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\HAL\TARGET\CC2530EB\" -I      #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\OSAL\MCU\CCSOC\" -I           #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\OSAL\INCLUDE\" -I             #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\AF\" -I                 #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\NWK\" -I                #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\SEC\" -I                #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\SAPI\" -I               #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\SYS\" -I                #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\ZCL\" -I                #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\STACK\ZDO\" -I                #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\ZMAC\F8W\" -I                 #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\ZMAC\" -I                     #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\SERVICES\SADDR\" -I           #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\SERVICES\SDATA\" -I           #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\INCLUDE\" -I              #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\HIGH_LEVEL\" -I           #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\" -I      #
#                          "F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Te #
#                          xas Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects #
#                          \zstack\HomeAutomation\SampleSwitch\CC2530DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CH #
#                          IP\" -I "C:\Program Files\IAR Systems\Embedded     #
#                          Workbench 5.3 Evaluation version\8051\INC\" -I     #
#                          "C:\Program Files\IAR Systems\Embedded Workbench   #
#                          5.3 Evaluation version\8051\INC\CLIB\" -Ohz        #
#    List file          =  F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Tex #
#                          as Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects\ #
#                          zstack\HomeAutomation\SampleSwitch\CC2530DB\Router #
#                          EB-Pro\List\zcl.lst                                #
#    Object file        =  F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Tex #
#                          as Instruments\ZStack-CC2530-2.2.0-1.3.0\Projects\ #
#                          zstack\HomeAutomation\SampleSwitch\CC2530DB\Router #
#                          EB-Pro\Obj\zcl.r51                                 #
#                                                                             #
#                                                                             #
###############################################################################

F:\Ëæ±Ê\²úÆ·»¯\CC2530PK(´ýÕûÀí)\ZigBee2007³ÌÐò\Texas Instruments\ZStack-CC2530-2.2.0-1.3.0\Components\stack\zcl\zcl.c
      1          /**************************************************************************************************
      2            Filename:       zcl.c
      3            Revised:        $Date: 2009-04-06 09:08:36 -0700 (Mon, 06 Apr 2009) $
      4            Revision:       $Revision: 19702 $
      5          
      6            Description:    This file contains the Zigbee Cluster Library Foundation functions.
      7          
      8          
      9            Copyright 2006-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          #include "OSAL.h"
     45          #include "OSAL_Tasks.h"
     46          #include "AF.h"
     47          #include "ZDConfig.h"
     48          
     49          #include "zcl.h"
     50          #include "zcl_general.h"
     51          
     52          #if defined ( INTER_PAN )
     53            #include "stub_aps.h"
     54          #endif
     55          
     56          /*********************************************************************
     57           * MACROS
     58           */
     59          /*** Frame Control ***/
     60          #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
     61          #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
     62          #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
     63          #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
     64          
     65          /*** Attribute Access Control ***/
     66          #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
     67          #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
     68          #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
     69          
     70          #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
     71          #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
     72          
     73          #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \
     74                                                  (zclHdr).fc.manuSpecific == 0          && \
     75                                                  (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
     76          
     77          // Commands that have corresponding responses
     78          #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ            || \
     79                                                  (cmd) == ZCL_CMD_WRITE           || \
     80                                                  (cmd) == ZCL_CMD_WRITE_UNDIVIDED || \
     81                                                  (cmd) == ZCL_CMD_CONFIG_REPORT   || \
     82                                                  (cmd) == ZCL_CMD_READ_REPORT_CFG || \
     83                                                  (cmd) == ZCL_CMD_DISCOVER        || \
     84                                                  (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
     85          
     86          /*********************************************************************
     87           * CONSTANTS
     88           */
     89          
     90          /*********************************************************************
     91           * TYPEDEFS
     92           */
     93          typedef struct zclLibPlugin
     94          {
     95            struct zclLibPlugin *next;
     96            uint16              startClusterID;    // starting cluster ID
     97            uint16              endClusterID;      // ending cluster ID
     98            zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
     99          } zclLibPlugin_t;
    100          
    101          // Attribute record list item
    102          typedef struct zclAttrRecsList
    103          {
    104            struct zclAttrRecsList *next;
    105            uint8                  endpoint;      // Used to link it into the endpoint descriptor
    106            uint8                  numAttributes; // Number of the following records
    107            CONST zclAttrRec_t     *attrs;        // attribute records
    108          } zclAttrRecsList;
    109          
    110          // Cluster option list item
    111          typedef struct zclClusterOptionList
    112          {
    113            struct zclClusterOptionList *next;
    114            uint8                       endpoint;   // Used to link it into the endpoint descriptor
    115            uint8                       numOptions; // Number of the following records
    116            zclOptionRec_t              *options;   // option records
    117          } zclClusterOptionList;
    118          
    119          typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
    120          typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
    121          
    122          typedef struct
    123          {
    124            zclParseInProfileCmd_t   pfnParseInProfile;
    125            zclProcessInProfileCmd_t pfnProcessInProfile;
    126          } zclCmdItems_t;
    127          
    128          
    129          /*********************************************************************
    130           * GLOBAL VARIABLES
    131           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    132          uint8 zcl_TaskID;
   \                     zcl_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    133          
    134          // The task Id of the Application where the unprocessed Foundation
    135          // Command/Response messages will be sent to.

   \                                 In  segment XDATA_I, align 1, keep-with-next
    136          uint8 zcl_RegisteredMsgTaskID = TASK_NO_TASK;
   \                     zcl_RegisteredMsgTaskID:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for zcl_RegisteredMsgTaskID>`
   \   000001                REQUIRE __INIT_XDATA_I
    137          
    138          // The Application should register its attribute data validation function

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    139          zclValidateAttrData_t zcl_ValidateAttrDataCB = NULL;
   \                     zcl_ValidateAttrDataCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    140          
    141          // ZCL Sequence number

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    142          uint8 zcl_SeqNum = 0x00;
   \                     zcl_SeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    143             
    144          /*********************************************************************
    145           * EXTERNAL VARIABLES
    146           */
    147          
    148          /*********************************************************************
    149           * EXTERNAL FUNCTIONS
    150           */
    151          
    152          /*********************************************************************
    153           * LOCAL VARIABLES
    154           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    155          static zclLibPlugin_t *plugins;
   \                     plugins:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    156          static zclAttrRecsList *attrList;
   \                     attrList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    157          static zclClusterOptionList *clusterOptionList;
   \                     clusterOptionList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    158          static uint8 zcl_TransID = 0;  // This is the unique message ID (counter)
   \                     zcl_TransID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    159          
    160          /*********************************************************************
    161           * LOCAL FUNCTIONS
    162           */
    163          static void zclProcessMessageMSG( afIncomingMSGPacket_t *pkt );
    164          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
    165          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
    166          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
    167          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
    168          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
    169          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
    170          
    171          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
    172          
    173          #if defined(ZCL_READ) || defined(ZCL_WRITE) || defined(ZCL_REPORT)
    174          static void zclSerializeData( uint8 dataType, void *attrData, uint8 *buf );
    175          #endif // ZCL_READ || ZCL_WRITE || ZCL_REPORT
    176          
    177          #ifdef ZCL_READ
    178          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
    179          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
    180          #endif // ZCL_READ
    181          
    182          #ifdef ZCL_WRITE
    183          static uint8 zclWriteAttrData( zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec );
    184          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
    185          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
    186          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
    187          #endif // ZCL_WRITE
    188          
    189          #ifdef ZCL_REPORT
    190          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
    191          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
    192          #endif // ZCL_REPORT
    193          
    194          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
    195          
    196          #ifdef ZCL_DISCOVER
    197          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint16 *attrId, zclAttrRec_t *pAttr );
    198          static void *zclParseInDiscRspCmd( zclParseCmd_t *pCmd );
    199          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
    200          #endif // ZCL_DISCOVER
    201          
    202          static uint8 zclSendMsg( zclIncoming_t *pInMsg );
    203          
    204          /*********************************************************************
    205           * Parse Profile Command Function Table
    206           */

   \                                 In  segment CODE_C, align 1
    207          static CONST zclCmdItems_t zclCmdTable[] =
   \                     zclCmdTable:
   \   000000   ........     DW ??zclParseInReadCmd?relay, ??zclProcessInReadCmd?relay
   \   000004   ........     DW ??zclParseInReadRspCmd?relay, ??zclSendMsg?relay
   \   000008   ........     DW ??zclParseInWriteCmd?relay, ??zclProcessInWriteCmd?relay
   \   00000C   ........     DW ??zclParseInWriteCmd?relay, ??zclProcessInWriteUndividedCmd?relay
   \   000010   ........     DW ??zclParseInWriteRspCmd?relay, ??zclSendMsg?relay
   \   000014   ........     DW ??zclParseInWriteCmd?relay, ??zclProcessInWriteCmd?relay, 0H, 0H, 0H
   \            00000000
   \            0000    
   \   00001E   00000000     DW 0H, 0H, 0H, 0H, 0H, 0H, 0H, ??zclParseInDefaultRspCmd?relay
   \            00000000
   \            00000000
   \            0000....
   \   00002E   ....0000     DW ??zclSendMsg?relay, 0H, 0H, 0H, 0H
   \            00000000
   \            0000    
    208          {
    209          #ifdef ZCL_READ
    210            /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
    211            /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zclSendMsg                      },
    212          #else
    213            /* ZCL_CMD_READ */                { NULL,                          NULL                            },
    214            /* ZCL_CMD_READ_RSP */            { NULL,                          NULL                            },
    215          #endif // ZCL_READ
    216          
    217          #ifdef ZCL_WRITE
    218            /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    219            /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
    220            /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zclSendMsg                      },
    221            /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    222          #else
    223            /* ZCL_CMD_WRITE */               { NULL,                          NULL                            },
    224            /* ZCL_CMD_WRITE_UNDIVIDED */     { NULL,                          NULL                            },
    225            /* ZCL_CMD_WRITE_RSP */           { NULL,                          NULL                            },
    226            /* ZCL_CMD_WRITE_NO_RSP */        { NULL,                          NULL                            },
    227          #endif // ZCL_WRITE
    228          
    229          #ifdef ZCL_REPORT
    230            /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zclSendMsg                      },
    231            /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zclSendMsg                      },
    232            /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zclSendMsg                      },
    233            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zclSendMsg                      },
    234            /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zclSendMsg                      },
    235          #else
    236            /* ZCL_CMD_CONFIG_REPORT */       { NULL,                          NULL                            },
    237            /* ZCL_CMD_CONFIG_REPORT_RSP */   { NULL,                          NULL                            },
    238            /* ZCL_CMD_READ_REPORT_CFG */     { NULL,                          NULL                            },
    239            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { NULL,                          NULL                            },
    240            /* ZCL_CMD_REPORT */              { NULL,                          NULL                            },
    241          #endif // ZCL_REPORT
    242          
    243            /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zclSendMsg                      },
    244            
    245          #ifdef ZCL_DISCOVER  
    246            /* ZCL_CMD_DISCOVER */            { zclParseInDiscCmd,             zclProcessInDiscCmd             },
    247            /* ZCL_CMD_DISCOVER_RSP */        { zclParseInDiscRspCmd,          zclSendMsg                      }
    248          #else
    249            /* ZCL_CMD_DISCOVER */            { NULL,                          NULL                            },
    250            /* ZCL_CMD_DISCOVER_RSP */        { NULL,                          NULL                            }
    251          #endif // ZCL_DISCOVER
    252          };
    253          
    254          /*********************************************************************
    255           * PUBLIC FUNCTIONS
    256           *********************************************************************/
    257          
    258          /*********************************************************************
    259           * @fn          zcl_Init
    260           *
    261           * @brief       Initialization function for the zcl layer.
    262           *
    263           * @param       task_id - ZCL task id
    264           *
    265           * @return      none
    266           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    267          void zcl_Init( uint8 task_id )
   \                     zcl_Init:
    268          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    269            zcl_TaskID = task_id;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#zcl_TaskID
   \   000008   F0           MOVX    @DPTR,A
    270          
    271            plugins = (zclLibPlugin_t  *)NULL;
   \   000009   90....       MOV     DPTR,#plugins
   \   00000C   E4           CLR     A
   \   00000D   F0           MOVX    @DPTR,A
   \   00000E   A3           INC     DPTR
   \   00000F   F0           MOVX    @DPTR,A
    272            attrList = (zclAttrRecsList *)NULL;
   \   000010   90....       MOV     DPTR,#attrList
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   F0           MOVX    @DPTR,A
    273            clusterOptionList = (zclClusterOptionList *)NULL;
   \   000016   90....       MOV     DPTR,#clusterOptionList
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   F0           MOVX    @DPTR,A
    274          }
   \   00001C   02....       LJMP    ?Subroutine131 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine131:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    275          
    276          /*********************************************************************
    277           * @fn          zcl_event_loop
    278           *
    279           * @brief       Event Loop Processor for zcl.
    280           *
    281           * @param       task_id - task id
    282           * @param       events - event bitmap
    283           *
    284           * @return      unprocessed events
    285           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    286          uint16 zcl_event_loop( uint8 task_id, uint16 events )
   \                     zcl_event_loop:
    287          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
    288            uint8 *msgPtr;
    289          
    290            (void)task_id;  // Intentionally unreferenced parameter
    291            
    292            if ( events & SYS_EVENT_MSG )
   \   000009   7480         MOV     A,#-0x80
   \   00000B   55..         ANL     A,?V0 + 1
   \   00000D   F9           MOV     R1,A
   \   00000E   E4           CLR     A
   \   00000F   7001         JNZ     ??zcl_event_loop_0
   \   000011   E9           MOV     A,R1
   \                     ??zcl_event_loop_0:
   \   000012   604B         JZ      ??zcl_event_loop_1
    293            {
    294              msgPtr = osal_msg_receive( zcl_TaskID );
   \   000014                ; Setup parameters for call to function osal_msg_receive
   \   000014   800E         SJMP    ??zcl_event_loop_2
    295              while ( msgPtr != NULL )
    296              {
    297                uint8 dealloc = TRUE;
    298                
    299                if ( *msgPtr == AF_INCOMING_MSG_CMD )
    300                {
    301                  zclProcessMessageMSG( (afIncomingMSGPacket_t *)msgPtr );
   \                     ??zcl_event_loop_3:
   \   000016                ; Setup parameters for call to function zclProcessMessageMSG
   \   000016   EE           MOV     A,R6
   \   000017   FA           MOV     R2,A
   \   000018   EF           MOV     A,R7
   \   000019   FB           MOV     R3,A
   \   00001A   12....       LCALL   ??zclProcessMessageMSG?relay
    302                }
    303                else if ( zcl_RegisteredMsgTaskID != TASK_NO_TASK )
    304                {
    305                  // send it to another task to process.
    306                  osal_msg_send( zcl_RegisteredMsgTaskID, msgPtr );
    307                  dealloc = FALSE;
    308                }
    309            
    310                // Release the memory
    311                if ( dealloc )
    312                {
    313                  osal_msg_deallocate( msgPtr );
   \                     ??zcl_event_loop_4:
   \   00001D                ; Setup parameters for call to function osal_msg_deallocate
   \   00001D   EE           MOV     A,R6
   \   00001E   FA           MOV     R2,A
   \   00001F   EF           MOV     A,R7
   \   000020   FB           MOV     R3,A
   \   000021   12....       LCALL   ??osal_msg_deallocate?relay
    314                }
    315          
    316                // Next
    317                msgPtr = osal_msg_receive( zcl_TaskID );
   \                     ??zcl_event_loop_2:
   \   000024                ; Setup parameters for call to function osal_msg_receive
   \   000024   90....       MOV     DPTR,#zcl_TaskID
   \   000027   E0           MOVX    A,@DPTR
   \   000028   F9           MOV     R1,A
   \   000029   12....       LCALL   ??osal_msg_receive?relay
   \   00002C   8A..         MOV     ?V0 + 2,R2
   \   00002E   8B..         MOV     ?V0 + 3,R3
   \   000030   AE..         MOV     R6,?V0 + 2
   \   000032   AF..         MOV     R7,?V0 + 3
   \   000034   EE           MOV     A,R6
   \   000035   7001         JNZ     ??zcl_event_loop_5
   \   000037   EF           MOV     A,R7
   \                     ??zcl_event_loop_5:
   \   000038   601C         JZ      ??zcl_event_loop_6
   \   00003A   8E82         MOV     DPL,R6
   \   00003C   8F83         MOV     DPH,R7
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   641A         XRL     A,#0x1a
   \   000041   60D3         JZ      ??zcl_event_loop_3
   \   000043   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   000046   E0           MOVX    A,@DPTR
   \   000047   64FF         XRL     A,#0xff
   \   000049   60D2         JZ      ??zcl_event_loop_4
   \   00004B                ; Setup parameters for call to function osal_msg_send
   \   00004B   EE           MOV     A,R6
   \   00004C   FA           MOV     R2,A
   \   00004D   EF           MOV     A,R7
   \   00004E   FB           MOV     R3,A
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   F9           MOV     R1,A
   \   000051   12....       LCALL   ??osal_msg_send?relay
   \   000054   80CE         SJMP    ??zcl_event_loop_2
    318              }
    319          
    320              // return unprocessed events
    321              return (events ^ SYS_EVENT_MSG);
   \                     ??zcl_event_loop_6:
   \   000056   AA..         MOV     R2,?V0 + 0
   \   000058   7480         MOV     A,#-0x80
   \   00005A   65..         XRL     A,?V0 + 1
   \   00005C   FB           MOV     R3,A
   \   00005D   8004         SJMP    ??zcl_event_loop_7
    322            }
    323          
    324            // Discard unknown events
    325            return 0;
   \                     ??zcl_event_loop_1:
   \   00005F   7A00         MOV     R2,#0x0
   \   000061   7B00         MOV     R3,#0x0
   \                     ??zcl_event_loop_7:
   \   000063   02....       LJMP    ?Subroutine132 & 0xFFFF
    326          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine132:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    327          
    328          /*********************************************************************
    329           * @fn          zcl_registerPlugin
    330           *
    331           * @brief       Add a Cluster Library handler
    332           *
    333           * @param       startClusterID - starting cluster ID
    334           * @param       endClusterID - ending cluster ID
    335           * @param       pfnHdlr - function pointer to incoming message handler
    336           *
    337           * @return      ZSuccess if OK
    338           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    339          ZStatus_t zcl_registerPlugin( uint16 startClusterID,
   \                     zcl_registerPlugin:
    340                    uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr )
    341          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   \   00000D   740E         MOV     A,#0xe
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F5..         MOV     ?V0 + 2,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F5..         MOV     ?V0 + 3,A
    342            zclLibPlugin_t *pNewItem;
    343            zclLibPlugin_t *pLoop;
    344          
    345            // Fill in the new profile list
    346            pNewItem = osal_mem_alloc( sizeof( zclLibPlugin_t ) );
   \   000019                ; Setup parameters for call to function osal_mem_alloc
   \   000019   7A08         MOV     R2,#0x8
   \   00001B   7B00         MOV     R3,#0x0
   \   00001D   12....       LCALL   ??osal_mem_alloc?relay
   \   000020   8A..         MOV     ?V0 + 4,R2
   \   000022   8B..         MOV     ?V0 + 5,R3
   \   000024   A8..         MOV     R0,?V0 + 4
   \   000026   A9..         MOV     R1,?V0 + 5
    347            if ( pNewItem == NULL )
   \   000028   E8           MOV     A,R0
   \   000029   7001         JNZ     ??zcl_registerPlugin_0
   \   00002B   E9           MOV     A,R1
   \                     ??zcl_registerPlugin_0:
   \   00002C   7004         JNZ     ??zcl_registerPlugin_1
    348              return (ZMemError);
   \   00002E   7910         MOV     R1,#0x10
   \   000030   803E         SJMP    ??CrossCallReturnLabel_22
    349          
    350            // Fill in the plugin record.
    351            pNewItem->next = (zclLibPlugin_t *)NULL;
   \                     ??zcl_registerPlugin_1:
   \   000032   12....       LCALL   ?Subroutine93 & 0xFFFF
    352            pNewItem->startClusterID = startClusterID;
   \                     ??CrossCallReturnLabel_152:
   \   000035   A3           INC     DPTR
   \   000036   E5..         MOV     A,?V0 + 1
   \   000038   12....       LCALL   ?Subroutine21 & 0xFFFF
    353            pNewItem->endClusterID = endClusterID;
   \                     ??CrossCallReturnLabel_39:
   \   00003B   EE           MOV     A,R6
   \   00003C   F0           MOVX    @DPTR,A
   \   00003D   A3           INC     DPTR
   \   00003E   EF           MOV     A,R7
   \   00003F   12....       LCALL   ?Subroutine21 & 0xFFFF
    354            pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
   \                     ??CrossCallReturnLabel_40:
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   E5..         MOV     A,?V0 + 2
   \   000046   F0           MOVX    @DPTR,A
   \   000047   A3           INC     DPTR
   \   000048   E5..         MOV     A,?V0 + 3
   \   00004A   F0           MOVX    @DPTR,A
    355          
    356            // Find spot in list
    357            if (  plugins == NULL )
   \   00004B   90....       MOV     DPTR,#plugins
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   7002         JNZ     ??zcl_registerPlugin_2
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \                     ??zcl_registerPlugin_2:
   \   000053   90....       MOV     DPTR,#plugins
   \   000056   6015         JZ      ??zcl_registerPlugin_3
    358            {
    359              plugins = pNewItem;
    360            }
    361            else
    362            {
    363              // Look for end of list
    364              pLoop = plugins;
   \   000058   E0           MOVX    A,@DPTR
   \   000059   FC           MOV     R4,A
   \   00005A   A3           INC     DPTR
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   8003         SJMP    ??zcl_registerPlugin_4
    365              while ( pLoop->next != NULL )
    366                pLoop = pLoop->next;
   \                     ??zcl_registerPlugin_5:
   \   00005E   EA           MOV     A,R2
   \   00005F   FC           MOV     R4,A
   \   000060   EB           MOV     A,R3
   \                     ??zcl_registerPlugin_4:
   \   000061   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   000064   7001         JNZ     ??zcl_registerPlugin_6
   \   000066   EB           MOV     A,R3
   \                     ??zcl_registerPlugin_6:
   \   000067   70F5         JNZ     ??zcl_registerPlugin_5
    367          
    368              // Put new item at end of list
    369              pLoop->next = pNewItem;
   \   000069   8C82         MOV     DPL,R4
   \   00006B   8D83         MOV     DPH,R5
    370            }
   \                     ??zcl_registerPlugin_3:
   \   00006D   12....       LCALL   ?Subroutine14 & 0xFFFF
    371          
    372            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_22:
   \   000070   7F06         MOV     R7,#0x6
   \   000072   02....       LJMP    ?BANKED_LEAVE_XDATA
    373          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_382:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine97:
   \   000000   12....       LCALL   ?Subroutine122 & 0xFFFF
   \                     ??CrossCallReturnLabel_249:
   \   000003                REQUIRE ?Subroutine138
   \   000003                ; // Fall through to label ?Subroutine138

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine138:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   FD           MOV     R5,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_287:
   \   000008   EA           MOV     A,R2
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   7900         MOV     R1,#0x0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine93:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   E4           CLR     A
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ?Subroutine122 & 0xFFFF
   \                     ??CrossCallReturnLabel_250:
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E5..         MOV     A,?V0 + 0
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine122:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   80..         SJMP    ??Subroutine157_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine157_0:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine100:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
    374          
    375          /*********************************************************************
    376           * @fn          zcl_registerAttrList
    377           *
    378           * @brief       Register an Attribute List with ZCL Foundation
    379           *
    380           * @param       endpoint - endpoint the attribute list belongs to
    381           * @param       numAttr - number of attributes in list
    382           * @param       newAttrList - array of Attribute records.
    383           *                            NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE IN
    384           *                            ASCENDING ORDER. OTHERWISE, THE DISCOVERY RESPONSE
    385           *                            COMMAND WILL NOT HAVE THE RIGHT ATTRIBUTE INFO
    386           *
    387           * @return      ZSuccess if OK
    388           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    389          ZStatus_t zcl_registerAttrList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t newAttrList[] )
   \                     zcl_registerAttrList:
    390          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine81 & 0xFFFF
    391            zclAttrRecsList *pNewItem;
    392            zclAttrRecsList *pLoop;
    393          
    394            // Fill in the new profile list
    395            pNewItem = osal_mem_alloc( sizeof( zclAttrRecsList ) );
    396            if ( pNewItem == NULL )
   \                     ??CrossCallReturnLabel_136:
   \   000008   7001         JNZ     ??zcl_registerAttrList_0
   \   00000A   E9           MOV     A,R1
   \                     ??zcl_registerAttrList_0:
   \   00000B   7004         JNZ     ??zcl_registerAttrList_1
    397              return (ZMemError);
   \   00000D   7910         MOV     R1,#0x10
   \   00000F   8028         SJMP    ??CrossCallReturnLabel_23
    398          
    399            pNewItem->next = (zclAttrRecsList *)NULL;
   \                     ??zcl_registerAttrList_1:
   \   000011   12....       LCALL   ?Subroutine2 & 0xFFFF
    400            pNewItem->endpoint = endpoint;
    401            pNewItem->numAttributes = numAttr;
    402            pNewItem->attrs = newAttrList;
    403          
    404            // Find spot in list
    405            if ( attrList == NULL )
   \                     ??CrossCallReturnLabel_2:
   \   000014   90....       MOV     DPTR,#attrList
   \   000017   E0           MOVX    A,@DPTR
   \   000018   7002         JNZ     ??zcl_registerAttrList_2
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \                     ??zcl_registerAttrList_2:
   \   00001C   90....       MOV     DPTR,#attrList
   \   00001F   6015         JZ      ??zcl_registerAttrList_3
    406            {
    407              attrList = pNewItem;
    408            }
    409            else
    410            {
    411              // Look for end of list
    412              pLoop = attrList;
   \   000021   E0           MOVX    A,@DPTR
   \   000022   FC           MOV     R4,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   8003         SJMP    ??zcl_registerAttrList_4
    413              while ( pLoop->next != NULL )
    414                pLoop = pLoop->next;
   \                     ??zcl_registerAttrList_5:
   \   000027   EA           MOV     A,R2
   \   000028   FC           MOV     R4,A
   \   000029   EB           MOV     A,R3
   \                     ??zcl_registerAttrList_4:
   \   00002A   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   00002D   7001         JNZ     ??zcl_registerAttrList_6
   \   00002F   EB           MOV     A,R3
   \                     ??zcl_registerAttrList_6:
   \   000030   70F5         JNZ     ??zcl_registerAttrList_5
    415          
    416              // Put new item at end of list
    417              pLoop->next = pNewItem;
   \   000032   8C82         MOV     DPL,R4
   \   000034   8D83         MOV     DPH,R5
    418            }
   \                     ??zcl_registerAttrList_3:
   \   000036   12....       LCALL   ?Subroutine14 & 0xFFFF
    419          
    420            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_23:
   \   000039   02....       LJMP    ?Subroutine132 & 0xFFFF
    421          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   89..         MOV     ?V0 + 0,R1
   \   000002   8A..         MOV     ?V0 + 1,R2
   \   000004   EC           MOV     A,R4
   \   000005   FE           MOV     R6,A
   \   000006   ED           MOV     A,R5
   \   000007   FF           MOV     R7,A
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008   7A06         MOV     R2,#0x6
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   12....       LCALL   ??osal_mem_alloc?relay
   \   00000F   8A..         MOV     ?V0 + 2,R2
   \   000011   8B..         MOV     ?V0 + 3,R3
   \   000013   A8..         MOV     R0,?V0 + 2
   \   000015   A9..         MOV     R1,?V0 + 3
   \   000017   E8           MOV     A,R0
   \   000018   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_153:
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   E5..         MOV     A,?V0 + 1
   \   00000C   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_383:
   \   00000F   EE           MOV     A,R6
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EF           MOV     A,R7
   \   000013   F0           MOVX    @DPTR,A
   \   000014   22           RET
    422          
    423          /*********************************************************************
    424           * @fn          zcl_registerClusterOptionList
    425           *
    426           * @brief       Register a Cluster Option List with ZCL Foundation
    427           *
    428           * @param       endpoint - endpoint the option list belongs to
    429           * @param       numOption - number of options in list
    430           * @param       optionList - array of cluster option records.
    431           *                           
    432           *              NOTE: This API should be called to enable 'Application
    433           *                    Link Key' security and/or 'APS ACK' for a specific      
    434           *                    Cluster. The 'Application Link Key' is discarded
    435           *                    if security isn't enabled on the device.
    436           *                    The default behavior is 'Network Key' when security
    437           *                    is enabled and no 'APS ACK' for the ZCL messages.
    438           *
    439           * @return      ZSuccess if OK
    440           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    441          ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
   \                     zcl_registerClusterOptionList:
    442          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine81 & 0xFFFF
    443            zclClusterOptionList *pNewItem;
    444            zclClusterOptionList *pLoop;
    445          
    446            // Fill in the new profile list
    447            pNewItem = osal_mem_alloc( sizeof( zclClusterOptionList ) );
    448            if ( pNewItem == NULL )
   \                     ??CrossCallReturnLabel_137:
   \   000008   7001         JNZ     ??zcl_registerClusterOptionList_0
   \   00000A   E9           MOV     A,R1
   \                     ??zcl_registerClusterOptionList_0:
   \   00000B   7004         JNZ     ??zcl_registerClusterOptionList_1
    449              return (ZMemError);
   \   00000D   7910         MOV     R1,#0x10
   \   00000F   8028         SJMP    ??CrossCallReturnLabel_24
    450          
    451            pNewItem->next = (zclClusterOptionList *)NULL;
   \                     ??zcl_registerClusterOptionList_1:
   \   000011   12....       LCALL   ?Subroutine2 & 0xFFFF
    452            pNewItem->endpoint = endpoint;
    453            pNewItem->numOptions = numOption;
    454            pNewItem->options = optionList;
    455          
    456            // Find spot in list
    457            if ( clusterOptionList == NULL )
   \                     ??CrossCallReturnLabel_3:
   \   000014   90....       MOV     DPTR,#clusterOptionList
   \   000017   E0           MOVX    A,@DPTR
   \   000018   7002         JNZ     ??zcl_registerClusterOptionList_2
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \                     ??zcl_registerClusterOptionList_2:
   \   00001C   90....       MOV     DPTR,#clusterOptionList
   \   00001F   6015         JZ      ??zcl_registerClusterOptionList_3
    458            {
    459              clusterOptionList = pNewItem;
    460            }
    461            else
    462            {
    463              // Look for end of list
    464              pLoop = clusterOptionList;
   \   000021   E0           MOVX    A,@DPTR
   \   000022   FC           MOV     R4,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   8003         SJMP    ??zcl_registerClusterOptionList_4
    465              while ( pLoop->next != NULL )
    466                pLoop = pLoop->next;
   \                     ??zcl_registerClusterOptionList_5:
   \   000027   EA           MOV     A,R2
   \   000028   FC           MOV     R4,A
   \   000029   EB           MOV     A,R3
   \                     ??zcl_registerClusterOptionList_4:
   \   00002A   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_119:
   \   00002D   7001         JNZ     ??zcl_registerClusterOptionList_6
   \   00002F   EB           MOV     A,R3
   \                     ??zcl_registerClusterOptionList_6:
   \   000030   70F5         JNZ     ??zcl_registerClusterOptionList_5
    467          
    468              // Put new item at end of list
    469              pLoop->next = pNewItem;
   \   000032   8C82         MOV     DPL,R4
   \   000034   8D83         MOV     DPH,R5
    470            }
   \                     ??zcl_registerClusterOptionList_3:
   \   000036   12....       LCALL   ?Subroutine14 & 0xFFFF
    471          
    472            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_24:
   \   000039   02....       LJMP    ?Subroutine132 & 0xFFFF
    473          }
    474          
    475          /*********************************************************************
    476           * @fn          zcl_registerValidateAttrData
    477           *
    478           * @brief       Add a validation function for attribute data
    479           *
    480           * @param       pfnValidateAttrData - function pointer to validate routine
    481           *
    482           * @return      ZSuccess if OK
    483           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    484          ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
   \                     zcl_registerValidateAttrData:
    485          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    486            zcl_ValidateAttrDataCB = pfnValidateAttrData;
   \   000004   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   000007   12....       LCALL   ?Subroutine16 & 0xFFFF
    487            
    488            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_28:
   \   00000A   7900         MOV     R1,#0x0
   \   00000C   80..         SJMP    ?Subroutine131
    489          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET
    490          
    491          /*********************************************************************
    492           * @fn      zcl_registerForMsg
    493           *
    494           * @brief   The ZCL is setup to send all incoming Foundation Command/Response
    495           *          messages that aren't processed to one task (if a task is
    496           *          registered).
    497           *
    498           * @param   taskId - task Id of the Application where commands will be sent to
    499           *
    500           * @return  TRUE if task registeration successful, FALSE otherwise
    501           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    502          uint8 zcl_registerForMsg( uint8 taskId )
   \                     zcl_registerForMsg:
    503          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    504            // Allow only the first task
    505            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000004   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   000007   E0           MOVX    A,@DPTR
   \   000008   64FF         XRL     A,#0xff
   \   00000A   7006         JNZ     ??zcl_registerForMsg_0
    506            {
    507              zcl_RegisteredMsgTaskID = taskId;
   \   00000C   E9           MOV     A,R1
   \   00000D   F0           MOVX    @DPTR,A
    508              
    509              return ( true );
   \   00000E   7901         MOV     R1,#0x1
   \   000010   8002         SJMP    ??zcl_registerForMsg_1
    510            }
    511            
    512            return ( false );
   \                     ??zcl_registerForMsg_0:
   \   000012   7900         MOV     R1,#0x0
   \                     ??zcl_registerForMsg_1:
   \   000014                REQUIRE ?Subroutine131
   \   000014                ; // Fall through to label ?Subroutine131
    513          }
    514          
    515          /*********************************************************************
    516           * @fn      zcl_DeviceOperational
    517           *
    518           * @brief   Used to see whether or not the device can send or respond 
    519           *          to application level commands.
    520           *
    521           * @param   srcEP - source endpoint
    522           * @param   clusterID - cluster ID
    523           * @param   frameType - command type
    524           * @param   cmd - command ID
    525           *
    526           * @return  TRUE if device is operational, FALSE otherwise
    527           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    528          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, 
   \                     zcl_DeviceOperational:
    529                                              uint8 frameType, uint8 cmd, uint16 profileID )
    530          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    531            zclAttrRec_t attrRec;
    532            uint8 deviceEnabled = DEVICE_ENABLED; // default value
   \   00000A   7401         MOV     A,#0x1
   \   00000C   85..82       MOV     DPL,?XSP + 0
   \   00000F   85..83       MOV     DPH,?XSP + 1
   \   000012   F0           MOVX    @DPTR,A
    533            
    534            (void)profileID;  // Intentionally unreferenced parameter
    535            
    536            // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it 
    537            // cannot send or respond to application level commands, other than commands
    538            // to read or write attributes. Note that the Identify cluster cannot be 
    539            // disabled, and remains functional regardless of this setting.
    540            if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
   \   000013   EC           MOV     A,R4
   \   000014   700A         JNZ     ??zcl_DeviceOperational_0
   \   000016   ED           MOV     A,R5
   \   000017   C3           CLR     C
   \   000018   9406         SUBB    A,#0x6
   \   00001A   5004         JNC     ??zcl_DeviceOperational_0
    541              return ( TRUE );
   \                     ??zcl_DeviceOperational_1:
   \   00001C   7901         MOV     R1,#0x1
   \   00001E   804E         SJMP    ??zcl_DeviceOperational_2
    542            
    543            if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
   \                     ??zcl_DeviceOperational_0:
   \   000020   7403         MOV     A,#0x3
   \   000022   6A           XRL     A,R2
   \   000023   7001         JNZ     ??zcl_DeviceOperational_3
   \   000025   EB           MOV     A,R3
   \                     ??zcl_DeviceOperational_3:
   \   000026   60F4         JZ      ??zcl_DeviceOperational_1
    544              return ( TRUE );
    545            
    546            // Is device enabled?
    547            if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC, ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
   \   000028                ; Setup parameters for call to function zclFindAttrRec
   \   000028   7401         MOV     A,#0x1
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   8582..       MOV     ?V0 + 0,DPL
   \   000030   8583..       MOV     ?V0 + 1,DPH
   \   000033   78..         MOV     R0,#?V0 + 0
   \   000035   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000038   7C12         MOV     R4,#0x12
   \   00003A   7D00         MOV     R5,#0x0
   \   00003C   7A00         MOV     R2,#0x0
   \   00003E   7B00         MOV     R3,#0x0
   \   000040   12....       LCALL   ??zclFindAttrRec?relay
   \   000043   7402         MOV     A,#0x2
   \   000045   12....       LCALL   ?DEALLOC_XSTACK8
   \   000048   E9           MOV     A,R1
   \   000049   6016         JZ      ??zcl_DeviceOperational_4
    548              zclReadAttrData( &deviceEnabled, &attrRec );
   \   00004B                ; Setup parameters for call to function zclReadAttrData
   \   00004B   7401         MOV     A,#0x1
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   AC82         MOV     R4,DPL
   \   000052   AD83         MOV     R5,DPH
   \   000054   85..82       MOV     DPL,?XSP + 0
   \   000057   85..83       MOV     DPH,?XSP + 1
   \   00005A   AA82         MOV     R2,DPL
   \   00005C   AB83         MOV     R3,DPH
   \   00005E   12....       LCALL   ??zclReadAttrData?relay
    549            
    550            return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
   \                     ??zcl_DeviceOperational_4:
   \   000061   85..82       MOV     DPL,?XSP + 0
   \   000064   85..83       MOV     DPH,?XSP + 1
   \   000067   E0           MOVX    A,@DPTR
   \   000068   6401         XRL     A,#0x1
   \   00006A   60B0         JZ      ??zcl_DeviceOperational_1
   \   00006C   7900         MOV     R1,#0x0
   \                     ??zcl_DeviceOperational_2:
   \   00006E   7409         MOV     A,#0x9
   \   000070   12....       LCALL   ?DEALLOC_XSTACK8
   \   000073   02....       LJMP    ?Subroutine141 & 0xFFFF
    551          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine141:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    552          
    553          /*********************************************************************
    554           * @fn      zcl_SendCommand
    555           *
    556           * @brief   Used to send Profile and Cluster Specific Command messages.
    557           *
    558           *          NOTE: The calling application is responsible for incrementing 
    559           *                the Sequence Number.
    560           *
    561           * @param   srcEp - source endpoint
    562           * @param   destAddr - destination address 
    563           * @param   clusterID - cluster ID
    564           * @param   cmd - command ID
    565           * @param   specific - whether the command is Cluster Specific
    566           * @param   direction - client/server direction of the command
    567           * @param   disableDefaultRsp - disable Default Response command
    568           * @param   manuCode - manufacturer code for proprietary extensions to a profile
    569           * @param   seqNumber - identification number for the transaction
    570           * @param   cmdFormatLen - length of the command to be sent
    571           * @param   cmdFormat - command to be sent
    572           *
    573           * @return  ZSuccess if OK
    574           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    575          ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
   \                     zcl_SendCommand:
    576                                     uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
    577                                     uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
    578                                     uint8 cmdFormatLen, uint8 *cmdFormat )
    579          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 22
   \   000005   74EA         MOV     A,#-0x16
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7406         MOV     A,#0x6
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EC           MOV     A,R4
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   ED           MOV     A,R5
   \   000013   F0           MOVX    @DPTR,A
   \   000014   E9           MOV     A,R1
   \   000015   FE           MOV     R6,A
   \   000016   7426         MOV     A,#0x26
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   FF           MOV     R7,A
   \   00001D   7427         MOV     A,#0x27
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F5..         MOV     ?V0 + 3,A
   \   000025   7428         MOV     A,#0x28
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F5..         MOV     ?V0 + 6,A
   \   00002D   7429         MOV     A,#0x29
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   E0           MOVX    A,@DPTR
   \   000033   F5..         MOV     ?V0 + 5,A
   \   000035   742C         MOV     A,#0x2c
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F5..         MOV     ?V0 + 4,A
    580            endPointDesc_t *epDesc;
    581            zclFrameHdr_t hdr;
    582            uint8 *msgBuf;
    583            uint8 msgLen;
    584            uint8 *pBuf;
    585            afAddrType_t dstAddr;
    586            uint8 options;
    587            ZStatus_t status;
    588          
    589            osal_memcpy( &dstAddr, destAddr, sizeof ( afAddrType_t ) );
   \   00003D                ; Setup parameters for call to function osal_memcpy
   \   00003D   8A..         MOV     ?V0 + 0,R2
   \   00003F   8B..         MOV     ?V0 + 1,R3
   \   000041   75..00       MOV     ?V0 + 2,#0x0
   \   000044   78..         MOV     R0,#?V0 + 0
   \   000046   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000049   7C0C         MOV     R4,#0xc
   \   00004B   7D00         MOV     R5,#0x0
   \   00004D   740D         MOV     A,#0xd
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   AA82         MOV     R2,DPL
   \   000054   AB83         MOV     R3,DPH
   \   000056   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_199:
   \   000059   12....       LCALL   ?DEALLOC_XSTACK8
    590          
    591            epDesc = afFindEndPointDesc( srcEP );
   \   00005C                ; Setup parameters for call to function afFindEndPointDesc
   \   00005C   EE           MOV     A,R6
   \   00005D   F9           MOV     R1,A
   \   00005E   12....       LCALL   ??afFindEndPointDesc?relay
   \   000061   7408         MOV     A,#0x8
   \   000063   12....       LCALL   ?XSTACK_DISP0_8
   \   000066   12....       LCALL   ?Subroutine16 & 0xFFFF
    592            if ( epDesc == NULL )
   \                     ??CrossCallReturnLabel_29:
   \   000069   7408         MOV     A,#0x8
   \   00006B   12....       LCALL   ?XSTACK_DISP0_8
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   7002         JNZ     ??zcl_SendCommand_0
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \                     ??zcl_SendCommand_0:
   \   000073   7005         JNZ     ??zcl_SendCommand_1
    593              return ( ZInvalidParameter ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_2:
   \   000075   7902         MOV     R1,#0x2
   \   000077   02....       LJMP    ??zcl_SendCommand_3 & 0xFFFF
    594          
    595            if ( clusterID == ZCL_INVALID_CLUSTER_ID )
   \                     ??zcl_SendCommand_1:
   \   00007A   7406         MOV     A,#0x6
   \   00007C   12....       LCALL   ?XSTACK_DISP0_8
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   64FF         XRL     A,#0xff
   \   000082   7004         JNZ     ??zcl_SendCommand_4
   \   000084   A3           INC     DPTR
   \   000085   E0           MOVX    A,@DPTR
   \   000086   64FF         XRL     A,#0xff
   \                     ??zcl_SendCommand_4:
   \   000088   60EB         JZ      ??zcl_SendCommand_2
    596              return ( ZInvalidParameter ); // EMBEDDED RETURN
    597          
    598          #if defined ( INTER_PAN )
    599            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
    600              options = AF_TX_OPTIONS_NONE;
    601            else
    602          #endif
    603              options = zclGetClusterOption( srcEP, clusterID );
   \   00008A                ; Setup parameters for call to function zclGetClusterOption
   \   00008A   7406         MOV     A,#0x6
   \   00008C   12....       LCALL   ?XSTACK_DISP0_8
   \   00008F   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   000092   12....       LCALL   ??zclGetClusterOption?relay
   \   000095   E9           MOV     A,R1
   \   000096   F5..         MOV     ?V0 + 7,A
    604            
    605            osal_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
   \   000098                ; Setup parameters for call to function osal_memset
   \   000098   7C06         MOV     R4,#0x6
   \   00009A   7D00         MOV     R5,#0x0
   \   00009C   7900         MOV     R1,#0x0
   \   00009E   85..82       MOV     DPL,?XSP + 0
   \   0000A1   85..83       MOV     DPH,?XSP + 1
   \   0000A4   AA82         MOV     R2,DPL
   \   0000A6   AB83         MOV     R3,DPH
   \   0000A8   12....       LCALL   ??osal_memset?relay
    606          
    607            // Not Profile wide command (like READ, WRITE)
    608            if ( specific )
   \   0000AB   E5..         MOV     A,?V0 + 3
   \   0000AD   85..82       MOV     DPL,?XSP + 0
   \   0000B0   85..83       MOV     DPH,?XSP + 1
   \   0000B3   6015         JZ      ??zcl_SendCommand_5
    609              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
   \   0000B5   E0           MOVX    A,@DPTR
   \   0000B6   54FC         ANL     A,#0xfc
   \   0000B8   F8           MOV     R0,A
   \   0000B9   A3           INC     DPTR
   \   0000BA   E0           MOVX    A,@DPTR
   \   0000BB   F9           MOV     R1,A
   \   0000BC   7401         MOV     A,#0x1
   \   0000BE   48           ORL     A,R0
   \   0000BF   85..82       MOV     DPL,?XSP + 0
   \   0000C2   85..83       MOV     DPH,?XSP + 1
   \   0000C5   F0           MOVX    @DPTR,A
   \   0000C6   A3           INC     DPTR
   \   0000C7   E9           MOV     A,R1
   \   0000C8   8006         SJMP    ??zcl_SendCommand_6
    610            else
    611              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
   \                     ??zcl_SendCommand_5:
   \   0000CA   E0           MOVX    A,@DPTR
   \   0000CB   54FC         ANL     A,#0xfc
   \   0000CD   F0           MOVX    @DPTR,A
   \   0000CE   A3           INC     DPTR
   \   0000CF   E0           MOVX    A,@DPTR
   \                     ??zcl_SendCommand_6:
   \   0000D0   F0           MOVX    @DPTR,A
    612          
    613            if ( zcl_DeviceOperational( srcEP, clusterID, hdr.fc.type, cmd, epDesc->simpleDesc->AppProfId ) == FALSE )
   \   0000D1                ; Setup parameters for call to function zcl_DeviceOperational
   \   0000D1   7408         MOV     A,#0x8
   \   0000D3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D6   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   0000D9   12....       LCALL   ??Subroutine163_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_291:
   \   0000DC   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000DF   EF           MOV     A,R7
   \   0000E0   FD           MOV     R5,A
   \   0000E1   7402         MOV     A,#0x2
   \   0000E3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E6   E0           MOVX    A,@DPTR
   \   0000E7   5403         ANL     A,#0x3
   \   0000E9   FC           MOV     R4,A
   \   0000EA   7408         MOV     A,#0x8
   \   0000EC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EF   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   0000F2   12....       LCALL   ??zcl_DeviceOperational?relay
   \   0000F5   7402         MOV     A,#0x2
   \   0000F7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000FA   E9           MOV     A,R1
   \   0000FB   7005         JNZ     ??zcl_SendCommand_7
    614              return ( ZFailure ); // EMBEDDED RETURN
   \   0000FD   7901         MOV     R1,#0x1
   \   0000FF   02....       LJMP    ??zcl_SendCommand_3 & 0xFFFF
    615            
    616            // Fill in the Maufacturer Code
    617            if ( manuCode != 0 )
   \                     ??zcl_SendCommand_7:
   \   000102   742A         MOV     A,#0x2a
   \   000104   12....       LCALL   ?XSTACK_DISP0_8
   \   000107   E0           MOVX    A,@DPTR
   \   000108   7002         JNZ     ??zcl_SendCommand_8
   \   00010A   A3           INC     DPTR
   \   00010B   E0           MOVX    A,@DPTR
   \                     ??zcl_SendCommand_8:
   \   00010C   601D         JZ      ??CrossCallReturnLabel_338
    618            {
    619              hdr.fc.manuSpecific = 1;
   \   00010E   85..82       MOV     DPL,?XSP + 0
   \   000111   85..83       MOV     DPH,?XSP + 1
   \   000114   E0           MOVX    A,@DPTR
   \   000115   4404         ORL     A,#0x4
   \   000117   F0           MOVX    @DPTR,A
   \   000118   A3           INC     DPTR
   \   000119   E0           MOVX    A,@DPTR
   \   00011A   F0           MOVX    @DPTR,A
    620              hdr.manuCode = manuCode;
   \   00011B   742A         MOV     A,#0x2a
   \   00011D   12....       LCALL   ?XSTACK_DISP0_8
   \   000120   12....       LCALL   ?Subroutine73 & 0xFFFF
    621            }
   \                     ??CrossCallReturnLabel_123:
   \   000123   7402         MOV     A,#0x2
   \   000125   12....       LCALL   ?XSTACK_DISP0_8
   \   000128   12....       LCALL   ??Subroutine171_0 & 0xFFFF
    622            
    623            // Set the Command Direction
    624            if ( direction )
   \                     ??CrossCallReturnLabel_338:
   \   00012B   E5..         MOV     A,?V0 + 6
   \   00012D   85..82       MOV     DPL,?XSP + 0
   \   000130   85..83       MOV     DPH,?XSP + 1
   \   000133   6005         JZ      ??zcl_SendCommand_9
    625              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   000135   E0           MOVX    A,@DPTR
   \   000136   4408         ORL     A,#0x8
   \   000138   8003         SJMP    ??zcl_SendCommand_10
    626            else
    627              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zcl_SendCommand_9:
   \   00013A   E0           MOVX    A,@DPTR
   \   00013B   54F7         ANL     A,#0xf7
   \                     ??zcl_SendCommand_10:
   \   00013D   F0           MOVX    @DPTR,A
   \   00013E   A3           INC     DPTR
   \   00013F   E0           MOVX    A,@DPTR
   \   000140   F0           MOVX    @DPTR,A
    628          
    629            // Set the Disable Default Response field
    630            if ( disableDefaultRsp )
   \   000141   E5..         MOV     A,?V0 + 5
   \   000143   85..82       MOV     DPL,?XSP + 0
   \   000146   85..83       MOV     DPH,?XSP + 1
   \   000149   6005         JZ      ??zcl_SendCommand_11
    631              hdr.fc.disableDefaultRsp = 1;
   \   00014B   E0           MOVX    A,@DPTR
   \   00014C   4410         ORL     A,#0x10
   \   00014E   8003         SJMP    ??zcl_SendCommand_12
    632            else
    633              hdr.fc.disableDefaultRsp = 0;
   \                     ??zcl_SendCommand_11:
   \   000150   E0           MOVX    A,@DPTR
   \   000151   54EF         ANL     A,#0xef
   \                     ??zcl_SendCommand_12:
   \   000153   F0           MOVX    @DPTR,A
   \   000154   A3           INC     DPTR
   \   000155   E0           MOVX    A,@DPTR
   \   000156   F0           MOVX    @DPTR,A
    634                               
    635            // Fill in the Transaction Sequence Number
    636            hdr.transSeqNum = seqNum;
   \   000157   7404         MOV     A,#0x4
   \   000159   12....       LCALL   ?XSTACK_DISP0_8
   \   00015C   E5..         MOV     A,?V0 + 4
   \   00015E   F0           MOVX    @DPTR,A
    637            
    638            // Fill in the command
    639            hdr.commandID = cmd;
   \   00015F   7405         MOV     A,#0x5
   \   000161   12....       LCALL   ?XSTACK_DISP0_8
   \   000164   EF           MOV     A,R7
   \   000165   F0           MOVX    @DPTR,A
    640            
    641            // calculate the needed buffer size
    642            msgLen = zclCalcHdrSize( &hdr );
   \   000166   7A03         MOV     R2,#0x3
   \   000168   85..82       MOV     DPL,?XSP + 0
   \   00016B   85..83       MOV     DPH,?XSP + 1
   \   00016E   E0           MOVX    A,@DPTR
   \   00016F   5404         ANL     A,#0x4
   \   000171   6002         JZ      ??zcl_SendCommand_13
   \   000173   0A           INC     R2
   \   000174   0A           INC     R2
    643            msgLen += cmdFormatLen;
   \                     ??zcl_SendCommand_13:
   \   000175   742D         MOV     A,#0x2d
   \   000177   12....       LCALL   ?XSTACK_DISP0_8
   \   00017A   E0           MOVX    A,@DPTR
   \   00017B   2A           ADD     A,R2
   \   00017C   FA           MOV     R2,A
    644          
    645            // Allocate the buffer needed
    646            msgBuf = osal_mem_alloc( msgLen );
   \   00017D   8A82         MOV     DPL,R2
   \   00017F   8582..       MOV     ?V0 + 0,DPL
   \   000182   75..00       MOV     ?V0 + 1,#0x0
   \   000185                ; Setup parameters for call to function osal_mem_alloc
   \   000185   7B00         MOV     R3,#0x0
   \   000187   12....       LCALL   ??osal_mem_alloc?relay
   \   00018A   8A..         MOV     ?V0 + 2,R2
   \   00018C   8B..         MOV     ?V0 + 3,R3
    647            if ( msgBuf != NULL )
   \   00018E   EA           MOV     A,R2
   \   00018F   7001         JNZ     ??zcl_SendCommand_14
   \   000191   EB           MOV     A,R3
   \                     ??zcl_SendCommand_14:
   \   000192   6078         JZ      ??zcl_SendCommand_15
    648            {
    649              // Fill in the ZCL Header
    650              pBuf = zclBuildHdr( &hdr, msgBuf );
    651          
    652              // Fill in the command frame
    653              osal_memcpy( pBuf, cmdFormat, cmdFormatLen );
   \   000194                ; Setup parameters for call to function osal_memcpy
   \   000194   742E         MOV     A,#0x2e
   \   000196   12....       LCALL   ?XSTACK_DISP0_8
   \   000199   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   00019C   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00019F   7430         MOV     A,#0x30
   \   0001A1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A4   E0           MOVX    A,@DPTR
   \   0001A5   F5..         MOV     ?V0 + 4,A
   \   0001A7                ; Setup parameters for call to function zclBuildHdr
   \   0001A7   AC..         MOV     R4,?V0 + 2
   \   0001A9   AD..         MOV     R5,?V0 + 3
   \   0001AB   7403         MOV     A,#0x3
   \   0001AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B0   AA82         MOV     R2,DPL
   \   0001B2   AB83         MOV     R3,DPH
   \   0001B4   12....       LCALL   ??zclBuildHdr?relay
   \   0001B7   AC..         MOV     R4,?V0 + 4
   \   0001B9   7D00         MOV     R5,#0x0
   \   0001BB   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_200:
   \   0001BE   12....       LCALL   ?DEALLOC_XSTACK8
    654          
    655              status = AF_DataRequest( &dstAddr, epDesc, clusterID, msgLen, msgBuf, 
    656                                       &zcl_TransID, options, AF_DEFAULT_RADIUS );  
   \   0001C1                ; Setup parameters for call to function AF_DataRequest
   \   0001C1   75..1E       MOV     ?V0 + 4,#0x1e
   \   0001C4   78..         MOV     R0,#?V0 + 4
   \   0001C6   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001C9   75....       MOV     ?V0 + 4,#(zcl_TransID & 0xff)
   \   0001CC   75....       MOV     ?V0 + 5,#((zcl_TransID >> 8) & 0xff)
   \   0001CF   78..         MOV     R0,#?V0 + 4
   \   0001D1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001D4   78..         MOV     R0,#?V0 + 2
   \   0001D6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001D9   78..         MOV     R0,#?V0 + 0
   \   0001DB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001DE   740D         MOV     A,#0xd
   \   0001E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E3   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0001E6   A9..         MOV     R1,?V0 + 7
   \   0001E8   7411         MOV     A,#0x11
   \   0001EA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001ED   12....       LCALL   ??Subroutine174_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_364:
   \   0001F0   7413         MOV     A,#0x13
   \   0001F2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F5   AA82         MOV     R2,DPL
   \   0001F7   AB83         MOV     R3,DPH
   \   0001F9   12....       LCALL   ??AF_DataRequest?relay
   \   0001FC   7409         MOV     A,#0x9
   \   0001FE   12....       LCALL   ?DEALLOC_XSTACK8
   \   000201   E9           MOV     A,R1
   \   000202   FE           MOV     R6,A
    657              osal_mem_free ( msgBuf );
   \   000203                ; Setup parameters for call to function osal_mem_free
   \   000203   AA..         MOV     R2,?V0 + 2
   \   000205   AB..         MOV     R3,?V0 + 3
   \   000207   12....       LCALL   ??osal_mem_free?relay
   \   00020A   8002         SJMP    ??zcl_SendCommand_16
    658            }
    659            else
    660              status = ZMemError;
   \                     ??zcl_SendCommand_15:
   \   00020C   7E10         MOV     R6,#0x10
    661          
    662            return ( status );
   \                     ??zcl_SendCommand_16:
   \   00020E   EE           MOV     A,R6
   \   00020F   F9           MOV     R1,A
   \                     ??zcl_SendCommand_3:
   \   000210   7416         MOV     A,#0x16
   \   000212   02....       LJMP    ??Subroutine152_0 & 0xFFFF
    663          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_285:
   \   000003   EE           MOV     A,R6
   \   000004   F9           MOV     R1,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine152_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine153_0
   \   000003                ; // Fall through to label ??Subroutine153_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine153_0:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   12....       LCALL   ?Subroutine107 & 0xFFFF
   \                     ??CrossCallReturnLabel_335:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine135:
   \   000000   12....       LCALL   ??osal_memcpy?relay
   \   000003   7403         MOV     A,#0x3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 5,A
   \   000007   75..00       MOV     ?V0 + 6,#0x0
   \   00000A   78..         MOV     R0,#?V0 + 4
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine163_0:
   \   000000   12....       LCALL   ?Subroutine109 & 0xFFFF
   \                     ??CrossCallReturnLabel_302:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine109:
   \   000000   12....       LCALL   ?Subroutine125 & 0xFFFF
   \                     ??CrossCallReturnLabel_304:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine125:
   \   000000   12....       LCALL   ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_362:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   12....       LCALL   ?Subroutine109 & 0xFFFF
   \                     ??CrossCallReturnLabel_300:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine130:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine171_0:
   \   000000   E8           MOV     A,R0
   \   000001                REQUIRE ??Subroutine172_0
   \   000001                ; // Fall through to label ??Subroutine172_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine172_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine174_0:
   \   000000   12....       LCALL   ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_375:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine112:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine107:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
    664          
    665          #ifdef ZCL_READ
    666          /*********************************************************************
    667           * @fn      zcl_SendRead
    668           *
    669           * @brief   Send a Read command
    670           *
    671           * @param   srcEP - Application's endpoint
    672           * @param   dstAddr - destination address
    673           * @param   clusterID - cluster ID
    674           * @param   readCmd - read command to be sent
    675           * @param   direction - direction of the command
    676           * @param   seqNum - transaction sequence number
    677           *
    678           * @return  ZSuccess if OK
    679           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    680          ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendRead:
    681                                  uint16 clusterID, zclReadCmd_t *readCmd,
    682                                  uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
    683          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000012   E9           MOV     A,R1
   \   000013   FE           MOV     R6,A
   \   000014   7415         MOV     A,#0x15
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F5..         MOV     ?V0 + 6,A
   \   00001C   7416         MOV     A,#0x16
   \   00001E   12....       LCALL   ?XSTACK_DISP0_8
   \   000021   E0           MOVX    A,@DPTR
   \   000022   FF           MOV     R7,A
   \   000023   7417         MOV     A,#0x17
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F5..         MOV     ?V0 + 2,A
    684            uint8 dataLen;
    685            uint8 *buf;
    686            uint8 *pBuf;
    687            ZStatus_t status;
    688          
    689            dataLen = readCmd->numAttr * 2; // Attribute ID
   \   00002B   7413         MOV     A,#0x13
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   12....       LCALL   ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_348:
   \   000033   C3           CLR     C
   \   000034   33           RLC     A
   \   000035   F5..         MOV     ?V0 + 3,A
    690          
    691            buf = osal_mem_alloc( dataLen );
   \   000037                ; Setup parameters for call to function osal_mem_alloc
   \   000037   FA           MOV     R2,A
   \   000038   7B00         MOV     R3,#0x0
   \   00003A   12....       LCALL   ??osal_mem_alloc?relay
   \   00003D   8B..         MOV     ?V0 + 1,R3
   \   00003F   8A..         MOV     ?V0 + 4,R2
   \   000041   8B..         MOV     ?V0 + 5,R3
    692            if ( buf != NULL )
   \   000043   EA           MOV     A,R2
   \   000044   7001         JNZ     ??zcl_SendRead_0
   \   000046   EB           MOV     A,R3
   \                     ??zcl_SendRead_0:
   \   000047   7003         JNZ     $+5
   \   000049   02....       LJMP    ??zcl_SendRead_1 & 0xFFFF
    693            {
    694              uint8 i;
    695          
    696              // Load the buffer - serially
    697              pBuf = buf;   
   \   00004C   A8..         MOV     R0,?V0 + 4
   \   00004E   A9..         MOV     R1,?V0 + 5
    698              for (i = 0; i < readCmd->numAttr; i++)
   \   000050   75..00       MOV     ?V0 + 0,#0x0
   \   000053   8028         SJMP    ??zcl_SendRead_2
    699              {
    700                *pBuf++ = LO_UINT16( readCmd->attrID[i] );
   \                     ??zcl_SendRead_3:
   \   000055   E5..         MOV     A,?V0 + 0
   \   000057   C3           CLR     C
   \   000058   33           RLC     A
   \   000059   FA           MOV     R2,A
   \   00005A   E4           CLR     A
   \   00005B   33           RLC     A
   \   00005C   FB           MOV     R3,A
   \   00005D   7413         MOV     A,#0x13
   \   00005F   12....       LCALL   ?XSTACK_DISP0_8
   \   000062   E0           MOVX    A,@DPTR
   \   000063   2A           ADD     A,R2
   \   000064   FC           MOV     R4,A
   \   000065   A3           INC     DPTR
   \   000066   E0           MOVX    A,@DPTR
   \   000067   3B           ADDC    A,R3
   \   000068   8C82         MOV     DPL,R4
   \   00006A   F583         MOV     DPH,A
   \   00006C   A3           INC     DPTR
   \   00006D   AA82         MOV     R2,DPL
   \   00006F   AB83         MOV     R3,DPH
   \   000071   12....       LCALL   ?Subroutine64 & 0xFFFF
    701                *pBuf++ = HI_UINT16( readCmd->attrID[i] );
   \                     ??CrossCallReturnLabel_107:
   \   000074   8A82         MOV     DPL,R2
   \   000076   8B83         MOV     DPH,R3
   \   000078   12....       LCALL   ?Subroutine41 & 0xFFFF
    702              }
   \                     ??CrossCallReturnLabel_214:
   \   00007B   05..         INC     ?V0 + 0
   \                     ??zcl_SendRead_2:
   \   00007D   7413         MOV     A,#0x13
   \   00007F   12....       LCALL   ?XSTACK_DISP0_8
   \   000082   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   000085   E0           MOVX    A,@DPTR
   \   000086   FA           MOV     R2,A
   \   000087   E5..         MOV     A,?V0 + 0
   \   000089   C3           CLR     C
   \   00008A   9A           SUBB    A,R2
   \   00008B   40C8         JC      ??zcl_SendRead_3
    703            
    704              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
    705                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );  
   \   00008D                ; Setup parameters for call to function zcl_SendCommand
   \   00008D   85....       MOV     ?V0 + 0,?V0 + 4
   \   000090   78..         MOV     R0,#?V0 + 0
   \   000092   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000095   E5..         MOV     A,?V0 + 3
   \   000097   F5..         MOV     ?V0 + 0,A
   \   000099   78..         MOV     R0,#?V0 + 0
   \   00009B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00009E   E5..         MOV     A,?V0 + 2
   \   0000A0   F5..         MOV     ?V0 + 0,A
   \   0000A2   78..         MOV     R0,#?V0 + 0
   \   0000A4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A7   75..00       MOV     ?V0 + 0,#0x0
   \   0000AA   75..00       MOV     ?V0 + 1,#0x0
   \   0000AD   78..         MOV     R0,#?V0 + 0
   \   0000AF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B2   EF           MOV     A,R7
   \   0000B3   F5..         MOV     ?V0 + 0,A
   \   0000B5   78..         MOV     R0,#?V0 + 0
   \   0000B7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BA   E5..         MOV     A,?V0 + 6
   \   0000BC   F5..         MOV     ?V0 + 0,A
   \   0000BE   78..         MOV     R0,#?V0 + 0
   \   0000C0   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C3   75..00       MOV     ?V0 + 0,#0x0
   \   0000C6   78..         MOV     R0,#?V0 + 0
   \   0000C8   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000CB   78..         MOV     R0,#?V0 + 0
   \   0000CD   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D0   740A         MOV     A,#0xa
   \   0000D2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D5   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   0000D8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DB   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   0000DE   12....       LCALL   ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   0000E1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E4   E9           MOV     A,R1
   \   0000E5   FE           MOV     R6,A
    706              osal_mem_free( buf );
   \   0000E6                ; Setup parameters for call to function osal_mem_free
   \   0000E6   AA..         MOV     R2,?V0 + 4
   \   0000E8   AB..         MOV     R3,?V0 + 5
   \   0000EA   12....       LCALL   ??osal_mem_free?relay
   \   0000ED   8002         SJMP    ??zcl_SendRead_4
    707            }
    708            else
    709              status = ZMemError;
   \                     ??zcl_SendRead_1:
   \   0000EF   7E10         MOV     R6,#0x10
    710          
    711            return ( status );
   \                     ??zcl_SendRead_4:
   \   0000F1   EE           MOV     A,R6
   \   0000F2   F9           MOV     R1,A
   \   0000F3   7404         MOV     A,#0x4
   \   0000F5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F8                REQUIRE ?Subroutine143
   \   0000F8                ; // Fall through to label ?Subroutine143
    712          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine143:
   \   000000   7F07         MOV     R7,#0x7
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine146_0
   \   000001                ; // Fall through to label ??Subroutine146_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine146_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   08           INC     R0
   \   000008   A983         MOV     R1,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine116:
   \   000000   12....       LCALL   ??zcl_SendCommand?relay
   \   000003   740A         MOV     A,#0xa
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   12....       LCALL   ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_374:
   \   000003   740C         MOV     A,#0xc
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   A882         MOV     R0,DPL
   \   000009   A983         MOV     R1,DPH
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_151:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine92:
   \   000000   12....       LCALL   ?Subroutine121 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   000003   EC           MOV     A,R4
   \   000004   F0           MOVX    @DPTR,A
   \   000005   A3           INC     DPTR
   \   000006   ED           MOV     A,R5
   \   000007   F0           MOVX    @DPTR,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine121:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004                REQUIRE ??Subroutine150_0
   \   000004                ; // Fall through to label ??Subroutine150_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine150_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function zcl_SendCommand
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine126:
   \   000000   12....       LCALL   ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_363:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8A82         MOV     DPL,R2
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine173_0:
   \   000000   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_359:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine101:
   \   000000   12....       LCALL   ?Subroutine126 & 0xFFFF
   \                     ??CrossCallReturnLabel_361:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET
    713          
    714          /*********************************************************************
    715           * @fn      zcl_SendReadRsp
    716           *
    717           * @brief   Send a Read Response command.
    718           *
    719           * @param   srcEP - Application's endpoint
    720           * @param   dstAddr - destination address
    721           * @param   clusterID - cluster ID
    722           * @param   readRspCmd - read response command to be sent
    723           * @param   direction - direction of the command
    724           * @param   seqNum - transaction sequence number
    725           *
    726           * @return  ZSuccess if OK
    727           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    728          ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadRsp:
    729                                     uint16 clusterID, zclReadRspCmd_t *readRspCmd,
    730                                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    731          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine3 & 0xFFFF
    732            uint8 *buf;
    733            uint8 *pBuf;
    734            zclReadRspStatus_t *statusRec;
    735            uint8 len = 0;
    736            uint8 i;
    737            ZStatus_t status;
    738            
    739            // calculate the size of the command
    740            for ( i = 0; i < readRspCmd->numAttr; i++ )
   \                     ??CrossCallReturnLabel_4:
   \   000012   8026         SJMP    ??zcl_SendReadRsp_0
    741            {
    742              statusRec = &(readRspCmd->attrList[i]);
   \                     ??zcl_SendReadRsp_1:
   \   000014   E5..         MOV     A,?V0 + 0
   \   000016   75F006       MOV     B,#0x6
   \   000019   A4           MUL     AB
   \   00001A   F8           MOV     R0,A
   \   00001B   A9F0         MOV     R1,B
   \   00001D   7414         MOV     A,#0x14
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   12....       LCALL   ?Subroutine42 & 0xFFFF
    743              
    744              len += 2 + 1; // Attribute ID + Status
   \                     ??CrossCallReturnLabel_66:
   \   000025   05..         INC     ?V0 + 1
   \   000027   05..         INC     ?V0 + 1
   \   000029   05..         INC     ?V0 + 1
    745          
    746              if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   7008         JNZ     ??zcl_SendReadRsp_2
    747              {
    748                len++; // Attribute Data Type
    749                len += zclGetAttrDataLength( statusRec->dataType, statusRec->data); // Attribute Data
   \   000030                ; Setup parameters for call to function zclGetAttrDataLength
   \   000030   12....       LCALL   ?Subroutine33 & 0xFFFF
    750              }
    751            }
   \                     ??CrossCallReturnLabel_52:
   \   000033   04           INC     A
   \   000034   25..         ADD     A,?V0 + 1
   \   000036   F5..         MOV     ?V0 + 1,A
   \                     ??zcl_SendReadRsp_2:
   \   000038   05..         INC     ?V0 + 0
   \                     ??zcl_SendReadRsp_0:
   \   00003A   7414         MOV     A,#0x14
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000042   40D0         JC      ??zcl_SendReadRsp_1
    752          
    753            buf = osal_mem_alloc( len );
   \   000044                ; Setup parameters for call to function osal_mem_alloc
   \   000044   12....       LCALL   ?Subroutine79 & 0xFFFF
    754            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_216:
   \   000047   7001         JNZ     ??zcl_SendReadRsp_3
   \   000049   EB           MOV     A,R3
   \                     ??zcl_SendReadRsp_3:
   \   00004A   7003         JNZ     $+5
   \   00004C   02....       LJMP    ??zcl_SendReadRsp_4 & 0xFFFF
    755            {
    756              // Load the buffer - serially
    757              pBuf = buf;
   \   00004F   AE..         MOV     R6,?V0 + 6
   \   000051   AF..         MOV     R7,?V0 + 7
    758              for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000053   75..00       MOV     ?V0 + 0,#0x0
   \   000056   8046         SJMP    ??zcl_SendReadRsp_5
    759              {
    760                statusRec = &(readRspCmd->attrList[i]);
   \                     ??zcl_SendReadRsp_6:
   \   000058   E5..         MOV     A,?V0 + 0
   \   00005A   75F006       MOV     B,#0x6
   \   00005D   A4           MUL     AB
   \   00005E   F8           MOV     R0,A
   \   00005F   A9F0         MOV     R1,B
   \   000061   7414         MOV     A,#0x14
   \   000063   12....       LCALL   ?XSTACK_DISP0_8
   \   000066   12....       LCALL   ?Subroutine4 & 0xFFFF
    761                
    762                *pBuf++ = LO_UINT16( statusRec->attrID );
    763                *pBuf++ = HI_UINT16( statusRec->attrID );
    764                *pBuf++ = statusRec->status;
   \                     ??CrossCallReturnLabel_6:
   \   000069   E5..         MOV     A,?V0 + 2
   \   00006B   2402         ADD     A,#0x2
   \   00006D   F8           MOV     R0,A
   \   00006E   E5..         MOV     A,?V0 + 3
   \   000070   12....       LCALL   ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_253:
   \   000073   12....       LCALL   ??Subroutine149_0 & 0xFFFF
    765          
    766                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??CrossCallReturnLabel_223:
   \   000076   8882         MOV     DPL,R0
   \   000078   8983         MOV     DPH,R1
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   701F         JNZ     ??zcl_SendReadRsp_7
   \   00007D   85..82       MOV     DPL,?V0 + 2
   \   000080   85..83       MOV     DPH,?V0 + 3
   \   000083   A3           INC     DPTR
   \   000084   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000087   A3           INC     DPTR
   \   000088   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   00008B   A3           INC     DPTR
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   F9           MOV     R1,A
    767                {
    768                  *pBuf++ = statusRec->dataType;
    769                  zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
   \   00008E   12....       LCALL   ??zclSerializeData?relay
    770                  
    771                  // move pass attribute data
    772                  pBuf += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
   \   000091                ; Setup parameters for call to function zclGetAttrDataLength
   \   000091   12....       LCALL   ?Subroutine33 & 0xFFFF
    773                }
    774              } // for loop
   \                     ??CrossCallReturnLabel_53:
   \   000094   F8           MOV     R0,A
   \   000095   EE           MOV     A,R6
   \   000096   28           ADD     A,R0
   \   000097   FE           MOV     R6,A
   \   000098   EF           MOV     A,R7
   \   000099   3400         ADDC    A,#0x0
   \   00009B   FF           MOV     R7,A
   \                     ??zcl_SendReadRsp_7:
   \   00009C   05..         INC     ?V0 + 0
   \                     ??zcl_SendReadRsp_5:
   \   00009E   7414         MOV     A,#0x14
   \   0000A0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A3   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   0000A6   40B0         JC      ??zcl_SendReadRsp_6
    775          
    776              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE, 
    777                                        direction, disableDefaultRsp, 0, seqNum, len, buf );
   \   0000A8                ; Setup parameters for call to function zcl_SendCommand
   \   0000A8   78..         MOV     R0,#?V0 + 6
   \   0000AA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AD   E5..         MOV     A,?V0 + 1
   \   0000AF   F5..         MOV     ?V0 + 0,A
   \   0000B1   78..         MOV     R0,#?V0 + 0
   \   0000B3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B6   741B         MOV     A,#0x1b
   \   0000B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BB   12....       LCALL   ??Subroutine154_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   0000BE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C1   75..00       MOV     ?V0 + 0,#0x0
   \   0000C4   75..00       MOV     ?V0 + 1,#0x0
   \   0000C7   78..         MOV     R0,#?V0 + 0
   \   0000C9   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000CC   741D         MOV     A,#0x1d
   \   0000CE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D1   12....       LCALL   ??Subroutine154_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   0000D4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D7   741D         MOV     A,#0x1d
   \   0000D9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DC   12....       LCALL   ??Subroutine154_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_231:
   \   0000DF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000E2   75..00       MOV     ?V0 + 0,#0x0
   \   0000E5   78..         MOV     R0,#?V0 + 0
   \   0000E7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000EA   75..01       MOV     ?V0 + 0,#0x1
   \   0000ED   78..         MOV     R0,#?V0 + 0
   \   0000EF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000F2   740A         MOV     A,#0xa
   \   0000F4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F7   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   0000FA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FD   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   000100   12....       LCALL   ?DEALLOC_XSTACK8
   \   000103   E9           MOV     A,R1
   \   000104   FE           MOV     R6,A
    778              osal_mem_free( buf );
   \   000105                ; Setup parameters for call to function osal_mem_free
   \   000105   AA..         MOV     R2,?V0 + 6
   \   000107   AB..         MOV     R3,?V0 + 7
   \   000109   12....       LCALL   ??osal_mem_free?relay
   \   00010C   8002         SJMP    ??zcl_SendReadRsp_8
    779            }
    780            else
    781              status = ZMemError;
   \                     ??zcl_SendReadRsp_4:
   \   00010E   7E10         MOV     R6,#0x10
    782          
    783            return ( status );
   \                     ??zcl_SendReadRsp_8:
   \   000110                REQUIRE ?Subroutine145
   \   000110                ; // Fall through to label ?Subroutine145
    784          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine145:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002   02....       LJMP    ??Subroutine151_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   AA..         MOV     R2,?V0 + 1
   \   000002                REQUIRE ??Subroutine147_0
   \   000002                ; // Fall through to label ??Subroutine147_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine147_0:
   \   000000   7B00         MOV     R3,#0x0
   \   000002   12....       LCALL   ??osal_mem_alloc?relay
   \   000005   8A..         MOV     ?V0 + 6,R2
   \   000007   8B..         MOV     ?V0 + 7,R3
   \   000009   EA           MOV     A,R2
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   85..82       MOV     DPL,?V0 + 2
   \   000003   85..83       MOV     DPH,?V0 + 3
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_221:
   \   00000A   A3           INC     DPTR
   \   00000B   12....       LCALL   ?Subroutine124 & 0xFFFF
   \                     ??CrossCallReturnLabel_265:
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine98:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine148_0
   \   000003                ; // Fall through to label ??Subroutine148_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine148_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   85..82       MOV     DPL,?V0 + 2
   \   000008   85..83       MOV     DPH,?V0 + 3
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_284:
   \   000003   A9..         MOV     R1,?V0 + 4
   \   000005   12....       LCALL   ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_175:
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   12....       LCALL   ??Subroutine148_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_220:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_160:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine103:
   \   000000   12....       LCALL   ?Subroutine123 & 0xFFFF
   \                     ??CrossCallReturnLabel_184:
   \   000003   8582..       MOV     ?V0 + 2,DPL
   \   000006   8583..       MOV     ?V0 + 3,DPH
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine124:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000005   E9           MOV     A,R1
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_354:
   \   000003   FA           MOV     R2,A
   \   000004   E5..         MOV     A,?V0 + 0
   \   000006   C3           CLR     C
   \   000007   9A           SUBB    A,R2
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   A3           INC     DPTR
   \   000001   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_225:
   \   000004                ; Setup parameters for call to function zclSerializeData
   \   000004                ; Setup parameters for call to function zclSerializeData
   \   000004   EE           MOV     A,R6
   \   000005   FC           MOV     R4,A
   \   000006   EF           MOV     A,R7
   \   000007   FD           MOV     R5,A
   \   000008   85..82       MOV     DPL,?V0 + 2
   \   00000B   85..83       MOV     DPH,?V0 + 3
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_159:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   8E82         MOV     DPL,R6
   \   000006   8F83         MOV     DPH,R7
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   AE82         MOV     R6,DPL
   \   00000C   AF83         MOV     R7,DPH
   \   00000E   85..82       MOV     DPL,?V0 + 2
   \   000011   85..83       MOV     DPH,?V0 + 3
   \   000014   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_224:
   \   000017   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine102:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine149_0
   \   000001                ; // Fall through to label ??Subroutine149_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine149_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   0E           INC     R6
   \   000008   AF83         MOV     R7,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   000003   89..         MOV     ?V0 + 4,R1
   \   000005   75..00       MOV     ?V0 + 1,#0x0
   \   000008   75..00       MOV     ?V0 + 0,#0x0
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine151_0:
   \   000000   7404         MOV     A,#0x4
   \   000002                REQUIRE ??Subroutine152_0
   \   000002                ; // Fall through to label ??Subroutine152_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine154_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 0,A
   \   000003   78..         MOV     R0,#?V0 + 0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine133:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F9           MOV     R1,A
   \   000003                REQUIRE ??Subroutine157_0
   \   000003                ; // Fall through to label ??Subroutine157_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine123:
   \   000000   12....       LCALL   ?Subroutine129 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine129:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   28           ADD     A,R0
   \   000002   FA           MOV     R2,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   39           ADDC    A,R1
   \   000006   8A82         MOV     DPL,R2
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET
    785          #endif // ZCL_READ
    786          
    787          #ifdef ZCL_WRITE
    788          /*********************************************************************
    789           * @fn      sendWriteRequest
    790           *
    791           * @brief   Send a Write command
    792           *
    793           * @param   dstAddr - destination address
    794           * @param   clusterID - cluster ID
    795           * @param   writeCmd - write command to be sent
    796           * @param   cmd - ZCL_CMD_WRITE, ZCL_CMD_WRITE_UNDIVIDED or ZCL_CMD_WRITE_NO_RSP
    797           * @param   direction - direction of the command
    798           * @param   seqNum - transaction sequence number
    799           *
    800           * @return  ZSuccess if OK
    801           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    802          ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID, 
   \                     zcl_SendWriteRequest:
    803                                          zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction, 
    804                                          uint8 disableDefaultRsp, uint8 seqNum )
    805          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine3 & 0xFFFF
    806            uint8 *buf;
    807            uint8 *pBuf;
    808            zclWriteRec_t *statusRec;
    809            uint8 attrDataLen;
    810            uint8 dataLen = 0;
    811            uint8 i;
    812            ZStatus_t status;
    813            
    814            for ( i = 0; i < writeCmd->numAttr; i++ )
   \                     ??CrossCallReturnLabel_5:
   \   000012   801C         SJMP    ??zcl_SendWriteRequest_0
    815            {
    816              statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_1:
   \   000014   E5..         MOV     A,?V0 + 0
   \   000016   75F005       MOV     B,#0x5
   \   000019   A4           MUL     AB
   \   00001A   F8           MOV     R0,A
   \   00001B   A9F0         MOV     R1,B
   \   00001D   7414         MOV     A,#0x14
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   12....       LCALL   ?Subroutine42 & 0xFFFF
    817              
    818              attrDataLen = zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
    819              dataLen += 2 + 1 + attrDataLen; // Attribute ID + Attribute Type + Attribute Data
   \                     ??CrossCallReturnLabel_67:
   \   000025                ; Setup parameters for call to function zclGetAttrDataLength
   \   000025   12....       LCALL   ?Subroutine35 & 0xFFFF
    820            }
   \                     ??CrossCallReturnLabel_56:
   \   000028   2403         ADD     A,#0x3
   \   00002A   25..         ADD     A,?V0 + 1
   \   00002C   F5..         MOV     ?V0 + 1,A
   \   00002E   05..         INC     ?V0 + 0
   \                     ??zcl_SendWriteRequest_0:
   \   000030   7414         MOV     A,#0x14
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   000038   40DA         JC      ??zcl_SendWriteRequest_1
    821          
    822            buf = osal_mem_alloc( dataLen );
   \   00003A                ; Setup parameters for call to function osal_mem_alloc
   \   00003A   12....       LCALL   ?Subroutine79 & 0xFFFF
    823            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_217:
   \   00003D   7001         JNZ     ??zcl_SendWriteRequest_2
   \   00003F   EB           MOV     A,R3
   \                     ??zcl_SendWriteRequest_2:
   \   000040   7003         JNZ     $+5
   \   000042   02....       LJMP    ??zcl_SendWriteRequest_3 & 0xFFFF
    824            {
    825              // Load the buffer - serially
    826              pBuf = buf;
   \   000045   AE..         MOV     R6,?V0 + 6
   \   000047   AF..         MOV     R7,?V0 + 7
    827              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000049   75..00       MOV     ?V0 + 0,#0x0
   \   00004C   8035         SJMP    ??zcl_SendWriteRequest_4
    828              { 
    829                statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_5:
   \   00004E   E5..         MOV     A,?V0 + 0
   \   000050   75F005       MOV     B,#0x5
   \   000053   A4           MUL     AB
   \   000054   F8           MOV     R0,A
   \   000055   A9F0         MOV     R1,B
   \   000057   7414         MOV     A,#0x14
   \   000059   12....       LCALL   ?XSTACK_DISP0_8
   \   00005C   12....       LCALL   ?Subroutine4 & 0xFFFF
    830                
    831                *pBuf++ = LO_UINT16( statusRec->attrID );
    832                *pBuf++ = HI_UINT16( statusRec->attrID );
   \                     ??CrossCallReturnLabel_7:
   \   00005F   85..82       MOV     DPL,?V0 + 2
   \   000062   85..83       MOV     DPH,?V0 + 3
   \   000065   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000068   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   F9           MOV     R1,A
    833                *pBuf++ = statusRec->dataType;
    834                
    835                zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
   \   00006D   12....       LCALL   ??zclSerializeData?relay
    836                
    837                attrDataLen = zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
    838                pBuf += attrDataLen; // move pass attribute data
   \   000070                ; Setup parameters for call to function zclGetAttrDataLength
   \   000070   85..82       MOV     DPL,?V0 + 2
   \   000073   85..83       MOV     DPH,?V0 + 3
   \   000076   12....       LCALL   ?Subroutine35 & 0xFFFF
    839              }
   \                     ??CrossCallReturnLabel_57:
   \   000079   F8           MOV     R0,A
   \   00007A   EE           MOV     A,R6
   \   00007B   28           ADD     A,R0
   \   00007C   FE           MOV     R6,A
   \   00007D   EF           MOV     A,R7
   \   00007E   3400         ADDC    A,#0x0
   \   000080   FF           MOV     R7,A
   \   000081   05..         INC     ?V0 + 0
   \                     ??zcl_SendWriteRequest_4:
   \   000083   7414         MOV     A,#0x14
   \   000085   12....       LCALL   ?XSTACK_DISP0_8
   \   000088   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   00008B   40C1         JC      ??zcl_SendWriteRequest_5
    840          
    841              status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE, 
    842                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   00008D                ; Setup parameters for call to function zcl_SendCommand
   \   00008D   78..         MOV     R0,#?V0 + 6
   \   00008F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000092   E5..         MOV     A,?V0 + 1
   \   000094   F5..         MOV     ?V0 + 0,A
   \   000096   78..         MOV     R0,#?V0 + 0
   \   000098   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00009B   741C         MOV     A,#0x1c
   \   00009D   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A0   12....       LCALL   ??Subroutine154_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_232:
   \   0000A3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A6   75..00       MOV     ?V0 + 0,#0x0
   \   0000A9   75..00       MOV     ?V0 + 1,#0x0
   \   0000AC   78..         MOV     R0,#?V0 + 0
   \   0000AE   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B1   741E         MOV     A,#0x1e
   \   0000B3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B6   12....       LCALL   ??Subroutine154_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_233:
   \   0000B9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BC   741E         MOV     A,#0x1e
   \   0000BE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C1   12....       LCALL   ??Subroutine154_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   0000C4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C7   75..00       MOV     ?V0 + 0,#0x0
   \   0000CA   78..         MOV     R0,#?V0 + 0
   \   0000CC   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000CF   741F         MOV     A,#0x1f
   \   0000D1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D4   12....       LCALL   ??Subroutine154_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_235:
   \   0000D7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000DA   740A         MOV     A,#0xa
   \   0000DC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DF   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   0000E2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E5   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   0000E8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EB   E9           MOV     A,R1
   \   0000EC   FE           MOV     R6,A
    843              osal_mem_free( buf );
   \   0000ED                ; Setup parameters for call to function osal_mem_free
   \   0000ED   AA..         MOV     R2,?V0 + 6
   \   0000EF   AB..         MOV     R3,?V0 + 7
   \   0000F1   12....       LCALL   ??osal_mem_free?relay
   \   0000F4   8002         SJMP    ??zcl_SendWriteRequest_6
    844            }
    845            else
    846              status = ZMemError;
   \                     ??zcl_SendWriteRequest_3:
   \   0000F6   7E10         MOV     R6,#0x10
    847          
    848            return ( status);
   \                     ??zcl_SendWriteRequest_6:
   \   0000F8   02....       LJMP    ?Subroutine145 & 0xFFFF
    849          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_222:
   \   000003   12....       LCALL   ?Subroutine124 & 0xFFFF
   \                     ??CrossCallReturnLabel_266:
   \   000006   22           RET
    850          
    851          /*********************************************************************
    852           * @fn      zcl_SendWriteRsp
    853           *
    854           * @brief   Send a Write Response command
    855           *
    856           * @param   dstAddr - destination address
    857           * @param   clusterID - cluster ID
    858           * @param   wrtieRspCmd - write response command to be sent
    859           * @param   direction - direction of the command
    860           * @param   seqNum - transaction sequence number
    861           *
    862           * @return  ZSuccess if OK
    863           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    864          ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendWriteRsp:
    865                                      uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
    866                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    867          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000012   89..         MOV     ?V0 + 0,R1
   \   000014   7414         MOV     A,#0x14
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   12....       LCALL   ??Subroutine166_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_313:
   \   00001C   7417         MOV     A,#0x17
   \   00001E   12....       LCALL   ?XSTACK_DISP0_8
   \   000021   E0           MOVX    A,@DPTR
   \   000022   F5..         MOV     ?V0 + 5,A
   \   000024   7418         MOV     A,#0x18
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F5..         MOV     ?V0 + 1,A
    868            uint8 dataLen;
    869            uint8 *buf;
    870            uint8 *pBuf;
    871            uint8 i;
    872            ZStatus_t status;
    873            
    874            dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
   \   00002C   75F003       MOV     B,#0x3
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   E0           MOVX    A,@DPTR
   \   000034   A4           MUL     AB
   \   000035   F5..         MOV     ?V0 + 4,A
    875          
    876            buf = osal_mem_alloc( dataLen );
   \   000037                ; Setup parameters for call to function osal_mem_alloc
   \   000037   FA           MOV     R2,A
   \   000038   12....       LCALL   ??Subroutine147_0 & 0xFFFF
    877            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_218:
   \   00003B   7001         JNZ     ??zcl_SendWriteRsp_0
   \   00003D   EB           MOV     A,R3
   \                     ??zcl_SendWriteRsp_0:
   \   00003E   7003         JNZ     $+5
   \   000040   02....       LJMP    ??zcl_SendWriteRsp_1 & 0xFFFF
    878            {
    879              // Load the buffer - serially
    880              pBuf = buf;
   \   000043   A8..         MOV     R0,?V0 + 6
   \   000045   A9..         MOV     R1,?V0 + 7
    881              for ( i = 0; i < writeRspCmd->numAttr; i++ )
   \   000047   75..00       MOV     ?V0 + 2,#0x0
   \   00004A   802F         SJMP    ??zcl_SendWriteRsp_2
    882              { 
    883                *pBuf++ = writeRspCmd->attrList[i].status;
   \                     ??zcl_SendWriteRsp_3:
   \   00004C   E5..         MOV     A,?V0 + 2
   \   00004E   75F003       MOV     B,#0x3
   \   000051   A4           MUL     AB
   \   000052   FA           MOV     R2,A
   \   000053   ABF0         MOV     R3,B
   \   000055   EE           MOV     A,R6
   \   000056   2A           ADD     A,R2
   \   000057   FA           MOV     R2,A
   \   000058   EF           MOV     A,R7
   \   000059   3B           ADDC    A,R3
   \   00005A   FB           MOV     R3,A
   \   00005B   8A82         MOV     DPL,R2
   \   00005D   8B83         MOV     DPH,R3
   \   00005F   A3           INC     DPTR
   \   000060   12....       LCALL   ?Subroutine64 & 0xFFFF
    884                *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
   \                     ??CrossCallReturnLabel_108:
   \   000063   EA           MOV     A,R2
   \   000064   2402         ADD     A,#0x2
   \   000066   FC           MOV     R4,A
   \   000067   EB           MOV     A,R3
   \   000068   3400         ADDC    A,#0x0
   \   00006A   FD           MOV     R5,A
   \   00006B   8C82         MOV     DPL,R4
   \   00006D   8D83         MOV     DPH,R5
   \   00006F   12....       LCALL   ??Subroutine146_0 & 0xFFFF
    885                *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
   \                     ??CrossCallReturnLabel_213:
   \   000072   8C82         MOV     DPL,R4
   \   000074   8D83         MOV     DPH,R5
   \   000076   12....       LCALL   ?Subroutine41 & 0xFFFF
    886              }
   \                     ??CrossCallReturnLabel_215:
   \   000079   05..         INC     ?V0 + 2
   \                     ??zcl_SendWriteRsp_2:
   \   00007B   8E82         MOV     DPL,R6
   \   00007D   8F83         MOV     DPH,R7
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   FA           MOV     R2,A
   \   000081   E5..         MOV     A,?V0 + 2
   \   000083   C3           CLR     C
   \   000084   9A           SUBB    A,R2
   \   000085   40C5         JC      ??zcl_SendWriteRsp_3
    887              
    888              // If there's only a single status record and its status field is set to 
    889              // SUCCESS then omit the attribute ID field.
    890              if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   000087   E0           MOVX    A,@DPTR
   \   000088   6401         XRL     A,#0x1
   \   00008A   7007         JNZ     ??zcl_SendWriteRsp_4
   \   00008C   A3           INC     DPTR
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   7003         JNZ     ??zcl_SendWriteRsp_4
    891                dataLen = 1;
   \   000090   75..01       MOV     ?V0 + 4,#0x1
    892                
    893              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
    894                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendWriteRsp_4:
   \   000093                ; Setup parameters for call to function zcl_SendCommand
   \   000093   78..         MOV     R0,#?V0 + 6
   \   000095   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000098   E5..         MOV     A,?V0 + 4
   \   00009A   F5..         MOV     ?V0 + 2,A
   \   00009C   78..         MOV     R0,#?V0 + 2
   \   00009E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A1   78..         MOV     R0,#?V0 + 1
   \   0000A3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A6   75..00       MOV     ?V0 + 2,#0x0
   \   0000A9   75..00       MOV     ?V0 + 3,#0x0
   \   0000AC   78..         MOV     R0,#?V0 + 2
   \   0000AE   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B1   E5..         MOV     A,?V0 + 5
   \   0000B3   F5..         MOV     ?V0 + 1,A
   \   0000B5   78..         MOV     R0,#?V0 + 1
   \   0000B7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BA   741D         MOV     A,#0x1d
   \   0000BC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BF   E0           MOVX    A,@DPTR
   \   0000C0   F5..         MOV     ?V0 + 1,A
   \   0000C2   78..         MOV     R0,#?V0 + 1
   \   0000C4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C7   75..00       MOV     ?V0 + 1,#0x0
   \   0000CA   78..         MOV     R0,#?V0 + 1
   \   0000CC   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000CF   75..04       MOV     ?V0 + 1,#0x4
   \   0000D2   78..         MOV     R0,#?V0 + 1
   \   0000D4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D7   740A         MOV     A,#0xa
   \   0000D9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DC   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   0000DF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E2   12....       LCALL   ??Subroutine162_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_273:
   \   0000E5   A9..         MOV     R1,?V0 + 0
   \   0000E7   12....       LCALL   ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_176:
   \   0000EA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000ED   E9           MOV     A,R1
   \   0000EE   FE           MOV     R6,A
    895              osal_mem_free( buf );
   \   0000EF                ; Setup parameters for call to function osal_mem_free
   \   0000EF   AA..         MOV     R2,?V0 + 6
   \   0000F1   AB..         MOV     R3,?V0 + 7
   \   0000F3   12....       LCALL   ??osal_mem_free?relay
   \   0000F6   8002         SJMP    ??zcl_SendWriteRsp_5
    896            }
    897            else
    898              status = ZMemError;
   \                     ??zcl_SendWriteRsp_1:
   \   0000F8   7E10         MOV     R6,#0x10
    899          
    900            return ( status );
   \                     ??zcl_SendWriteRsp_5:
   \   0000FA   02....       LJMP    ?Subroutine145 & 0xFFFF
    901          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine162_0:
   \   000000   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_290:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine166_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FF           MOV     R7,A
   \   000005   22           RET
    902          #endif // ZCL_WRITE
    903          
    904          #ifdef ZCL_REPORT
    905          /*********************************************************************
    906           * @fn      zcl_SendConfigReportCmd
    907           *
    908           * @brief   Send a Configure Reporting command
    909           *
    910           * @param   dstAddr - destination address
    911           * @param   clusterID - cluster ID
    912           * @param   cfgReportCmd - configure reporting command to be sent
    913           * @param   direction - direction of the command
    914           * @param   seqNum - transaction sequence number
    915           *
    916           * @return  ZSuccess if OK
    917           */
    918          ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
    919                                    uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
    920                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    921          {
    922            uint8 *buf;
    923            uint8 *pBuf;
    924            uint8 dataLen = 0;
    925            zclCfgReportRec_t *reportRec;
    926            uint8 reportChangeLen; // length of Reportable Change field
    927            uint8 i;
    928            ZStatus_t status;
    929            
    930            // Find out the data length
    931            for ( i = 0; i < cfgReportCmd->numAttr; i++ )
    932            {
    933              reportRec = &(cfgReportCmd->attrList[i]);
    934              
    935              dataLen += 1 + 2; // Direction + Attribute ID
    936              reportChangeLen = 0;
    937              
    938              if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
    939              {
    940                dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
    941                
    942                // Find out the size of the Reportable Change field (for Analog data types)
    943                if ( zclAnalogDataType( reportRec->dataType ) )
    944                {
    945                  reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
    946                  dataLen += reportChangeLen;
    947                }
    948              }
    949              else
    950              {
    951                dataLen += 2; // Timeout Period
    952              }
    953            }
    954            
    955            buf = osal_mem_alloc( dataLen );
    956            if ( buf != NULL )
    957            {
    958              // Load the buffer - serially
    959              pBuf = buf;
    960              for ( i = 0; i < cfgReportCmd->numAttr; i++ )
    961              {
    962                reportRec = &(cfgReportCmd->attrList[i]);
    963                
    964                *pBuf++ = reportRec->direction;
    965                *pBuf++ = LO_UINT16( reportRec->attrID );
    966                *pBuf++ = HI_UINT16( reportRec->attrID );
    967                
    968                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
    969                {
    970                  *pBuf++ = reportRec->dataType;
    971                  *pBuf++ = LO_UINT16( reportRec->minReportInt );
    972                  *pBuf++ = HI_UINT16( reportRec->minReportInt );
    973                  *pBuf++ = LO_UINT16( reportRec->maxReportInt );
    974                  *pBuf++ = HI_UINT16( reportRec->maxReportInt );
    975          
    976                  if ( zclAnalogDataType( reportRec->dataType ) )
    977                  {
    978                    zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
    979                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
    980                    pBuf += reportChangeLen;
    981                  }
    982                }
    983                else
    984                {
    985                  *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
    986                  *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
    987                } 
    988              } // for loop
    989              
    990              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE, 
    991                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
    992              osal_mem_free( buf );
    993            }
    994            else
    995              status = ZMemError;
    996            
    997            return ( status );
    998          }
    999          
   1000          /*********************************************************************
   1001           * @fn      zcl_SendConfigReportRspCmd
   1002           *
   1003           * @brief   Send a Configure Reporting Response command
   1004           *
   1005           * @param   dstAddr - destination address
   1006           * @param   clusterID - cluster ID
   1007           * @param   cfgReportRspCmd - configure reporting response command to be sent
   1008           * @param   direction - direction of the command
   1009           * @param   seqNum - transaction sequence number
   1010           *
   1011           * @return  ZSuccess if OK
   1012           */
   1013          ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1014                              uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
   1015                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1016          {
   1017            uint8 dataLen;
   1018            uint8 *buf;
   1019            uint8 *pBuf;
   1020            uint8 i;
   1021            ZStatus_t status;
   1022            
   1023            // Atrribute list (Status, Direction and Attribute ID)
   1024            dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 ); 
   1025            
   1026            buf = osal_mem_alloc( dataLen );
   1027            if ( buf != NULL )
   1028            {
   1029              // Load the buffer - serially
   1030              pBuf = buf; 
   1031              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   1032              {
   1033                *pBuf++ = cfgReportRspCmd->attrList[i].status;
   1034                *pBuf++ = cfgReportRspCmd->attrList[i].direction;
   1035                *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
   1036                *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
   1037              }
   1038              
   1039              // If there's only a single status record and its status field is set to 
   1040              // SUCCESS then omit the attribute ID field.
   1041              if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   1042                dataLen = 1;
   1043              
   1044              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1045                                        ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction, 
   1046                                        disableDefaultRsp, 0, seqNum, dataLen, buf );
   1047              osal_mem_free( buf );
   1048            }
   1049            else
   1050              status = ZMemError;
   1051            
   1052            return ( status );
   1053          }
   1054          
   1055          /*********************************************************************
   1056           * @fn      zcl_SendReadReportCfgCmd
   1057           *
   1058           * @brief   Send a Read Reporting Configuration command
   1059           *
   1060           * @param   dstAddr - destination address
   1061           * @param   clusterID - cluster ID
   1062           * @param   readReportCfgCmd - read reporting configuration command to be sent
   1063           * @param   direction - direction of the command
   1064           * @param   seqNum - transaction sequence number
   1065           *
   1066           * @return  ZSuccess if OK
   1067           */
   1068          ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1069                            uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
   1070                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1071          {
   1072            uint8 dataLen;
   1073            uint8 *buf;
   1074            uint8 *pBuf;
   1075            uint8 i;
   1076            ZStatus_t status;
   1077           
   1078            dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
   1079            
   1080            buf = osal_mem_alloc( dataLen );
   1081            if ( buf != NULL )
   1082            {
   1083              // Load the buffer - serially
   1084              pBuf = buf;
   1085              for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
   1086              {
   1087                *pBuf++ = readReportCfgCmd->attrList[i].direction;
   1088                *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
   1089                *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
   1090              }
   1091              
   1092              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE, 
   1093                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1094              osal_mem_free( buf );
   1095            }
   1096            else
   1097              status = ZMemError;
   1098            
   1099            return ( status );
   1100          }
   1101          
   1102          /*********************************************************************
   1103           * @fn      zcl_SendReadReportCfgRspCmd
   1104           *
   1105           * @brief   Send a Read Reporting Configuration Response command
   1106           *
   1107           * @param   dstAddr - destination address
   1108           * @param   clusterID - cluster ID
   1109           * @param   readReportCfgRspCmd - read reporting configuration response command to be sent
   1110           * @param   direction - direction of the command
   1111           * @param   seqNum - transaction sequence number
   1112           *
   1113           * @return  ZSuccess if OK
   1114           */
   1115          ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1116                       uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
   1117                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1118          {
   1119            uint8 *buf;
   1120            uint8 *pBuf;
   1121            uint8 dataLen = 0;
   1122            zclReportCfgRspRec_t *reportRspRec;
   1123            uint8 reportChangeLen;
   1124            uint8 i;
   1125            ZStatus_t status;
   1126          
   1127            // Find out the data length
   1128            for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   1129            {
   1130              reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1131              
   1132              dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
   1133              
   1134              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1135              {
   1136                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1137                {
   1138                  dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1139                
   1140                  if ( zclAnalogDataType( reportRspRec->dataType ) )
   1141                  {
   1142                    reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   1143                    dataLen += reportChangeLen; // Reportable Change field
   1144                  }
   1145                }
   1146                else
   1147                {
   1148                  dataLen += 2; // Timeout Period
   1149                }
   1150              }
   1151            }
   1152            
   1153            buf = osal_mem_alloc( dataLen );
   1154            if ( buf != NULL )
   1155            {
   1156              // Load the buffer - serially
   1157              pBuf = buf;
   1158          
   1159              for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   1160              {
   1161                reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1162          
   1163                *pBuf++ = reportRspRec->status;
   1164                *pBuf++ = reportRspRec->direction;
   1165                *pBuf++ = LO_UINT16( reportRspRec->attrID );
   1166                *pBuf++ = HI_UINT16( reportRspRec->attrID );
   1167               
   1168                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1169                {
   1170                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1171                  {
   1172                    *pBuf++ = reportRspRec->dataType;
   1173                    *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
   1174                    *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
   1175                    *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
   1176                    *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
   1177          
   1178                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   1179                    {
   1180                      zclSerializeData( reportRspRec->dataType, 
   1181                                        reportRspRec->reportableChange, pBuf );
   1182                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   1183                      pBuf += reportChangeLen;
   1184                    }
   1185                  }
   1186                  else
   1187                  {
   1188                    *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
   1189                    *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
   1190                  }
   1191                }
   1192              }
   1193             
   1194              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1195                                        ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
   1196                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1197              osal_mem_free( buf );
   1198            }
   1199            else
   1200              status = ZMemError;
   1201            
   1202            return ( status );
   1203          }
   1204          
   1205          /*********************************************************************
   1206           * @fn      zcl_SendReportCmd
   1207           *
   1208           * @brief   Send a Report command
   1209           *
   1210           * @param   dstAddr - destination address
   1211           * @param   clusterID - cluster ID
   1212           * @param   reportCmd - report command to be sent
   1213           * @param   direction - direction of the command
   1214           * @param   seqNum - transaction sequence number
   1215           *
   1216           * @return  ZSuccess if OK
   1217           */
   1218          ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1219                                       uint16 clusterID, zclReportCmd_t *reportCmd,
   1220                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1221          {
   1222            zclReport_t *reportRec;
   1223            uint8 attrDataLen;
   1224            uint8 dataLen = 0;
   1225            uint8 *buf;
   1226            uint8 *pBuf;
   1227            uint8 i;
   1228            ZStatus_t status;
   1229            
   1230            // calculate the size of the command
   1231            for ( i = 0; i < reportCmd->numAttr; i++ )
   1232            {
   1233              reportRec = &(reportCmd->attrList[i]);
   1234              
   1235              dataLen += 2 + 1; // Attribute ID + data type
   1236          
   1237              attrDataLen = zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   1238              dataLen += attrDataLen; // Attribute Data
   1239            }
   1240            
   1241            buf = osal_mem_alloc( dataLen );
   1242            if ( buf != NULL )
   1243            {
   1244              // Load the buffer - serially
   1245              pBuf = buf;
   1246              for ( i = 0; i < reportCmd->numAttr; i++ )
   1247              {
   1248                reportRec = &(reportCmd->attrList[i]);
   1249                
   1250                *pBuf++ = LO_UINT16( reportRec->attrID );
   1251                *pBuf++ = HI_UINT16( reportRec->attrID );
   1252                *pBuf++ = reportRec->dataType;
   1253          
   1254                zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
   1255                attrDataLen = zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   1256                pBuf += attrDataLen; // move pass attribute data
   1257              }
   1258           
   1259              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE, 
   1260                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1261              osal_mem_free( buf );
   1262            }
   1263            else
   1264              status = ZMemError;
   1265            
   1266            return ( status );
   1267          }
   1268          #endif // ZCL_REPORT
   1269                 
   1270          /*********************************************************************
   1271           * @fn      zcl_SendDefaultRspCmd
   1272           *
   1273           * @brief   Send a Default Response command
   1274           *
   1275           * @param   dstAddr - destination address
   1276           * @param   clusterID - cluster ID
   1277           * @param   defaultRspCmd - default response command to be sent
   1278           * @param   direction - direction of the command
   1279           * @param   seqNum - transaction sequence number
   1280           *
   1281           * @return  ZSuccess if OK
   1282           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1283          ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendDefaultRspCmd:
   1284                                      uint16 clusterID, zclDefaultRspCmd_t *defaultRspCmd,
   1285                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1286          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   740E         MOV     A,#0xe
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   000014   7410         MOV     A,#0x10
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   FF           MOV     R7,A
   \   00001B   7411         MOV     A,#0x11
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F5..         MOV     ?V0 + 2,A
   \   000023   7412         MOV     A,#0x12
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F5..         MOV     ?V0 + 3,A
   1287            uint8 buf[2]; // Command ID and Status;
   1288          
   1289            // Load the buffer - serially
   1290            buf[0] = defaultRspCmd->commandID;
   \   00002B   8882         MOV     DPL,R0
   \   00002D   8983         MOV     DPH,R1
   \   00002F   12....       LCALL   ?Subroutine113 & 0xFFFF
   1291            buf[1] = defaultRspCmd->statusCode;
   \                     ??CrossCallReturnLabel_170:
   \   000032   8882         MOV     DPL,R0
   \   000034   8983         MOV     DPH,R1
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   C0E0         PUSH    A
   \   00003A   7401         MOV     A,#0x1
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   D0E0         POP     A
   \   000041   12....       LCALL   ??Subroutine150_0 & 0xFFFF
   1292          
   1293            return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
   1294                                      direction, disableDefaultRsp, 0, seqNum, 2, buf ) ); 
   \                     ??CrossCallReturnLabel_227:
   \   000044   8582..       MOV     ?V0 + 0,DPL
   \   000047   8583..       MOV     ?V0 + 1,DPH
   \   00004A   78..         MOV     R0,#?V0 + 0
   \   00004C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004F   75..02       MOV     ?V0 + 0,#0x2
   \   000052   78..         MOV     R0,#?V0 + 0
   \   000054   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000057   E5..         MOV     A,?V0 + 3
   \   000059   F5..         MOV     ?V0 + 0,A
   \   00005B   78..         MOV     R0,#?V0 + 0
   \   00005D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000060   75..00       MOV     ?V0 + 0,#0x0
   \   000063   75..00       MOV     ?V0 + 1,#0x0
   \   000066   78..         MOV     R0,#?V0 + 0
   \   000068   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006B   E5..         MOV     A,?V0 + 2
   \   00006D   F5..         MOV     ?V0 + 0,A
   \   00006F   78..         MOV     R0,#?V0 + 0
   \   000071   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000074   EF           MOV     A,R7
   \   000075   F5..         MOV     ?V0 + 0,A
   \   000077   78..         MOV     R0,#?V0 + 0
   \   000079   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00007C   75..00       MOV     ?V0 + 0,#0x0
   \   00007F   78..         MOV     R0,#?V0 + 0
   \   000081   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000084   75..0B       MOV     ?V0 + 0,#0xb
   \   000087   78..         MOV     R0,#?V0 + 0
   \   000089   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00008C   EE           MOV     A,R6
   \   00008D   F9           MOV     R1,A
   \   00008E   12....       LCALL   ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_177:
   \   000091   12....       LCALL   ?DEALLOC_XSTACK8
   \   000094   7402         MOV     A,#0x2
   \   000096   12....       LCALL   ?DEALLOC_XSTACK8
   \   000099                REQUIRE ?Subroutine132
   \   000099                ; // Fall through to label ?Subroutine132
   1295          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine113:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   F0           MOVX    @DPTR,A
   \   000008   22           RET
   1296          
   1297          #ifdef ZCL_DISCOVER
   1298          /*********************************************************************
   1299           * @fn      zcl_SendDiscoverCmd
   1300           *
   1301           * @brief   Send a Discover command
   1302           *
   1303           * @param   dstAddr - destination address
   1304           * @param   clusterID - cluster ID
   1305           * @param   discoverCmd - discover command to be sent
   1306           * @param   direction - direction of the command
   1307           * @param   seqNum - transaction sequence number
   1308           *
   1309           * @return  ZSuccess if OK
   1310           */
   1311          ZStatus_t zcl_SendDiscoverCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1312                                      uint16 clusterID, zclDiscoverCmd_t *discoverCmd,
   1313                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1314          {
   1315            uint8 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
   1316            uint8 *buf;
   1317            uint8 *pBuf;
   1318            ZStatus_t status;
   1319            
   1320            buf = osal_mem_alloc( dataLen );
   1321            if ( buf != NULL )
   1322            {
   1323              // Load the buffer - serially
   1324              pBuf = buf;
   1325              *pBuf++ = LO_UINT16(discoverCmd->startAttr);
   1326              *pBuf++ = HI_UINT16(discoverCmd->startAttr);
   1327              *pBuf++ = discoverCmd->maxAttrIDs;
   1328              
   1329              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER, FALSE, 
   1330                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1331              osal_mem_free( buf );
   1332            }
   1333            else
   1334              status = ZMemError;
   1335            
   1336            return ( status );
   1337          }
   1338          
   1339          /*********************************************************************
   1340           * @fn      zcl_SendDiscoverRspCmd
   1341           *
   1342           * @brief   Send a Discover Response command
   1343           *
   1344           * @param   dstAddr - destination address
   1345           * @param   clusterID - cluster ID
   1346           * @param   reportRspCmd - report response command to be sent
   1347           * @param   direction - direction of the command
   1348           * @param   seqNum - transaction sequence number
   1349           *
   1350           * @return  ZSuccess if OK
   1351           */
   1352          ZStatus_t zcl_SendDiscoverRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1353                                uint16 clusterID, zclDiscoverRspCmd_t *discoverRspCmd,
   1354                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1355          {
   1356            uint8 dataLen = 1; // Discovery complete
   1357            uint8 *buf;
   1358            uint8 *pBuf;
   1359            uint8 i;
   1360            ZStatus_t status;
   1361            
   1362            // calculate the size of the command
   1363            dataLen += discoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
   1364            
   1365            buf = osal_mem_alloc( dataLen );
   1366            if ( buf != NULL )
   1367            {
   1368              // Load the buffer - serially
   1369              pBuf = buf;
   1370              *pBuf++ = discoverRspCmd->discComplete;    
   1371              for ( i = 0; i < discoverRspCmd->numAttr; i++ )
   1372              {
   1373                *pBuf++ = LO_UINT16(discoverRspCmd->attrList[i].attrID);
   1374                *pBuf++ = HI_UINT16(discoverRspCmd->attrList[i].attrID);
   1375                *pBuf++ = discoverRspCmd->attrList[i].dataType;
   1376              }
   1377              
   1378              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_RSP, FALSE,
   1379                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1380              osal_mem_free( buf );
   1381            }
   1382            else
   1383              status = ZMemError;
   1384            
   1385            return ( status );
   1386          }
   1387          #endif // ZCL_DISCOVER
   1388          
   1389          /*********************************************************************
   1390           * PRIVATE FUNCTIONS
   1391           *********************************************************************/
   1392          
   1393          /*********************************************************************
   1394           * @fn      zclProcessMessageMSG
   1395           *
   1396           * @brief   Data message processor callback.  This function processes
   1397           *          any incoming data - probably from other devices.  So, based
   1398           *          on cluster ID, perform the intended action.
   1399           *
   1400           * @param   pkt - incoming message
   1401           *
   1402           * @return  none
   1403           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1404          static void zclProcessMessageMSG( afIncomingMSGPacket_t *pkt )
   \                     zclProcessMessageMSG:
   1405          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 19
   \   000005   74ED         MOV     A,#-0x13
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1406            endPointDesc_t *epDesc;
   1407            zclIncoming_t inMsg;
   1408            zclLibPlugin_t *pInPlugin;
   1409            zclDefaultRspCmd_t defautlRspCmd;
   1410            uint8 options;
   1411            uint8 securityEnable;
   1412            uint8 interPanMsg;
   1413            ZStatus_t status = ZFailure;
   1414          
   1415            if ( pkt->cmd.DataLength == 0 )
   \   00000E   EE           MOV     A,R6
   \   00000F   241F         ADD     A,#0x1f
   \   000011   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_140:
   \   000014   7002         JNZ     ??zclProcessMessageMSG_0
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \                     ??zclProcessMessageMSG_0:
   \   000018   7003         JNZ     $+5
   \   00001A   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1416              return;   // Error, ignore the message
   1417          
   1418            // Initialize
   1419            inMsg.msg = pkt;
   \   00001D   7402         MOV     A,#0x2
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   EE           MOV     A,R6
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   EF           MOV     A,R7
   \   000026   F0           MOVX    @DPTR,A
   1420            inMsg.attrCmd = NULL;
   \   000027   740D         MOV     A,#0xd
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   E4           CLR     A
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   A3           INC     DPTR
   \   00002F   F0           MOVX    @DPTR,A
   1421            inMsg.pData = NULL;
   \   000030   740A         MOV     A,#0xa
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   E4           CLR     A
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   F0           MOVX    @DPTR,A
   1422            inMsg.pDataLen = 0;
   \   000039   740C         MOV     A,#0xc
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   E4           CLR     A
   \   00003F   F0           MOVX    @DPTR,A
   1423          
   1424            inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
   \   000040   EE           MOV     A,R6
   \   000041   2421         ADD     A,#0x21
   \   000043   F5..         MOV     ?V0 + 0,A
   \   000045   EF           MOV     A,R7
   \   000046   12....       LCALL   ?Subroutine117 & 0xFFFF
   \                     ??CrossCallReturnLabel_178:
   \   000049   12....       LCALL   ??Subroutine174_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_365:
   \   00004C   7404         MOV     A,#0x4
   \   00004E   12....       LCALL   ?XSTACK_DISP0_8
   \   000051   AA82         MOV     R2,DPL
   \   000053   AB83         MOV     R3,DPH
   \   000055   12....       LCALL   ??zclParseHdr?relay
   \   000058   740A         MOV     A,#0xa
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   12....       LCALL   ?Subroutine16 & 0xFFFF
   1425            inMsg.pDataLen = pkt->cmd.DataLength;
   1426            inMsg.pDataLen -= (uint8)(inMsg.pData - pkt->cmd.Data);
   \                     ??CrossCallReturnLabel_30:
   \   000060   85..82       MOV     DPL,?V0 + 0
   \   000063   85..83       MOV     DPH,?V0 + 1
   \   000066   E0           MOVX    A,@DPTR
   \   000067   F8           MOV     R0,A
   \   000068   740A         MOV     A,#0xa
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   FA           MOV     R2,A
   \   00006F   85..82       MOV     DPL,?V0 + 2
   \   000072   85..83       MOV     DPH,?V0 + 3
   \   000075   E0           MOVX    A,@DPTR
   \   000076   C3           CLR     C
   \   000077   9A           SUBB    A,R2
   \   000078   28           ADD     A,R0
   \   000079   C0E0         PUSH    A
   \   00007B   740C         MOV     A,#0xc
   \   00007D   12....       LCALL   ?XSTACK_DISP0_8
   \   000080   D0E0         POP     A
   \   000082   F0           MOVX    @DPTR,A
   1427          
   1428            // Find the wanted endpoint
   1429            epDesc = afFindEndPointDesc( pkt->endPoint );
   \   000083   EE           MOV     A,R6
   \   000084   2414         ADD     A,#0x14
   \   000086   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_141:
   \   000089   F9           MOV     R1,A
   \   00008A   12....       LCALL   ??afFindEndPointDesc?relay
   \   00008D   8A..         MOV     ?V0 + 0,R2
   \   00008F   8B..         MOV     ?V0 + 1,R3
   \   000091   A8..         MOV     R0,?V0 + 0
   \   000093   A9..         MOV     R1,?V0 + 1
   1430            if ( epDesc == NULL )
   \   000095   E8           MOV     A,R0
   \   000096   7001         JNZ     ??zclProcessMessageMSG_2
   \   000098   E9           MOV     A,R1
   \                     ??zclProcessMessageMSG_2:
   \   000099   7003         JNZ     $+5
   \   00009B   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1431              return;   // Error, ignore the message
   1432          
   1433            if ( pkt->clusterId == ZCL_INVALID_CLUSTER_ID )
   \   00009E   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_146:
   \   0000A1   85..82       MOV     DPL,?V0 + 4
   \   0000A4   F583         MOV     DPH,A
   \   0000A6   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   0000A9   7003         JNZ     ??zclProcessMessageMSG_3
   \   0000AB   74FF         MOV     A,#-0x1
   \   0000AD   6B           XRL     A,R3
   \                     ??zclProcessMessageMSG_3:
   \   0000AE   7003         JNZ     $+5
   \   0000B0   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1434              return;   // Error, ignore the message
   1435            
   1436            if ( zcl_DeviceOperational( pkt->endPoint, pkt->clusterId, 
   1437                                        inMsg.hdr.fc.type, inMsg.hdr.commandID, epDesc->simpleDesc->AppProfId ) == FALSE )
   \   0000B3                ; Setup parameters for call to function zcl_DeviceOperational
   \   0000B3   8882         MOV     DPL,R0
   \   0000B5   8983         MOV     DPH,R1
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   A3           INC     DPTR
   \   0000BA   12....       LCALL   ??Subroutine163_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_292:
   \   0000BD   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000C0   740B         MOV     A,#0xb
   \   0000C2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C5   E0           MOVX    A,@DPTR
   \   0000C6   FD           MOV     R5,A
   \   0000C7   7406         MOV     A,#0x6
   \   0000C9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CC   E0           MOVX    A,@DPTR
   \   0000CD   5403         ANL     A,#0x3
   \   0000CF   FC           MOV     R4,A
   \   0000D0   85..82       MOV     DPL,?V0 + 2
   \   0000D3   85..83       MOV     DPH,?V0 + 3
   \   0000D6   E0           MOVX    A,@DPTR
   \   0000D7   F9           MOV     R1,A
   \   0000D8   12....       LCALL   ??zcl_DeviceOperational?relay
   \   0000DB   7402         MOV     A,#0x2
   \   0000DD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E0   E9           MOV     A,R1
   \   0000E1   7003         JNZ     $+5
   \   0000E3   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1438            {
   1439              return; // Error, ignore the message
   1440            }
   1441          
   1442          #if defined ( INTER_PAN )
   1443            if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
   1444            {
   1445              // No foundation command is supported thru Inter-PAN communication
   1446              if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   1447                return;
   1448          
   1449              interPanMsg = TRUE; 
   1450              options = AF_TX_OPTIONS_NONE;
   1451            }
   1452            else
   1453          #endif
   1454            {
   1455              interPanMsg = FALSE;
   1456              options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
   \   0000E6                ; Setup parameters for call to function zclGetClusterOption
   \   0000E6   85..82       MOV     DPL,?V0 + 4
   \   0000E9   85..83       MOV     DPH,?V0 + 5
   \   0000EC   12....       LCALL   ??Subroutine162_0 & 0xFFFF
   1457            }
   \                     ??CrossCallReturnLabel_274:
   \   0000EF   85..82       MOV     DPL,?V0 + 2
   \   0000F2   85..83       MOV     DPH,?V0 + 3
   \   0000F5   E0           MOVX    A,@DPTR
   \   0000F6   F9           MOV     R1,A
   \   0000F7   12....       LCALL   ??zclGetClusterOption?relay
   \   0000FA   E9           MOV     A,R1
   \   0000FB   FA           MOV     R2,A
   1458            
   1459            // Local and remote Security options must match except for Default Response command
   1460            if ( !zcl_DefaultRspCmd( inMsg.hdr ) )
   \   0000FC   7404         MOV     A,#0x4
   \   0000FE   12....       LCALL   ?XSTACK_DISP0_8
   \   000101   E0           MOVX    A,@DPTR
   \   000102   F8           MOV     R0,A
   \   000103   5407         ANL     A,#0x7
   \   000105   700D         JNZ     ??zclProcessMessageMSG_4
   \   000107   7409         MOV     A,#0x9
   \   000109   12....       LCALL   ?XSTACK_DISP0_8
   \   00010C   E0           MOVX    A,@DPTR
   \   00010D   640B         XRL     A,#0xb
   \   00010F   7003         JNZ     $+5
   \   000111   02....       LJMP    ??zclProcessMessageMSG_5 & 0xFFFF
   1461            {
   1462              securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
   \                     ??zclProcessMessageMSG_4:
   \   000114   EA           MOV     A,R2
   \   000115   A2E6         MOV     C,0xE0 /* A   */.6
   \   000117   5004         JNC     ??zclProcessMessageMSG_6
   \   000119   D2F0         SETB    B.0
   \   00011B   8002         SJMP    ??zclProcessMessageMSG_7
   \                     ??zclProcessMessageMSG_6:
   \   00011D   C2F0         CLR     B.0
   \                     ??zclProcessMessageMSG_7:
   \   00011F   A2F0         MOV     C,B.0
   \   000121   E4           CLR     A
   \   000122   92E0         MOV     0xE0 /* A   */.0,C
   \   000124   F5..         MOV     ?V0 + 0,A
   1463              if ( pkt->SecurityUse != securityEnable )
   \   000126   EE           MOV     A,R6
   \   000127   2419         ADD     A,#0x19
   \   000129   F582         MOV     DPL,A
   \   00012B   EF           MOV     A,R7
   \   00012C   3400         ADDC    A,#0x0
   \   00012E   F583         MOV     DPH,A
   \   000130   E0           MOVX    A,@DPTR
   \   000131   65..         XRL     A,?V0 + 0
   \   000133   7003         JNZ     $+5
   \   000135   02....       LJMP    ??zclProcessMessageMSG_5 & 0xFFFF
   1464              {
   1465                if ( UNICAST_MSG( inMsg.msg ) )
   \   000138   7402         MOV     A,#0x2
   \   00013A   12....       LCALL   ?XSTACK_DISP0_8
   \   00013D   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   000140   6003         JZ      $+5
   \   000142   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   000145   7402         MOV     A,#0x2
   \   000147   12....       LCALL   ?XSTACK_DISP0_8
   \   00014A   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   00014D   7002         JNZ     ??zclProcessMessageMSG_8
   \   00014F   A3           INC     DPTR
   \   000150   E0           MOVX    A,@DPTR
   \                     ??zclProcessMessageMSG_8:
   \   000151   6003         JZ      $+5
   \   000153   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1466                {
   1467                  // Send a Default Response command back with no Application Link Key security
   1468                  if ( securityEnable )
   \   000156   E5..         MOV     A,?V0 + 0
   \   000158   6005         JZ      ??CrossCallReturnLabel_64
   1469                    zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
   \   00015A                ; Setup parameters for call to function zclSetSecurityOption
   \   00015A   7C00         MOV     R4,#0x0
   \   00015C   12....       LCALL   ?Subroutine40 & 0xFFFF
   1470                  
   1471                  defautlRspCmd.statusCode = status;
   \                     ??CrossCallReturnLabel_64:
   \   00015F   7401         MOV     A,#0x1
   \   000161   12....       LCALL   ?XSTACK_DISP0_8
   \   000164   7401         MOV     A,#0x1
   \   000166   F0           MOVX    @DPTR,A
   1472                  defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   000167   7409         MOV     A,#0x9
   \   000169   12....       LCALL   ?XSTACK_DISP0_8
   \   00016C   12....       LCALL   ?Subroutine69 & 0xFFFF
   1473                  zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1474                                         inMsg.msg->clusterId, &defautlRspCmd, 
   1475                                         ZCL_FRAME_SERVER_CLIENT_DIR, true, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_113:
   \   00016F   12....       LCALL   ?XSTACK_DISP0_8
   \   000172   E0           MOVX    A,@DPTR
   \   000173   F5..         MOV     ?V0 + 1,A
   \   000175   78..         MOV     R0,#?V0 + 1
   \   000177   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00017A   75..01       MOV     ?V0 + 1,#0x1
   \   00017D   78..         MOV     R0,#?V0 + 1
   \   00017F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000182   78..         MOV     R0,#?V0 + 1
   \   000184   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000187   7403         MOV     A,#0x3
   \   000189   12....       LCALL   ?XSTACK_DISP0_8
   \   00018C   8582..       MOV     ?V0 + 6,DPL
   \   00018F   8583..       MOV     ?V0 + 7,DPH
   \   000192   78..         MOV     R0,#?V0 + 6
   \   000194   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000197   7407         MOV     A,#0x7
   \   000199   12....       LCALL   ?XSTACK_DISP0_8
   \   00019C   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   00019F   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A2   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   0001A5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A8   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   0001AB   12....       LCALL   ?DEALLOC_XSTACK8
   1476                  if ( securityEnable )
   \   0001AE   E5..         MOV     A,?V0 + 0
   \   0001B0   7003         JNZ     $+5
   \   0001B2   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1477                    zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );       
   \   0001B5                ; Setup parameters for call to function zclSetSecurityOption
   \   0001B5   7C01         MOV     R4,#0x1
   \   0001B7   12....       LCALL   ?Subroutine40 & 0xFFFF
   1478                }
   1479                
   1480                return;   // Error, ignore the message
   1481              }
   1482            }
   \                     ??CrossCallReturnLabel_65:
   \   0001BA   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1483            
   1484            // Is this a foundation type message
   1485            if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \                     ??zclProcessMessageMSG_5:
   \   0001BD   E8           MOV     A,R0
   \   0001BE   5403         ANL     A,#0x3
   \   0001C0   6003         JZ      $+5
   \   0001C2   02....       LJMP    ??zclProcessMessageMSG_9 & 0xFFFF
   1486            { 
   1487              if ( inMsg.hdr.fc.manuSpecific )
   \   0001C5   E8           MOV     A,R0
   \   0001C6   5404         ANL     A,#0x4
   \   0001C8   6005         JZ      ??zclProcessMessageMSG_10
   1488              {
   1489                // We don't support any manufacturer specific command
   1490                status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
   \   0001CA   7A84         MOV     R2,#-0x7c
   \   0001CC   02....       LJMP    ??zclProcessMessageMSG_11 & 0xFFFF
   1491              }
   1492              else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) && 
   1493                        ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
   \                     ??zclProcessMessageMSG_10:
   \   0001CF   7409         MOV     A,#0x9
   \   0001D1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D4   E0           MOVX    A,@DPTR
   \   0001D5   F5..         MOV     ?V0 + 0,A
   \   0001D7   C3           CLR     C
   \   0001D8   940E         SUBB    A,#0xe
   \   0001DA   4003         JC      $+5
   \   0001DC   02....       LJMP    ??zclProcessMessageMSG_12 & 0xFFFF
   \   0001DF   75..00       MOV     ?V0 + 1,#0x0
   \   0001E2   7402         MOV     A,#0x2
   \   0001E4   78..         MOV     R0,#?V0 + 0
   \   0001E6   12....       LCALL   ?S_SHL
   \   0001E9   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   0001EC   F8           MOV     R0,A
   \   0001ED   7401         MOV     A,#0x1
   \   0001EF   93           MOVC    A,@A+DPTR
   \   0001F0   F9           MOV     R1,A
   \   0001F1   E8           MOV     A,R0
   \   0001F2   7001         JNZ     ??zclProcessMessageMSG_13
   \   0001F4   E9           MOV     A,R1
   \                     ??zclProcessMessageMSG_13:
   \   0001F5   7003         JNZ     $+5
   \   0001F7   02....       LJMP    ??zclProcessMessageMSG_12 & 0xFFFF
   1494              {
   1495                zclParseCmd_t parseCmd;
   1496                
   1497                parseCmd.endpoint = pkt->endPoint;
   \   0001FA   85..82       MOV     DPL,?V0 + 2
   \   0001FD   85..83       MOV     DPH,?V0 + 3
   \   000200   E0           MOVX    A,@DPTR
   \   000201   C0E0         PUSH    A
   \   000203   740F         MOV     A,#0xf
   \   000205   12....       LCALL   ?XSTACK_DISP0_8
   \   000208   D0E0         POP     A
   \   00020A   F0           MOVX    @DPTR,A
   1498                parseCmd.dataLen = inMsg.pDataLen;
   \   00020B   740C         MOV     A,#0xc
   \   00020D   12....       LCALL   ?XSTACK_DISP0_8
   \   000210   E0           MOVX    A,@DPTR
   \   000211   C0E0         PUSH    A
   \   000213   7410         MOV     A,#0x10
   \   000215   12....       LCALL   ?XSTACK_DISP0_8
   \   000218   D0E0         POP     A
   \   00021A   F0           MOVX    @DPTR,A
   1499                parseCmd.pData = inMsg.pData;
   \   00021B   740A         MOV     A,#0xa
   \   00021D   12....       LCALL   ?XSTACK_DISP0_8
   \   000220   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   000223   7411         MOV     A,#0x11
   \   000225   12....       LCALL   ?XSTACK_DISP0_8
   \   000228   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   1500                
   1501                // Parse the command, remember that the return value is a pointer to allocated memory
   1502                inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
   \                     ??CrossCallReturnLabel_339:
   \   00022B                ; Setup parameters for indirect call
   \   00022B   740F         MOV     A,#0xf
   \   00022D   12....       LCALL   ?XSTACK_DISP0_8
   \   000230   AA82         MOV     R2,DPL
   \   000232   AB83         MOV     R3,DPH
   \   000234   7409         MOV     A,#0x9
   \   000236   12....       LCALL   ?XSTACK_DISP0_8
   \   000239   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   00023C   12....       LCALL   ?S_SHL
   \   00023F   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_145:
   \   000242   C0E0         PUSH    A
   \   000244   7401         MOV     A,#0x1
   \   000246   93           MOVC    A,@A+DPTR
   \   000247   F583         MOV     DPH,A
   \   000249   D082         POP     DPL
   \   00024B   12....       LCALL   ?CALL_IND
   \   00024E   740D         MOV     A,#0xd
   \   000250   12....       LCALL   ?XSTACK_DISP0_8
   \   000253   12....       LCALL   ?Subroutine16 & 0xFFFF
   1503                if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
   \                     ??CrossCallReturnLabel_31:
   \   000256   740D         MOV     A,#0xd
   \   000258   12....       LCALL   ?XSTACK_DISP0_8
   \   00025B   E0           MOVX    A,@DPTR
   \   00025C   7002         JNZ     ??zclProcessMessageMSG_14
   \   00025E   A3           INC     DPTR
   \   00025F   E0           MOVX    A,@DPTR
   \                     ??zclProcessMessageMSG_14:
   \   000260   6048         JZ      ??CrossCallReturnLabel_128
   \   000262   7409         MOV     A,#0x9
   \   000264   12....       LCALL   ?XSTACK_DISP0_8
   \   000267   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   00026A   12....       LCALL   ?S_SHL
   \   00026D   E5..         MOV     A,?V0 + 0
   \   00026F   24..         ADD     A,#((zclCmdTable + 2) & 0xff)
   \   000271   F582         MOV     DPL,A
   \   000273   E5..         MOV     A,?V0 + 1
   \   000275   34..         ADDC    A,#(((zclCmdTable + 2) >> 8) & 0xff)
   \   000277   F583         MOV     DPH,A
   \   000279   E4           CLR     A
   \   00027A   93           MOVC    A,@A+DPTR
   \   00027B   F8           MOV     R0,A
   \   00027C   7401         MOV     A,#0x1
   \   00027E   93           MOVC    A,@A+DPTR
   \   00027F   F9           MOV     R1,A
   \   000280   E8           MOV     A,R0
   \   000281   7001         JNZ     ??zclProcessMessageMSG_15
   \   000283   E9           MOV     A,R1
   \                     ??zclProcessMessageMSG_15:
   \   000284   601C         JZ      ??zclProcessMessageMSG_16
   1504                { 
   1505                  // Process the command
   1506                  if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
   \   000286                ; Setup parameters for indirect call
   \   000286   7402         MOV     A,#0x2
   \   000288   12....       LCALL   ?XSTACK_DISP0_8
   \   00028B   AA82         MOV     R2,DPL
   \   00028D   AB83         MOV     R3,DPH
   \   00028F   8882         MOV     DPL,R0
   \   000291   8983         MOV     DPH,R1
   \   000293   12....       LCALL   ?CALL_IND
   1507                  {
   1508                    // Couldn't find attribute in the table.
   1509                  }
   1510                }
   1511                 
   1512                // Free the buffer
   1513                if ( inMsg.attrCmd )
   \   000296   740D         MOV     A,#0xd
   \   000298   12....       LCALL   ?XSTACK_DISP0_8
   \   00029B   E0           MOVX    A,@DPTR
   \   00029C   7002         JNZ     ??zclProcessMessageMSG_17
   \   00029E   A3           INC     DPTR
   \   00029F   E0           MOVX    A,@DPTR
   \                     ??zclProcessMessageMSG_17:
   \   0002A0   6008         JZ      ??CrossCallReturnLabel_128
   1514                  osal_mem_free( inMsg.attrCmd );
   \                     ??zclProcessMessageMSG_16:
   \   0002A2                ; Setup parameters for call to function osal_mem_free
   \   0002A2   740D         MOV     A,#0xd
   \   0002A4   12....       LCALL   ?XSTACK_DISP0_8
   \   0002A7   12....       LCALL   ?Subroutine74 & 0xFFFF
   1515                
   1516                if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
   \                     ??CrossCallReturnLabel_128:
   \   0002AA   7409         MOV     A,#0x9
   \   0002AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0002AF   E0           MOVX    A,@DPTR
   \   0002B0   FA           MOV     R2,A
   \   0002B1   7003         JNZ     $+5
   \   0002B3   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   0002B6   7402         MOV     A,#0x2
   \   0002B8   6A           XRL     A,R2
   \   0002B9   7003         JNZ     $+5
   \   0002BB   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   0002BE   7403         MOV     A,#0x3
   \   0002C0   6A           XRL     A,R2
   \   0002C1   7003         JNZ     $+5
   \   0002C3   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   0002C6   7406         MOV     A,#0x6
   \   0002C8   6A           XRL     A,R2
   \   0002C9   7003         JNZ     $+5
   \   0002CB   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   0002CE   7408         MOV     A,#0x8
   \   0002D0   6A           XRL     A,R2
   \   0002D1   7003         JNZ     $+5
   \   0002D3   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   0002D6   740C         MOV     A,#0xc
   \   0002D8   6A           XRL     A,R2
   \   0002D9   7003         JNZ     $+5
   \   0002DB   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   0002DE   740B         MOV     A,#0xb
   \   0002E0   6A           XRL     A,R2
   \   0002E1   7003         JNZ     $+5
   \   0002E3   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1517                  return; // We're done
   1518                
   1519                status = ZSuccess;
   \   0002E6   7A00         MOV     R2,#0x0
   \   0002E8   02....       LJMP    ??zclProcessMessageMSG_11 & 0xFFFF
   1520              }
   1521              else
   1522              {
   1523                // Unsupported message
   1524                status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
   \                     ??zclProcessMessageMSG_12:
   \   0002EB   7A82         MOV     R2,#-0x7e
   \   0002ED   02....       LJMP    ??zclProcessMessageMSG_11 & 0xFFFF
   1525              }
   1526            }
   1527            else
   1528            {
   1529              // Nope, must be specific to the cluster ID
   1530          
   1531              // Find the appropriate plugin
   1532              pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
   \                     ??zclProcessMessageMSG_9:
   \   0002F0   85..82       MOV     DPL,?V0 + 4
   \   0002F3   85..83       MOV     DPH,?V0 + 5
   \   0002F6   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   0002F9   7003         JNZ     ??zclProcessMessageMSG_18
   \   0002FB   74FF         MOV     A,#-0x1
   \   0002FD   6B           XRL     A,R3
   \                     ??zclProcessMessageMSG_18:
   \   0002FE   6037         JZ      ??zclProcessMessageMSG_19
   \   000300   90....       MOV     DPTR,#plugins
   \   000303   8004         SJMP    ??zclProcessMessageMSG_20
   \                     ??zclProcessMessageMSG_21:
   \   000305   8882         MOV     DPL,R0
   \   000307   8983         MOV     DPH,R1
   \                     ??zclProcessMessageMSG_20:
   \   000309   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   00030C   7001         JNZ     ??zclProcessMessageMSG_22
   \   00030E   E9           MOV     A,R1
   \                     ??zclProcessMessageMSG_22:
   \   00030F   6026         JZ      ??zclProcessMessageMSG_19
   \   000311   8882         MOV     DPL,R0
   \   000313   8983         MOV     DPH,R1
   \   000315   A3           INC     DPTR
   \   000316   A3           INC     DPTR
   \   000317   12....       LCALL   ??Subroutine174_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_366:
   \   00031A   C3           CLR     C
   \   00031B   EA           MOV     A,R2
   \   00031C   9C           SUBB    A,R4
   \   00031D   EB           MOV     A,R3
   \   00031E   9D           SUBB    A,R5
   \   00031F   40E4         JC      ??zclProcessMessageMSG_21
   \   000321   8882         MOV     DPL,R0
   \   000323   8983         MOV     DPH,R1
   \   000325   A3           INC     DPTR
   \   000326   A3           INC     DPTR
   \   000327   A3           INC     DPTR
   \   000328   A3           INC     DPTR
   \   000329   C3           CLR     C
   \   00032A   E0           MOVX    A,@DPTR
   \   00032B   9A           SUBB    A,R2
   \   00032C   A3           INC     DPTR
   \   00032D   E0           MOVX    A,@DPTR
   \   00032E   9B           SUBB    A,R3
   \   00032F   40D4         JC      ??zclProcessMessageMSG_21
   \   000331   8882         MOV     DPL,R0
   \   000333   8983         MOV     DPH,R1
   \   000335   8006         SJMP    ??zclProcessMessageMSG_23
   \                     ??zclProcessMessageMSG_19:
   \   000337   758200       MOV     DPL,#0x0
   \   00033A   758300       MOV     DPH,#0x0
   1533              if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
   \                     ??zclProcessMessageMSG_23:
   \   00033D   E582         MOV     A,DPL
   \   00033F   7002         JNZ     ??zclProcessMessageMSG_24
   \   000341   E583         MOV     A,DPH
   \                     ??zclProcessMessageMSG_24:
   \   000343   602D         JZ      ??zclProcessMessageMSG_25
   \   000345   A3           INC     DPTR
   \   000346   A3           INC     DPTR
   \   000347   A3           INC     DPTR
   \   000348   A3           INC     DPTR
   \   000349   A3           INC     DPTR
   \   00034A   A3           INC     DPTR
   \   00034B   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   00034E   7001         JNZ     ??zclProcessMessageMSG_26
   \   000350   E9           MOV     A,R1
   \                     ??zclProcessMessageMSG_26:
   \   000351   601F         JZ      ??zclProcessMessageMSG_25
   1534              { 
   1535                // The return value of the plugin function will be
   1536                //  ZSuccess - Supported and need default response
   1537                //  ZFailure - Unsupported
   1538                //  ZCL_STATUS_CMD_HAS_RSP - Supported and do not need default rsp
   1539                //  ZCL_STATUS_INVALID_FIELD - Supported, but the incoming msg is wrong formatted
   1540                //  ZCL_STATUS_INVALID_VALUE - Supported, but the request not achievable by the h/w
   1541                //  ZCL_STATUS_SOFTWARE_FAILURE - Supported but ZStack memory allocation fails
   1542                status = pInPlugin->pfnIncomingHdlr( &inMsg );
   \   000353                ; Setup parameters for indirect call
   \   000353   7402         MOV     A,#0x2
   \   000355   12....       LCALL   ?XSTACK_DISP0_8
   \   000358   AA82         MOV     R2,DPL
   \   00035A   AB83         MOV     R3,DPH
   \   00035C   8882         MOV     DPL,R0
   \   00035E   8983         MOV     DPH,R1
   \   000360   12....       LCALL   ?CALL_IND
   \   000363   E9           MOV     A,R1
   \   000364   FA           MOV     R2,A
   1543                if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
   \   000365   74FF         MOV     A,#-0x1
   \   000367   6A           XRL     A,R2
   \   000368   7003         JNZ     $+5
   \   00036A   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1544                  return; // We're done      
   1545              }
   1546              
   1547              if ( status == ZFailure )
   \   00036D   7401         MOV     A,#0x1
   \   00036F   6A           XRL     A,R2
   \   000370   7010         JNZ     ??zclProcessMessageMSG_11
   1548              {
   1549                // Unsupported message
   1550                if ( inMsg.hdr.fc.manuSpecific )
   \                     ??zclProcessMessageMSG_25:
   \   000372   7404         MOV     A,#0x4
   \   000374   12....       LCALL   ?XSTACK_DISP0_8
   \   000377   E0           MOVX    A,@DPTR
   \   000378   5404         ANL     A,#0x4
   \   00037A   6004         JZ      ??zclProcessMessageMSG_27
   1551                  status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
   \   00037C   7A83         MOV     R2,#-0x7d
   \   00037E   8002         SJMP    ??zclProcessMessageMSG_11
   1552                else
   1553                  status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   \                     ??zclProcessMessageMSG_27:
   \   000380   7A81         MOV     R2,#-0x7f
   1554              }
   1555            }
   1556            
   1557            if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
   \                     ??zclProcessMessageMSG_11:
   \   000382   7402         MOV     A,#0x2
   \   000384   12....       LCALL   ?XSTACK_DISP0_8
   \   000387   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   00038A   7064         JNZ     ??zclProcessMessageMSG_1
   \   00038C   7402         MOV     A,#0x2
   \   00038E   12....       LCALL   ?XSTACK_DISP0_8
   \   000391   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   000394   7002         JNZ     ??zclProcessMessageMSG_28
   \   000396   A3           INC     DPTR
   \   000397   E0           MOVX    A,@DPTR
   \                     ??zclProcessMessageMSG_28:
   \   000398   7056         JNZ     ??zclProcessMessageMSG_1
   \   00039A   7404         MOV     A,#0x4
   \   00039C   12....       LCALL   ?XSTACK_DISP0_8
   \   00039F   E0           MOVX    A,@DPTR
   \   0003A0   5410         ANL     A,#0x10
   \   0003A2   704C         JNZ     ??zclProcessMessageMSG_1
   1558            {
   1559              // Send a Default Response command back
   1560              defautlRspCmd.statusCode = status;
   \   0003A4   7401         MOV     A,#0x1
   \   0003A6   12....       LCALL   ?XSTACK_DISP0_8
   \   0003A9   EA           MOV     A,R2
   \   0003AA   F0           MOVX    @DPTR,A
   1561              defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0003AB   7409         MOV     A,#0x9
   \   0003AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0003B0   12....       LCALL   ?Subroutine69 & 0xFFFF
   1562              zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1563                                     inMsg.msg->clusterId, &defautlRspCmd, 
   1564                                     ZCL_FRAME_SERVER_CLIENT_DIR, true, inMsg.hdr.transSeqNum );
   1565            }
   \                     ??CrossCallReturnLabel_114:
   \   0003B3   12....       LCALL   ?XSTACK_DISP0_8
   \   0003B6   12....       LCALL   ??Subroutine154_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_236:
   \   0003B9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003BC   75..01       MOV     ?V0 + 0,#0x1
   \   0003BF   78..         MOV     R0,#?V0 + 0
   \   0003C1   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003C4   78..         MOV     R0,#?V0 + 0
   \   0003C6   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003C9   7403         MOV     A,#0x3
   \   0003CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0003CE   8582..       MOV     ?V0 + 0,DPL
   \   0003D1   8583..       MOV     ?V0 + 1,DPH
   \   0003D4   78..         MOV     R0,#?V0 + 0
   \   0003D6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0003D9   7407         MOV     A,#0x7
   \   0003DB   12....       LCALL   ?XSTACK_DISP0_8
   \   0003DE   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   0003E1   12....       LCALL   ?XSTACK_DISP0_8
   \   0003E4   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_110:
   \   0003E7   12....       LCALL   ?XSTACK_DISP0_8
   \   0003EA   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   0003ED   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??zclProcessMessageMSG_1:
   \   0003F0   7413         MOV     A,#0x13
   \   0003F2   80..         SJMP    ??Subroutine152_0
   1566          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine89:
   \   000000   E5..         MOV     A,?V0 + 0
   \   000002   24..         ADD     A,#(zclCmdTable & 0xff)
   \   000004   F582         MOV     DPL,A
   \   000006   E5..         MOV     A,?V0 + 1
   \   000008   34..         ADDC    A,#((zclCmdTable >> 8) & 0xff)
   \   00000A   F583         MOV     DPH,A
   \   00000C   E4           CLR     A
   \   00000D   93           MOVC    A,@A+DPTR
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine86:
   \   000000   F5..         MOV     ?V0 + 2,A
   \   000002   EF           MOV     A,R7
   \   000003   3400         ADDC    A,#0x0
   \   000005   F5..         MOV     ?V0 + 3,A
   \   000007                ; Setup parameters for call to function afFindEndPointDesc
   \   000007   85..82       MOV     DPL,?V0 + 2
   \   00000A   F583         MOV     DPH,A
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_289:
   \   000003   74FF         MOV     A,#-0x1
   \   000005   6A           XRL     A,R2
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 0,A
   \   000003   75..00       MOV     ?V0 + 1,#0x0
   \   000006   7402         MOV     A,#0x2
   \   000008   78..         MOV     R0,#?V0 + 0
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_171:
   \   000003                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000003                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000003   7408         MOV     A,#0x8
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2406         ADD     A,#0x6
   \   000003   FA           MOV     R2,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   FB           MOV     R3,A
   \   000009   7407         MOV     A,#0x7
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   12....       LCALL   ?Subroutine109 & 0xFFFF
   \                     ??CrossCallReturnLabel_301:
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2415         ADD     A,#0x15
   \   000003   12....       LCALL   ?Subroutine114 & 0xFFFF
   \                     ??CrossCallReturnLabel_173:
   \   000006   E0           MOVX    A,@DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   85..82       MOV     DPL,?V0 + 4
   \   000003   85..83       MOV     DPH,?V0 + 5
   \   000006   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_283:
   \   000009   85..82       MOV     DPL,?V0 + 2
   \   00000C   85..83       MOV     DPH,?V0 + 3
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F9           MOV     R1,A
   \   000011   12....       LCALL   ??zclSetSecurityOption?relay
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_156:
   \   000003   FC           MOV     R4,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   FD           MOV     R5,A
   \   000007   7407         MOV     A,#0x7
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_165:
   \   000003   12....       LCALL   ??zcl_SendDefaultRspCmd?relay
   \   000006   7405         MOV     A,#0x5
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine90:
   \   000000   EE           MOV     A,R6
   \   000001   2404         ADD     A,#0x4
   \   000003   F5..         MOV     ?V0 + 4,A
   \   000005   EF           MOV     A,R7
   \   000006   3400         ADDC    A,#0x0
   \   000008   F5..         MOV     ?V0 + 5,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   12....       LCALL   ?Subroutine107 & 0xFFFF
   \                     ??CrossCallReturnLabel_334:
   \   000003   E8           MOV     A,R0
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine117:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F5..         MOV     ?V0 + 1,A
   \   000004                ; Setup parameters for call to function zclParseHdr
   \   000004                ; Setup parameters for call to function zclGetAttrDataLength
   \   000004                ; Setup parameters for call to function zclGetAttrDataLength
   \   000004   85..82       MOV     DPL,?V0 + 0
   \   000007   F583         MOV     DPH,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_288:
   \   000003   12....       LCALL   ??osal_mem_free?relay
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine114:
   \   000000   12....       LCALL   ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_257:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine127:
   \   000000   F8           MOV     R0,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   02....       LJMP    ?Subroutine133 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine105:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2414         ADD     A,#0x14
   \   000003   12....       LCALL   ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_256:
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F9           MOV     R1,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine99:
   \   000000   12....       LCALL   ?Subroutine125 & 0xFFFF
   \                     ??CrossCallReturnLabel_303:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   22           RET
   1567          
   1568          /*********************************************************************
   1569           * @fn      zclParseHdr
   1570           *
   1571           * @brief   Parse header of the ZCL format
   1572           *
   1573           * @param   hdr - place to put the frame control information
   1574           * @param   pData - incoming buffer to parse
   1575           *
   1576           * @return  pointer past the header
   1577           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1578          uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclParseHdr:
   1579          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   1580            // Clear the header
   1581            osal_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
   \   00000D                ; Setup parameters for call to function osal_memset
   \   00000D   7C06         MOV     R4,#0x6
   \   00000F   7D00         MOV     R5,#0x0
   \   000011   7900         MOV     R1,#0x0
   \   000013   12....       LCALL   ??osal_memset?relay
   1582          
   1583            // Parse the Frame Control
   1584            hdr->fc.type = zcl_FCType( *pData );
   \   000016   85..82       MOV     DPL,?V0 + 0
   \   000019   85..83       MOV     DPH,?V0 + 1
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   54FC         ANL     A,#0xfc
   \   00001F   F8           MOV     R0,A
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   F9           MOV     R1,A
   \   000023   8E82         MOV     DPL,R6
   \   000025   8F83         MOV     DPH,R7
   \   000027   E0           MOVX    A,@DPTR
   \   000028   FA           MOV     R2,A
   \   000029   7403         MOV     A,#0x3
   \   00002B   5A           ANL     A,R2
   \   00002C   48           ORL     A,R0
   \   00002D   F8           MOV     R0,A
   \   00002E   85..82       MOV     DPL,?V0 + 0
   \   000031   85..83       MOV     DPH,?V0 + 1
   \   000034   12....       LCALL   ??Subroutine172_0 & 0xFFFF
   1585            hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_337:
   \   000037   74FB         MOV     A,#-0x5
   \   000039   58           ANL     A,R0
   \   00003A   FA           MOV     R2,A
   \   00003B   8E82         MOV     DPL,R6
   \   00003D   8F83         MOV     DPH,R7
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   A2E2         MOV     C,0xE0 /* A   */.2
   \   000042   E4           CLR     A
   \   000043   92E0         MOV     0xE0 /* A   */.0,C
   \   000045   F5..         MOV     ?V0 + 2,A
   \   000047   75..00       MOV     ?V0 + 3,#0x0
   \   00004A   7402         MOV     A,#0x2
   \   00004C   78..         MOV     R0,#?V0 + 2
   \   00004E   12....       LCALL   ?S_SHL
   \   000051   7404         MOV     A,#0x4
   \   000053   55..         ANL     A,?V0 + 2
   \   000055   4A           ORL     A,R2
   \   000056   85..82       MOV     DPL,?V0 + 0
   \   000059   85..83       MOV     DPH,?V0 + 1
   \   00005C   12....       LCALL   ?Subroutine18 & 0xFFFF
   1586            if ( zcl_FCDirection( *pData ) )
   \                     ??CrossCallReturnLabel_37:
   \   00005F   A2E3         MOV     C,0xE0 /* A   */.3
   \   000061   85..82       MOV     DPL,?V0 + 0
   \   000064   85..83       MOV     DPH,?V0 + 1
   \   000067   E0           MOVX    A,@DPTR
   \   000068   5004         JNC     ??zclParseHdr_0
   1587              hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   00006A   4408         ORL     A,#0x8
   \   00006C   8002         SJMP    ??zclParseHdr_1
   1588            else
   1589              hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zclParseHdr_0:
   \   00006E   54F7         ANL     A,#0xf7
   \                     ??zclParseHdr_1:
   \   000070   F0           MOVX    @DPTR,A
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   12....       LCALL   ??Subroutine175_0 & 0xFFFF
   1590            
   1591            hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_378:
   \   000076   54EF         ANL     A,#0xef
   \   000078   FA           MOV     R2,A
   \   000079   A3           INC     DPTR
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   FB           MOV     R3,A
   \   00007C   8E82         MOV     DPL,R6
   \   00007E   8F83         MOV     DPH,R7
   \   000080   E0           MOVX    A,@DPTR
   \   000081   A2E4         MOV     C,0xE0 /* A   */.4
   \   000083   E4           CLR     A
   \   000084   92E0         MOV     0xE0 /* A   */.0,C
   \   000086   F5..         MOV     ?V0 + 2,A
   \   000088   7404         MOV     A,#0x4
   \   00008A   78..         MOV     R0,#?V0 + 2
   \   00008C   12....       LCALL   ?S_SHL
   \   00008F   7410         MOV     A,#0x10
   \   000091   55..         ANL     A,?V0 + 2
   \   000093   4A           ORL     A,R2
   \   000094   F8           MOV     R0,A
   \   000095   EB           MOV     A,R3
   \   000096   F9           MOV     R1,A
   \   000097   85..82       MOV     DPL,?V0 + 0
   \   00009A   85..83       MOV     DPH,?V0 + 1
   \   00009D   E8           MOV     A,R0
   \   00009E   F0           MOVX    @DPTR,A
   \   00009F   12....       LCALL   ?Subroutine10 & 0xFFFF
   1592            pData++;  // move past the frame control field
   1593          
   1594            // parse the manfacturer code
   1595            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_239:
   \   0000A2   E8           MOV     A,R0
   \   0000A3   5404         ANL     A,#0x4
   \   0000A5   6014         JZ      ??CrossCallReturnLabel_20
   1596            {
   1597              hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
   \   0000A7   E0           MOVX    A,@DPTR
   \   0000A8   FA           MOV     R2,A
   \   0000A9   A3           INC     DPTR
   \   0000AA   E0           MOVX    A,@DPTR
   \   0000AB   F9           MOV     R1,A
   \   0000AC   EA           MOV     A,R2
   \   0000AD   85..82       MOV     DPL,?V0 + 0
   \   0000B0   85..83       MOV     DPH,?V0 + 1
   \   0000B3   A3           INC     DPTR
   \   0000B4   A3           INC     DPTR
   \   0000B5   F0           MOVX    @DPTR,A
   \   0000B6   A3           INC     DPTR
   \   0000B7   E9           MOV     A,R1
   \   0000B8   12....       LCALL   ?Subroutine13 & 0xFFFF
   1598              pData += 2;
   1599            }
   1600          
   1601            // parse the Transaction Sequence Number
   1602            hdr->transSeqNum = *pData++;
   \                     ??CrossCallReturnLabel_20:
   \   0000BB   8E82         MOV     DPL,R6
   \   0000BD   8F83         MOV     DPH,R7
   \   0000BF   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   0000C2   A3           INC     DPTR
   \   0000C3   A3           INC     DPTR
   \   0000C4   12....       LCALL   ?Subroutine9 & 0xFFFF
   1603          
   1604            // parse the Cluster's command ID
   1605            hdr->commandID = *pData++;
   \                     ??CrossCallReturnLabel_18:
   \   0000C7   85..82       MOV     DPL,?V0 + 0
   \   0000CA   85..83       MOV     DPH,?V0 + 1
   \   0000CD   A3           INC     DPTR
   \   0000CE   A3           INC     DPTR
   \   0000CF   A3           INC     DPTR
   \   0000D0   A3           INC     DPTR
   \   0000D1   A3           INC     DPTR
   \   0000D2   12....       LCALL   ??Subroutine168_0 & 0xFFFF
   1606          
   1607            // Should point to the frame payload
   1608            return ( pData );
   \                     ??CrossCallReturnLabel_326:
   \   0000D5   AA82         MOV     R2,DPL
   \   0000D7   AB83         MOV     R3,DPH
   \   0000D9   02....       LJMP    ?Subroutine132 & 0xFFFF
   1609          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   A3           INC     DPTR
   \   000001   E9           MOV     A,R1
   \   000002                REQUIRE ??Subroutine155_0
   \   000002                ; // Fall through to label ??Subroutine155_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine155_0:
   \   000000   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_242:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine95:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   AE82         MOV     R6,DPL
   \   000008   AF83         MOV     R7,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_154:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine94:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   12....       LCALL   ?Subroutine128 & 0xFFFF
   \                     ??CrossCallReturnLabel_186:
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine134:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine128:
   \   000000   EE           MOV     A,R6
   \   000001   2402         ADD     A,#0x2
   \   000003   0E           INC     R6
   \   000004   0E           INC     R6
   \   000005   EF           MOV     A,R7
   \   000006   3400         ADDC    A,#0x0
   \   000008   FF           MOV     R7,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   A3           INC     DPTR
   \   000001   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_243:
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine168_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V0 + 0
   \   000004   85..83       MOV     DPH,?V0 + 1
   \   000007   A3           INC     DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine175_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V0 + 0
   \   000004   85..83       MOV     DPH,?V0 + 1
   \   000007   E0           MOVX    A,@DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine96:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   02....       LJMP    ?Subroutine134 & 0xFFFF
   1610          
   1611          /*********************************************************************
   1612           * @fn      zclBuildHdr
   1613           *
   1614           * @brief   Build header of the ZCL format
   1615           *
   1616           * @param   hdr - outgoing header information
   1617           * @param   pData - outgoing header space
   1618           *
   1619           * @return  pointer past the header
   1620           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1621          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclBuildHdr:
   1622          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   F8           MOV     R0,A
   \   000007   EB           MOV     A,R3
   \   000008   F9           MOV     R1,A
   \   000009   EC           MOV     A,R4
   \   00000A   FA           MOV     R2,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FB           MOV     R3,A
   1623            // Build the Frame Control byte
   1624            *pData = hdr->fc.type;
   \   00000D   8882         MOV     DPL,R0
   \   00000F   8983         MOV     DPH,R1
   \   000011   E0           MOVX    A,@DPTR
   \   000012   5403         ANL     A,#0x3
   \   000014   8A82         MOV     DPL,R2
   \   000016   8B83         MOV     DPH,R3
   \   000018   12....       LCALL   ??Subroutine156_0 & 0xFFFF
   1625            *pData |= hdr->fc.manuSpecific << 2;
   \                     ??CrossCallReturnLabel_246:
   \   00001B   5404         ANL     A,#0x4
   \   00001D   12....       LCALL   ?Subroutine22 & 0xFFFF
   1626            *pData |= hdr->fc.direction << 3;
   \                     ??CrossCallReturnLabel_244:
   \   000020   5408         ANL     A,#0x8
   \   000022   12....       LCALL   ?Subroutine22 & 0xFFFF
   1627            *pData |= hdr->fc.disableDefaultRsp << 4;
   \                     ??CrossCallReturnLabel_245:
   \   000025   5410         ANL     A,#0x10
   \   000027   FC           MOV     R4,A
   \   000028   8A82         MOV     DPL,R2
   \   00002A   8B83         MOV     DPH,R3
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   4C           ORL     A,R4
   \   00002E   12....       LCALL   ?Subroutine12 & 0xFFFF
   1628            pData++;  // move past the frame control field
   1629          
   1630            // Add the manfacturer code
   1631            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_247:
   \   000031   E0           MOVX    A,@DPTR
   \   000032   5404         ANL     A,#0x4
   \   000034   6016         JZ      ??CrossCallReturnLabel_260
   1632            {
   1633              *pData++ = LO_UINT16( hdr->manuCode );
   \   000036   E8           MOV     A,R0
   \   000037   2402         ADD     A,#0x2
   \   000039   FC           MOV     R4,A
   \   00003A   E9           MOV     A,R1
   \   00003B   3400         ADDC    A,#0x0
   \   00003D   FD           MOV     R5,A
   \   00003E   8C82         MOV     DPL,R4
   \   000040   8D83         MOV     DPH,R5
   \   000042   12....       LCALL   ??Subroutine158_0 & 0xFFFF
   1634              *pData++ = HI_UINT16( hdr->manuCode );
   \                     ??CrossCallReturnLabel_259:
   \   000045   8C82         MOV     DPL,R4
   \   000047   8D83         MOV     DPH,R5
   \   000049   12....       LCALL   ?Subroutine20 & 0xFFFF
   1635            }
   1636          
   1637            // Add the Transaction Sequence Number
   1638            *pData++ = hdr->transSeqNum;
   \                     ??CrossCallReturnLabel_260:
   \   00004C   8882         MOV     DPL,R0
   \   00004E   8983         MOV     DPH,R1
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   12....       LCALL   ??Subroutine167_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_320:
   \   000057   12....       LCALL   ?Subroutine12 & 0xFFFF
   1639            
   1640            // Add the Cluster's command ID
   1641            *pData++ = hdr->commandID;
   \                     ??CrossCallReturnLabel_248:
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   12....       LCALL   ?Subroutine20 & 0xFFFF
   1642          
   1643            // Should point to the frame payload
   1644            return ( pData );
   \                     ??CrossCallReturnLabel_261:
   \   000061   7F01         MOV     R7,#0x1
   \   000063   02....       LJMP    ?BANKED_LEAVE_XDATA
   1645          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   FC           MOV     R4,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   E0           MOVX    A,@DPTR
   \   000006   4C           ORL     A,R4
   \   000007                REQUIRE ??Subroutine156_0
   \   000007                ; // Fall through to label ??Subroutine156_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine156_0:
   \   000000   12....       LCALL   ?Subroutine122 & 0xFFFF
   \                     ??CrossCallReturnLabel_251:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine158_0
   \   000001                ; // Fall through to label ??Subroutine158_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine158_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001                REQUIRE ??Subroutine159_0
   \   000001                ; // Fall through to label ??Subroutine159_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine159_0:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   A3           INC     DPTR
   \   000006   0A           INC     R2
   \   000007   AB83         MOV     R3,DPH
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   AA82         MOV     R2,DPL
   \   000004   AB83         MOV     R3,DPH
   \   000006   80..         SJMP    ??Subroutine157_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine167_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   22           RET
   1646          
   1647          /*********************************************************************
   1648           * @fn      zclCalcHdrSize
   1649           *
   1650           * @brief   Calculate the number of bytes needed for an outgoing
   1651           *          ZCL header.
   1652           *
   1653           * @param   hdr - outgoing header information
   1654           *
   1655           * @return  returns the number of bytes needed
   1656           */
   1657          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
   1658          {
   1659            uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
   1660          
   1661            // Add the manfacturer code
   1662            if ( hdr->fc.manuSpecific )
   1663              needed += 2;
   1664          
   1665            return ( needed );
   1666          }
   1667          
   1668          /*********************************************************************
   1669           * @fn      zclFindPlugin
   1670           *
   1671           * @brief   Find the right plugin for a cluster ID
   1672           *
   1673           * @param   clusterID - cluster ID to look for
   1674           * @param   profileID - profile ID
   1675           * 
   1676           * @return  pointer to plugin, NULL if not found
   1677           */
   1678          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
   1679          {
   1680            zclLibPlugin_t *pLoop;
   1681            
   1682            (void)profileID;  // Intentionally unreferenced parameter
   1683          
   1684            if ( clusterID != ZCL_INVALID_CLUSTER_ID )
   1685            {
   1686              pLoop = plugins;
   1687              while ( pLoop != NULL )
   1688              {
   1689                if ( clusterID >= pLoop->startClusterID && clusterID <= pLoop->endClusterID )
   1690                  return ( pLoop );
   1691                pLoop = pLoop->next;
   1692              }
   1693            }
   1694            return ( (zclLibPlugin_t *)NULL );
   1695          }
   1696          
   1697          /*********************************************************************
   1698           * @fn      zclFindAttrRec
   1699           *
   1700           * @brief   Find the attribute record that matchs the parameters
   1701           *
   1702           * @param   endpoint - Application's endpoint
   1703           * @param   clusterID - cluster ID
   1704           * @param   attrId - attribute looking for
   1705           *
   1706           * @return  TRUE if record found. FALSE, otherwise.
   1707           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1708          uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
   \                     zclFindAttrRec:
   1709          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 2,R1
   \   000007   7410         MOV     A,#0x10
   \   000009   12....       LCALL   ?XSTACK_DISP0_8
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F5..         MOV     ?V0 + 6,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F5..         MOV     ?V0 + 7,A
   1710            uint8 x;
   1711            zclAttrRecsList *pLoop;
   1712          
   1713            pLoop = attrList;
   \   000013   90....       MOV     DPTR,#attrList
   \   000016   8004         SJMP    ??zclFindAttrRec_0
   1714          
   1715            while ( pLoop != NULL )
   1716            {
   1717              if ( pLoop->endpoint == endpoint )
   1718              {
   1719                for ( x = 0; x < pLoop->numAttributes; x++ )
   1720                {
   1721                  if ( pLoop->attrs[x].clusterID == clusterID && pLoop->attrs[x].attr.attrId == attrId )
   1722                  {
   1723                    *pAttr = pLoop->attrs[x];
   1724                    return ( TRUE ); // EMBEDDED RETURN
   1725                  }
   1726                }
   1727              }
   1728              pLoop = pLoop->next;
   \                     ??zclFindAttrRec_1:
   \   000018   8E82         MOV     DPL,R6
   \   00001A   8F83         MOV     DPH,R7
   \                     ??zclFindAttrRec_0:
   \   00001C   12....       LCALL   ??Subroutine166_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_314:
   \   00001F   EE           MOV     A,R6
   \   000020   7001         JNZ     ??zclFindAttrRec_2
   \   000022   EF           MOV     A,R7
   \                     ??zclFindAttrRec_2:
   \   000023   6079         JZ      ??zclFindAttrRec_3
   \   000025   8E82         MOV     DPL,R6
   \   000027   8F83         MOV     DPH,R7
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   65..         XRL     A,?V0 + 2
   \   00002E   70E8         JNZ     ??zclFindAttrRec_1
   \   000030   75..00       MOV     ?V0 + 3,#0x0
   \   000033   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   000036   8002         SJMP    ??zclFindAttrRec_4
   \                     ??zclFindAttrRec_5:
   \   000038   05..         INC     ?V0 + 3
   \                     ??zclFindAttrRec_4:
   \   00003A   8E82         MOV     DPL,R6
   \   00003C   8F83         MOV     DPH,R7
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   F8           MOV     R0,A
   \   000043   E5..         MOV     A,?V0 + 3
   \   000045   C3           CLR     C
   \   000046   98           SUBB    A,R0
   \   000047   50CF         JNC     ??zclFindAttrRec_1
   \   000049   85....       MOV     ?V0 + 0,?V0 + 3
   \   00004C   75..00       MOV     ?V0 + 1,#0x0
   \   00004F   7403         MOV     A,#0x3
   \   000051   78..         MOV     R0,#?V0 + 0
   \   000053   12....       LCALL   ?S_SHL
   \   000056   A8..         MOV     R0,?V0 + 0
   \   000058   A9..         MOV     R1,?V0 + 1
   \   00005A   85..82       MOV     DPL,?V0 + 4
   \   00005D   85..83       MOV     DPH,?V0 + 5
   \   000060   E0           MOVX    A,@DPTR
   \   000061   28           ADD     A,R0
   \   000062   F5..         MOV     ?V0 + 0,A
   \   000064   A3           INC     DPTR
   \   000065   E0           MOVX    A,@DPTR
   \   000066   39           ADDC    A,R1
   \   000067   85..82       MOV     DPL,?V0 + 0
   \   00006A   F583         MOV     DPH,A
   \   00006C   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   00006F   EA           MOV     A,R2
   \   000070   65..         XRL     A,?V0 + 0
   \   000072   7003         JNZ     ??zclFindAttrRec_6
   \   000074   EB           MOV     A,R3
   \   000075   65..         XRL     A,?V0 + 1
   \                     ??zclFindAttrRec_6:
   \   000077   70BF         JNZ     ??zclFindAttrRec_5
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_149:
   \   00007E   EC           MOV     A,R4
   \   00007F   65..         XRL     A,?V0 + 0
   \   000081   7003         JNZ     ??zclFindAttrRec_7
   \   000083   ED           MOV     A,R5
   \   000084   65..         XRL     A,?V0 + 1
   \                     ??zclFindAttrRec_7:
   \   000086   70B0         JNZ     ??zclFindAttrRec_5
   \   000088   85..82       MOV     DPL,?V0 + 4
   \   00008B   85..83       MOV     DPH,?V0 + 5
   \   00008E   12....       LCALL   ?Subroutine129 & 0xFFFF
   \                     ??CrossCallReturnLabel_188:
   \   000091   AC..         MOV     R4,?V0 + 6
   \   000093   AD..         MOV     R5,?V0 + 7
   \   000095   7408         MOV     A,#0x8
   \   000097   12....       LCALL   ?MOVE_LONG8_XDATA_CODE
   \   00009A   7901         MOV     R1,#0x1
   \   00009C   8002         SJMP    ??zclFindAttrRec_8
   1729            }
   1730          
   1731            return ( FALSE );
   \                     ??zclFindAttrRec_3:
   \   00009E   7900         MOV     R1,#0x0
   \                     ??zclFindAttrRec_8:
   \   0000A0   02....       LJMP    ??Subroutine153_0 & 0xFFFF
   1732          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine91:
   \   000000   E4           CLR     A
   \   000001   93           MOVC    A,@A+DPTR
   \   000002   F5..         MOV     ?V0 + 0,A
   \   000004   7401         MOV     A,#0x1
   \   000006   93           MOVC    A,@A+DPTR
   \   000007   F5..         MOV     ?V0 + 1,A
   \   000009   22           RET
   1733          
   1734          /*********************************************************************
   1735           * @fn      zclFindClusterOption
   1736           *
   1737           * @brief   Find the option record that matchs the cluster id
   1738           *
   1739           * @param   endpoint - Application's endpoint
   1740           * @param   clusterID - cluster ID looking for
   1741           *
   1742           * @return  pointer to clutser option, NULL if not found
   1743           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1744          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclFindClusterOption:
   1745          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   1746            uint8 x;
   1747            zclClusterOptionList *pLoop;
   1748          
   1749            pLoop = clusterOptionList;
   \   000007   90....       MOV     DPTR,#clusterOptionList
   \   00000A   8004         SJMP    ??zclFindClusterOption_0
   1750          
   1751            while ( pLoop != NULL )
   1752            {
   1753              if ( pLoop->endpoint == endpoint )
   1754              {
   1755                for ( x = 0; x < pLoop->numOptions; x++ )
   1756                {
   1757                  if ( pLoop->options[x].clusterID == clusterID )
   1758                    return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
   1759                }
   1760              }
   1761              pLoop = pLoop->next;
   \                     ??zclFindClusterOption_1:
   \   00000C   8882         MOV     DPL,R0
   \   00000E   8983         MOV     DPH,R1
   \                     ??zclFindClusterOption_0:
   \   000010   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   000013   7001         JNZ     ??zclFindClusterOption_2
   \   000015   E9           MOV     A,R1
   \                     ??zclFindClusterOption_2:
   \   000016   605D         JZ      ??zclFindClusterOption_3
   \   000018   8882         MOV     DPL,R0
   \   00001A   8983         MOV     DPH,R1
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   6E           XRL     A,R6
   \   000020   70EA         JNZ     ??zclFindClusterOption_1
   \   000022   75..00       MOV     ?V0 + 2,#0x0
   \   000025   E8           MOV     A,R0
   \   000026   2404         ADD     A,#0x4
   \   000028   FC           MOV     R4,A
   \   000029   E9           MOV     A,R1
   \   00002A   3400         ADDC    A,#0x0
   \   00002C   FD           MOV     R5,A
   \   00002D   8C..         MOV     ?V0 + 0,R4
   \   00002F   8D..         MOV     ?V0 + 1,R5
   \   000031   8002         SJMP    ??zclFindClusterOption_4
   \                     ??zclFindClusterOption_5:
   \   000033   05..         INC     ?V0 + 2
   \                     ??zclFindClusterOption_4:
   \   000035   8882         MOV     DPL,R0
   \   000037   8983         MOV     DPH,R1
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   FC           MOV     R4,A
   \   00003E   E5..         MOV     A,?V0 + 2
   \   000040   C3           CLR     C
   \   000041   9C           SUBB    A,R4
   \   000042   50C8         JNC     ??zclFindClusterOption_1
   \   000044   E5..         MOV     A,?V0 + 2
   \   000046   75F003       MOV     B,#0x3
   \   000049   A4           MUL     AB
   \   00004A   FC           MOV     R4,A
   \   00004B   ADF0         MOV     R5,B
   \   00004D   85..82       MOV     DPL,?V0 + 0
   \   000050   85..83       MOV     DPH,?V0 + 1
   \   000053   E0           MOVX    A,@DPTR
   \   000054   2C           ADD     A,R4
   \   000055   FF           MOV     R7,A
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   3D           ADDC    A,R5
   \   000059   8F82         MOV     DPL,R7
   \   00005B   F583         MOV     DPH,A
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   6A           XRL     A,R2
   \   00005F   7003         JNZ     ??zclFindClusterOption_6
   \   000061   A3           INC     DPTR
   \   000062   E0           MOVX    A,@DPTR
   \   000063   6B           XRL     A,R3
   \                     ??zclFindClusterOption_6:
   \   000064   70CD         JNZ     ??zclFindClusterOption_5
   \   000066   85..82       MOV     DPL,?V0 + 0
   \   000069   85..83       MOV     DPH,?V0 + 1
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   2C           ADD     A,R4
   \   00006E   FA           MOV     R2,A
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   3D           ADDC    A,R5
   \   000072   FB           MOV     R3,A
   \   000073   8004         SJMP    ??zclFindClusterOption_7
   1762            }
   1763          
   1764            return ( NULL );
   \                     ??zclFindClusterOption_3:
   \   000075   7A00         MOV     R2,#0x0
   \   000077   7B00         MOV     R3,#0x0
   \                     ??zclFindClusterOption_7:
   \   000079                REQUIRE ?Subroutine144
   \   000079                ; // Fall through to label ?Subroutine144
   1765          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine144:
   \   000000   7F03         MOV     R7,#0x3
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   1766          
   1767          /*********************************************************************
   1768           * @fn      zclGetClusterOption
   1769           *
   1770           * @brief   Get the option record that matchs the cluster id
   1771           *
   1772           * @param   endpoint - Application's endpoint
   1773           * @param   clusterID - cluster ID looking for
   1774           *
   1775           * @return  clutser option, AF_TX_OPTIONS_NONE if not found
   1776           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1777          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclGetClusterOption:
   1778          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1779            uint8 option;
   1780            zclOptionRec_t *pOption;
   1781          
   1782             pOption = zclFindClusterOption( endpoint, clusterID );
   \   000005                ; Setup parameters for call to function zclFindClusterOption
   \   000005   12....       LCALL   ??zclFindClusterOption?relay
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   1783            if ( pOption != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   7002         JNZ     ??zclGetClusterOption_0
   \   000010   E583         MOV     A,DPH
   \                     ??zclGetClusterOption_0:
   \   000012   6008         JZ      ??zclGetClusterOption_1
   1784            {
   1785              option = pOption->option;
   1786              if ( !ZG_SECURE_ENABLED )
   1787                option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
   1788          
   1789              return ( option ); // EMBEDDED RETURN
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   54BF         ANL     A,#0xbf
   \   000019   F9           MOV     R1,A
   \   00001A   8002         SJMP    ??zclGetClusterOption_2
   1790            }
   1791          
   1792            return ( AF_TX_OPTIONS_NONE );
   \                     ??zclGetClusterOption_1:
   \   00001C   7900         MOV     R1,#0x0
   \                     ??zclGetClusterOption_2:
   \   00001E   80..         SJMP    ?Subroutine141
   1793          }
   1794          
   1795          /*********************************************************************
   1796           * @fn      zclSetSecurityOption
   1797           *
   1798           * @brief   Set the security option for the cluster id
   1799           *
   1800           * @param   endpoint - Application's endpoint
   1801           * @param   clusterID - cluster ID looking for
   1802           * @param   enable - whether to enable (TRUE) or disable (FALSE) security option
   1803           *
   1804           * @return  none
   1805           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1806          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
   \                     zclSetSecurityOption:
   1807          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   1808            zclOptionRec_t *pOption;
   1809          
   1810            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000007                ; Setup parameters for call to function zclFindClusterOption
   \   000007   12....       LCALL   ??zclFindClusterOption?relay
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   A8..         MOV     R0,?V0 + 0
   \   000010   A9..         MOV     R1,?V0 + 1
   1811            if ( pOption != NULL )
   \   000012   E8           MOV     A,R0
   \   000013   7001         JNZ     ??zclSetSecurityOption_0
   \   000015   E9           MOV     A,R1
   \                     ??zclSetSecurityOption_0:
   \   000016   6016         JZ      ??zclSetSecurityOption_1
   1812            {
   1813              if ( enable )
   \   000018   E8           MOV     A,R0
   \   000019   2402         ADD     A,#0x2
   \   00001B   F582         MOV     DPL,A
   \   00001D   E9           MOV     A,R1
   \   00001E   3400         ADDC    A,#0x0
   \   000020   F583         MOV     DPH,A
   \   000022   EE           MOV     A,R6
   \   000023   6005         JZ      ??zclSetSecurityOption_2
   1814                pOption->option |= AF_EN_SECURITY;
   \   000025   E0           MOVX    A,@DPTR
   \   000026   D2E6         SETB    0xE0 /* A   */.6
   \   000028   8003         SJMP    ??zclSetSecurityOption_3
   1815              else
   1816                pOption->option &= (AF_EN_SECURITY ^ 0xFF);
   \                     ??zclSetSecurityOption_2:
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   C2E6         CLR     0xE0 /* A   */.6
   \                     ??zclSetSecurityOption_3:
   \   00002D   F0           MOVX    @DPTR,A
   1817            }
   1818          }
   \                     ??zclSetSecurityOption_1:
   \   00002E                REQUIRE ?Subroutine141
   \   00002E                ; // Fall through to label ?Subroutine141
   1819          
   1820          #ifdef ZCL_DISCOVER
   1821          /*********************************************************************
   1822           * @fn      zclFindNextAttrRec
   1823           *
   1824           * @brief   Find the attribute (or next) record that matchs the parameters
   1825           *
   1826           * @param   endpoint - Application's endpoint
   1827           * @param   clusterID - cluster ID
   1828           * @param   attr - attribute looking for
   1829           *
   1830           * @return  pointer to attribute record, NULL if not found
   1831           */
   1832          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID,
   1833                                           uint16 *attrId, zclAttrRec_t *pAttr )
   1834          {
   1835            uint16 x;
   1836            zclAttrRecsList *pLoop;
   1837          
   1838            pLoop = attrList;
   1839          
   1840            while ( pLoop != NULL )
   1841            {
   1842              if ( pLoop->endpoint == endpoint )
   1843              {
   1844                for ( x = 0; x < pLoop->numAttributes; x++ )
   1845                {
   1846                  if ( pLoop->attrs[x].clusterID == clusterID && pLoop->attrs[x].attr.attrId >= *attrId )
   1847                  {
   1848                    *pAttr = pLoop->attrs[x];
   1849                    
   1850                    // Update attribute ID
   1851                    *attrId = pAttr->attr.attrId; 
   1852                    return ( TRUE ); // EMBEDDED RETURN
   1853                  }
   1854                }
   1855              }
   1856              pLoop = pLoop->next;
   1857            }
   1858          
   1859            return ( FALSE );
   1860          }
   1861          #endif // ZCL_DISCOVER
   1862          
   1863          #if defined(ZCL_READ) || defined(ZCL_WRITE) || defined(ZCL_REPORT)
   1864          /*********************************************************************
   1865           * @fn      zclSerializeData
   1866           *
   1867           * @brief   Builds a buffer from the attribute data to sent out over
   1868           *          the air.
   1869           *
   1870           * @param   dataType - data types defined in zcl.h
   1871           * @param   attrData - pointer to the attribute data
   1872           * @param   buf - where to put the serialized data
   1873           *
   1874           * @return  none
   1875           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1876          static void zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
   \                     zclSerializeData:
   1877          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   EC           MOV     A,R4
   \   00000A   FA           MOV     R2,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FB           MOV     R3,A
   1878            uint8 *pStr;
   1879            uint8 len;
   1880          
   1881            switch ( dataType )
   \   00000D   8E..         MOV     ?V0 + 0,R6
   \   00000F   8F..         MOV     ?V0 + 1,R7
   \   000011   75..00       MOV     ?V0 + 2,#0x0
   \   000014   8A82         MOV     DPL,R2
   \   000016   8B83         MOV     DPH,R3
   \   000018   A3           INC     DPTR
   \   000019   AC82         MOV     R4,DPL
   \   00001B   AD83         MOV     R5,DPH
   \   00001D   E9           MOV     A,R1
   \   00001E   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclSerializeData>_0`:
   \   000021   03           DB        3
   \   000022   41           DB        65
   \   000023   42           DB        66
   \   000024   ....         DW        ??zclSerializeData_0
   \   000026   E0           DB        224
   \   000027   E2           DB        226
   \   000028   ....         DW        ??zclSerializeData_1
   \   00002A   E8           DB        232
   \   00002B   E9           DB        233
   \   00002C   ....         DW        ??zclSerializeData_2
   \   00002E   19           DB        25
   \   00002F   08           DB        8
   \   000030   ....         DW        ??zclSerializeData_3
   \   000032   09           DB        9
   \   000033   ....         DW        ??zclSerializeData_2
   \   000035   0A           DB        10
   \   000036   ....         DW        ??zclSerializeData_4
   \   000038   0B           DB        11
   \   000039   ....         DW        ??zclSerializeData_1
   \   00003B   10           DB        16
   \   00003C   ....         DW        ??zclSerializeData_3
   \   00003E   18           DB        24
   \   00003F   ....         DW        ??zclSerializeData_3
   \   000041   19           DB        25
   \   000042   ....         DW        ??zclSerializeData_2
   \   000044   1A           DB        26
   \   000045   ....         DW        ??zclSerializeData_4
   \   000047   1B           DB        27
   \   000048   ....         DW        ??zclSerializeData_1
   \   00004A   20           DB        32
   \   00004B   ....         DW        ??zclSerializeData_3
   \   00004D   21           DB        33
   \   00004E   ....         DW        ??zclSerializeData_2
   \   000050   22           DB        34
   \   000051   ....         DW        ??zclSerializeData_4
   \   000053   23           DB        35
   \   000054   ....         DW        ??zclSerializeData_1
   \   000056   24           DB        36
   \   000057   ....         DW        ??zclSerializeData_5
   \   000059   25           DB        37
   \   00005A   ....         DW        ??zclSerializeData_6
   \   00005C   28           DB        40
   \   00005D   ....         DW        ??zclSerializeData_3
   \   00005F   29           DB        41
   \   000060   ....         DW        ??zclSerializeData_2
   \   000062   2A           DB        42
   \   000063   ....         DW        ??zclSerializeData_4
   \   000065   2B           DB        43
   \   000066   ....         DW        ??zclSerializeData_1
   \   000068   30           DB        48
   \   000069   ....         DW        ??zclSerializeData_3
   \   00006B   31           DB        49
   \   00006C   ....         DW        ??zclSerializeData_2
   \   00006E   38           DB        56
   \   00006F   ....         DW        ??zclSerializeData_2
   \   000071   39           DB        57
   \   000072   ....         DW        ??zclSerializeData_1
   \   000074   EA           DB        234
   \   000075   ....         DW        ??zclSerializeData_1
   \   000077   F0           DB        240
   \   000078   ....         DW        ??zclSerializeData_7
   \   00007A   ....         DW        ??zclSerializeData_8
   1882            {
   1883              case ZCL_DATATYPE_DATA8:
   1884              case ZCL_DATATYPE_BOOLEAN:
   1885              case ZCL_DATATYPE_BITMAP8:
   1886              case ZCL_DATATYPE_INT8:
   1887              case ZCL_DATATYPE_UINT8:
   1888              case ZCL_DATATYPE_ENUM8:
   1889                *buf = *((uint8 *)attrData);
   \                     ??zclSerializeData_3:
   \   00007C   8E82         MOV     DPL,R6
   \   00007E   8F83         MOV     DPH,R7
   \                     ??zclSerializeData_9:
   \   000080   12....       LCALL   ??Subroutine167_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_321:
   \   000083   F0           MOVX    @DPTR,A
   \   000084   02....       LJMP    ??zclSerializeData_8 & 0xFFFF
   1890                 break;
   1891          
   1892              case ZCL_DATATYPE_DATA16:
   1893              case ZCL_DATATYPE_BITMAP16:
   1894              case ZCL_DATATYPE_UINT16:
   1895              case ZCL_DATATYPE_INT16: 
   1896              case ZCL_DATATYPE_ENUM16:
   1897              case ZCL_DATATYPE_SEMI_PREC:
   1898              case ZCL_DATATYPE_CLUSTER_ID:
   1899              case ZCL_DATATYPE_ATTR_ID:
   1900                *buf++ = LO_UINT16( *((uint16*)attrData) );
   \                     ??zclSerializeData_2:
   \   000087   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_323:
   \   00008A   12....       LCALL   ?Subroutine23 & 0xFFFF
   1901                *buf++ = HI_UINT16( *((uint16*)attrData) );
   \                     ??CrossCallReturnLabel_41:
   \   00008D   A3           INC     DPTR
   \   00008E   80F0         SJMP    ??zclSerializeData_9
   1902                break;
   1903          
   1904              case ZCL_DATATYPE_DATA24:
   1905              case ZCL_DATATYPE_BITMAP24: 
   1906              case ZCL_DATATYPE_UINT24:
   1907              case ZCL_DATATYPE_INT24:
   1908                *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
   \                     ??zclSerializeData_4:
   \   000090   8E82         MOV     DPL,R6
   \   000092   8F83         MOV     DPH,R7
   \   000094   78..         MOV     R0,#?V0 + 0
   \   000096   12....       LCALL   ?L_MOV_X
   \   000099   8A82         MOV     DPL,R2
   \   00009B   8B83         MOV     DPH,R3
   \   00009D   E5..         MOV     A,?V0 + 0
   \   00009F   12....       LCALL   ?Subroutine23 & 0xFFFF
   1909                *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
   \                     ??CrossCallReturnLabel_42:
   \   0000A2   78..         MOV     R0,#?V0 + 0
   \   0000A4   12....       LCALL   ?L_MOV_X
   \   0000A7   E5..         MOV     A,?V0 + 1
   \   0000A9   12....       LCALL   ??Subroutine159_0 & 0xFFFF
   1910                *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
   \                     ??CrossCallReturnLabel_258:
   \   0000AC   8E82         MOV     DPL,R6
   \   0000AE   8F83         MOV     DPH,R7
   \   0000B0   78..         MOV     R0,#?V0 + 0
   \   0000B2   12....       LCALL   ?L_MOV_X
   \   0000B5   7410         MOV     A,#0x10
   \   0000B7   78..         MOV     R0,#?V0 + 0
   \   0000B9   12....       LCALL   ?UL_SHR
   \   0000BC   8A82         MOV     DPL,R2
   \   0000BE   8B83         MOV     DPH,R3
   \   0000C0   E5..         MOV     A,?V0 + 0
   \   0000C2   80BF         SJMP    ??CrossCallReturnLabel_321
   1911                break;
   1912                
   1913              case ZCL_DATATYPE_DATA32:
   1914              case ZCL_DATATYPE_BITMAP32:
   1915              case ZCL_DATATYPE_UINT32:
   1916              case ZCL_DATATYPE_INT32:
   1917              case ZCL_DATATYPE_SINGLE_PREC:
   1918              case ZCL_DATATYPE_TOD:
   1919              case ZCL_DATATYPE_DATE:
   1920              case ZCL_DATATYPE_UTC:
   1921              case ZCL_DATATYPE_BAC_OID:
   1922                buf = osal_buffer_uint32( buf, *((uint32*)attrData) );
   \                     ??zclSerializeData_1:
   \   0000C4                ; Setup parameters for call to function osal_buffer_uint32
   \   0000C4   8E82         MOV     DPL,R6
   \   0000C6   8F83         MOV     DPH,R7
   \   0000C8   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   0000CB   12....       LCALL   ??osal_buffer_uint32?relay
   \   0000CE   7404         MOV     A,#0x4
   \   0000D0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D3   8043         SJMP    ??zclSerializeData_8
   1923                break;
   1924                
   1925              case ZCL_DATATYPE_UINT40:
   1926                pStr = (uint8*)attrData;
   1927                osal_memcpy( buf, pStr, 5 );
   \                     ??zclSerializeData_5:
   \   0000D5                ; Setup parameters for call to function osal_memcpy
   \   0000D5   78..         MOV     R0,#?V0 + 0
   \   0000D7   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000DA   7C05         MOV     R4,#0x5
   \   0000DC   8032         SJMP    ??zclSerializeData_10
   1928                break;
   1929                
   1930              case ZCL_DATATYPE_UINT48:
   1931                pStr = (uint8*)attrData;
   1932                osal_memcpy( buf, pStr, 6 );
   \                     ??zclSerializeData_6:
   \   0000DE                ; Setup parameters for call to function osal_memcpy
   \   0000DE   78..         MOV     R0,#?V0 + 0
   \   0000E0   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000E3   7C06         MOV     R4,#0x6
   \   0000E5   8029         SJMP    ??zclSerializeData_10
   1933                break;
   1934                
   1935              case ZCL_DATATYPE_IEEE_ADDR:
   1936                pStr = (uint8*)attrData;
   1937                osal_memcpy( buf, pStr, 8 );
   \                     ??zclSerializeData_7:
   \   0000E7                ; Setup parameters for call to function osal_memcpy
   \   0000E7   78..         MOV     R0,#?V0 + 0
   \   0000E9   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000EC   7C08         MOV     R4,#0x8
   \   0000EE   8020         SJMP    ??zclSerializeData_10
   1938                break;
   1939                
   1940              case ZCL_DATATYPE_CHAR_STR:
   1941              case ZCL_DATATYPE_OCTET_STR:
   1942                pStr = (uint8*)attrData;
   1943                len = *pStr++;
   \                     ??zclSerializeData_0:
   \   0000F0   8E82         MOV     DPL,R6
   \   0000F2   8F83         MOV     DPH,R7
   \   0000F4   E0           MOVX    A,@DPTR
   \   0000F5   F5..         MOV     ?V0 + 3,A
   \   0000F7   A3           INC     DPTR
   \   0000F8   AE82         MOV     R6,DPL
   \   0000FA   AF83         MOV     R7,DPH
   1944                *buf++ = len;
   \   0000FC   8A82         MOV     DPL,R2
   \   0000FE   8B83         MOV     DPH,R3
   \   000100   F0           MOVX    @DPTR,A
   \   000101   EC           MOV     A,R4
   \   000102   FA           MOV     R2,A
   \   000103   ED           MOV     A,R5
   \   000104   FB           MOV     R3,A
   1945                osal_memcpy( buf, pStr, len );
   \   000105                ; Setup parameters for call to function osal_memcpy
   \   000105   8E..         MOV     ?V0 + 0,R6
   \   000107   8F..         MOV     ?V0 + 1,R7
   \   000109   78..         MOV     R0,#?V0 + 0
   \   00010B   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00010E   AC..         MOV     R4,?V0 + 3
   \                     ??zclSerializeData_10:
   \   000110   7D00         MOV     R5,#0x0
   1946                break;
   1947                
   1948              case ZCL_DATATYPE_NO_DATA:
   1949              case ZCL_DATATYPE_UNKNOWN:
   1950                // Fall through
   1951          
   1952              default:
   1953                break;
   1954            }
   \   000112   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_201:
   \   000115   12....       LCALL   ?DEALLOC_XSTACK8
   1955          }
   \                     ??zclSerializeData_8:
   \   000118   02....       LJMP    ?Subroutine132 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   EC           MOV     A,R4
   \   000002   FA           MOV     R2,A
   \   000003   ED           MOV     A,R5
   \   000004   FB           MOV     R3,A
   \   000005   8E82         MOV     DPL,R6
   \   000007   8F83         MOV     DPH,R7
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004                REQUIRE ??Subroutine167_0
   \   000004                ; // Fall through to label ??Subroutine167_0
   1956          #endif // ZCL_READ || ZCL_WRITE || ZCL_REPORT
   1957          
   1958          #ifdef ZCL_REPORT
   1959          /*********************************************************************
   1960           * @fn      zclAnalogDataType
   1961           *
   1962           * @brief   Checks to see if Data Type is Analog
   1963           *
   1964           * @param   dataType - data type
   1965           *
   1966           * @return  TRUE if data type is analog
   1967           */
   1968          uint8 zclAnalogDataType( uint8 dataType )
   1969          {
   1970            uint8 analog;
   1971            
   1972            switch ( dataType )
   1973            {
   1974              case ZCL_DATATYPE_UINT8:
   1975              case ZCL_DATATYPE_UINT16:
   1976              case ZCL_DATATYPE_UINT24:
   1977              case ZCL_DATATYPE_UINT32:
   1978              case ZCL_DATATYPE_UINT40:
   1979              case ZCL_DATATYPE_UINT48:
   1980              case ZCL_DATATYPE_INT8:
   1981              case ZCL_DATATYPE_INT16:
   1982              case ZCL_DATATYPE_INT24:
   1983              case ZCL_DATATYPE_INT32:
   1984              case ZCL_DATATYPE_SEMI_PREC:
   1985              case ZCL_DATATYPE_SINGLE_PREC:
   1986              case ZCL_DATATYPE_DOUBLE_PREC:
   1987              case ZCL_DATATYPE_TOD:
   1988              case ZCL_DATATYPE_DATE:
   1989              case ZCL_DATATYPE_UTC:
   1990                analog = TRUE;
   1991                break;
   1992                
   1993              default:
   1994                analog = FALSE;
   1995                break;
   1996            }
   1997            
   1998            return ( analog );
   1999          }
   2000          
   2001          /*********************************************************************
   2002           * @fn      zcl_BuildAnalogData
   2003           *
   2004           * @brief   Build an analog arribute out of sequential bytes.
   2005           *
   2006           * @param   dataType - type of data
   2007           * @param   pData - pointer to data
   2008           * @param   pBuf - where to put the data
   2009           *
   2010           * @return  none
   2011           */
   2012          static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf)
   2013          {
   2014            switch ( dataType )
   2015            {
   2016              case ZCL_DATATYPE_UINT8:
   2017              case ZCL_DATATYPE_INT8:
   2018                *pData = *pBuf;
   2019                break;
   2020          
   2021              case ZCL_DATATYPE_UINT16:
   2022              case ZCL_DATATYPE_INT16:
   2023              case ZCL_DATATYPE_SEMI_PREC:
   2024                *((uint16*)pData) = BUILD_UINT16( pBuf[0], pBuf[1] ); 
   2025                break;
   2026           
   2027              case ZCL_DATATYPE_UINT24:
   2028              case ZCL_DATATYPE_INT24:
   2029                *((uint32*)pData) = osal_build_uint32( pBuf, 3 );
   2030                break;
   2031                
   2032              case ZCL_DATATYPE_UINT32:
   2033              case ZCL_DATATYPE_INT32:
   2034              case ZCL_DATATYPE_SINGLE_PREC:
   2035              case ZCL_DATATYPE_TOD:
   2036              case ZCL_DATATYPE_DATE:
   2037              case ZCL_DATATYPE_UTC:
   2038                *((uint32*)pData) = osal_build_uint32( pBuf, 4 );
   2039                break;
   2040                
   2041              case ZCL_DATATYPE_DOUBLE_PREC:
   2042                *pData = 0;
   2043                break;
   2044           
   2045              default:
   2046                break;
   2047            }
   2048          }
   2049          #endif // ZCL_REPORT
   2050          
   2051          /*********************************************************************
   2052           * @fn      zclGetDataTypeLength
   2053           *
   2054           * @brief   Return the length of the datatype in length. 
   2055           *          NOTE: Should not be called for ZCL_DATATYPE_OCTECT_STR or 
   2056           *                ZCL_DATATYPE_CHAR_STR data types.
   2057           *
   2058           * @param   dataType - data type
   2059           *
   2060           * @return  length of data
   2061           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2062          uint8 zclGetDataTypeLength( uint8 dataType )
   \                     zclGetDataTypeLength:
   2063          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2064            uint8 len;
   2065            
   2066            switch ( dataType )
   \   000004   E9           MOV     A,R1
   \   000005   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclGetDataTypeLength>_0`:
   \   000008   02           DB        2
   \   000009   E0           DB        224
   \   00000A   E2           DB        226
   \   00000B   ....         DW        ??zclGetDataTypeLength_0
   \   00000D   E8           DB        232
   \   00000E   E9           DB        233
   \   00000F   ....         DW        ??zclGetDataTypeLength_1
   \   000011   1A           DB        26
   \   000012   08           DB        8
   \   000013   ....         DW        ??zclGetDataTypeLength_2
   \   000015   09           DB        9
   \   000016   ....         DW        ??zclGetDataTypeLength_1
   \   000018   0A           DB        10
   \   000019   ....         DW        ??zclGetDataTypeLength_3
   \   00001B   0B           DB        11
   \   00001C   ....         DW        ??zclGetDataTypeLength_0
   \   00001E   10           DB        16
   \   00001F   ....         DW        ??zclGetDataTypeLength_2
   \   000021   18           DB        24
   \   000022   ....         DW        ??zclGetDataTypeLength_2
   \   000024   19           DB        25
   \   000025   ....         DW        ??zclGetDataTypeLength_1
   \   000027   1A           DB        26
   \   000028   ....         DW        ??zclGetDataTypeLength_3
   \   00002A   1B           DB        27
   \   00002B   ....         DW        ??zclGetDataTypeLength_0
   \   00002D   20           DB        32
   \   00002E   ....         DW        ??zclGetDataTypeLength_2
   \   000030   21           DB        33
   \   000031   ....         DW        ??zclGetDataTypeLength_1
   \   000033   22           DB        34
   \   000034   ....         DW        ??zclGetDataTypeLength_3
   \   000036   23           DB        35
   \   000037   ....         DW        ??zclGetDataTypeLength_0
   \   000039   24           DB        36
   \   00003A   ....         DW        ??zclGetDataTypeLength_4
   \   00003C   25           DB        37
   \   00003D   ....         DW        ??zclGetDataTypeLength_5
   \   00003F   28           DB        40
   \   000040   ....         DW        ??zclGetDataTypeLength_2
   \   000042   29           DB        41
   \   000043   ....         DW        ??zclGetDataTypeLength_1
   \   000045   2A           DB        42
   \   000046   ....         DW        ??zclGetDataTypeLength_3
   \   000048   2B           DB        43
   \   000049   ....         DW        ??zclGetDataTypeLength_0
   \   00004B   30           DB        48
   \   00004C   ....         DW        ??zclGetDataTypeLength_2
   \   00004E   31           DB        49
   \   00004F   ....         DW        ??zclGetDataTypeLength_1
   \   000051   38           DB        56
   \   000052   ....         DW        ??zclGetDataTypeLength_1
   \   000054   39           DB        57
   \   000055   ....         DW        ??zclGetDataTypeLength_0
   \   000057   3A           DB        58
   \   000058   ....         DW        ??zclGetDataTypeLength_6
   \   00005A   EA           DB        234
   \   00005B   ....         DW        ??zclGetDataTypeLength_0
   \   00005D   F0           DB        240
   \   00005E   ....         DW        ??zclGetDataTypeLength_6
   \   000060   ....         DW        ??zclGetDataTypeLength_7
   2067            {
   2068              case ZCL_DATATYPE_DATA8:
   2069              case ZCL_DATATYPE_BOOLEAN:
   2070              case ZCL_DATATYPE_BITMAP8:
   2071              case ZCL_DATATYPE_INT8:
   2072              case ZCL_DATATYPE_UINT8:
   2073              case ZCL_DATATYPE_ENUM8:
   2074                len = 1;
   \                     ??zclGetDataTypeLength_2:
   \   000062   7901         MOV     R1,#0x1
   \   000064   801A         SJMP    ??zclGetDataTypeLength_8
   2075                break;
   2076                
   2077              case ZCL_DATATYPE_DATA16:
   2078              case ZCL_DATATYPE_BITMAP16:
   2079              case ZCL_DATATYPE_UINT16:
   2080              case ZCL_DATATYPE_INT16: 
   2081              case ZCL_DATATYPE_ENUM16:
   2082              case ZCL_DATATYPE_SEMI_PREC:
   2083              case ZCL_DATATYPE_CLUSTER_ID:
   2084              case ZCL_DATATYPE_ATTR_ID:
   2085                len = 2;
   \                     ??zclGetDataTypeLength_1:
   \   000066   7902         MOV     R1,#0x2
   \   000068   8016         SJMP    ??zclGetDataTypeLength_8
   2086                break;
   2087                
   2088              case ZCL_DATATYPE_DATA24:
   2089              case ZCL_DATATYPE_BITMAP24: 
   2090              case ZCL_DATATYPE_UINT24:
   2091              case ZCL_DATATYPE_INT24:
   2092                len = 3;
   \                     ??zclGetDataTypeLength_3:
   \   00006A   7903         MOV     R1,#0x3
   \   00006C   8012         SJMP    ??zclGetDataTypeLength_8
   2093                break;
   2094                
   2095              case ZCL_DATATYPE_DATA32:
   2096              case ZCL_DATATYPE_BITMAP32:
   2097              case ZCL_DATATYPE_UINT32:
   2098              case ZCL_DATATYPE_INT32:
   2099              case ZCL_DATATYPE_SINGLE_PREC:
   2100              case ZCL_DATATYPE_TOD:
   2101              case ZCL_DATATYPE_DATE:
   2102              case ZCL_DATATYPE_UTC:
   2103              case ZCL_DATATYPE_BAC_OID:
   2104                len = 4;
   \                     ??zclGetDataTypeLength_0:
   \   00006E   7904         MOV     R1,#0x4
   \   000070   800E         SJMP    ??zclGetDataTypeLength_8
   2105                break;                       
   2106                          
   2107             case ZCL_DATATYPE_UINT40:
   2108                 len = 5;
   \                     ??zclGetDataTypeLength_4:
   \   000072   7905         MOV     R1,#0x5
   \   000074   800A         SJMP    ??zclGetDataTypeLength_8
   2109                 break;
   2110                 
   2111             case ZCL_DATATYPE_UINT48:
   2112                 len = 6;
   \                     ??zclGetDataTypeLength_5:
   \   000076   7906         MOV     R1,#0x6
   \   000078   8006         SJMP    ??zclGetDataTypeLength_8
   2113                 break;
   2114                 
   2115             case ZCL_DATATYPE_DOUBLE_PREC:
   2116             case ZCL_DATATYPE_IEEE_ADDR:
   2117               len = 8;
   \                     ??zclGetDataTypeLength_6:
   \   00007A   7908         MOV     R1,#0x8
   \   00007C   8002         SJMP    ??zclGetDataTypeLength_8
   2118               break;
   2119          
   2120              case ZCL_DATATYPE_NO_DATA:
   2121              case ZCL_DATATYPE_UNKNOWN:
   2122                // Fall through
   2123                
   2124              default:
   2125                len = 0;
   \                     ??zclGetDataTypeLength_7:
   \   00007E   7900         MOV     R1,#0x0
   2126                break;
   2127            }
   2128            
   2129            return ( len );
   \                     ??zclGetDataTypeLength_8:
   \   000080   02....       LJMP    ?Subroutine131 & 0xFFFF
   2130          }
   2131          
   2132          /*********************************************************************
   2133           * @fn      zclGetAttrDataLength
   2134           *
   2135           * @brief   Return the length of the attribute.
   2136           *
   2137           * @param   dataType - data type
   2138           * @param   pData - pointer to data
   2139           *
   2140           * @return  returns atrribute lentgh
   2141           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2142          uint8 zclGetAttrDataLength( uint8  dataType, uint8 *pData)
   \                     zclGetAttrDataLength:
   2143          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2144            uint8 dataLen = 0;
   2145            
   2146            if ( dataType  == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
   \   000004   7442         MOV     A,#0x42
   \   000006   69           XRL     A,R1
   \   000007   6005         JZ      ??zclGetAttrDataLength_0
   \   000009   7441         MOV     A,#0x41
   \   00000B   69           XRL     A,R1
   \   00000C   7009         JNZ     ??zclGetAttrDataLength_1
   2147            {
   2148              dataLen = *pData + 1; // string length + 1 for length field
   \                     ??zclGetAttrDataLength_0:
   \   00000E   8A82         MOV     DPL,R2
   \   000010   8B83         MOV     DPH,R3
   \   000012   E0           MOVX    A,@DPTR
   \   000013   04           INC     A
   \   000014   F9           MOV     R1,A
   \   000015   8003         SJMP    ??zclGetAttrDataLength_2
   2149            }
   2150            else
   2151            {
   2152              dataLen = zclGetDataTypeLength( dataType );
   \                     ??zclGetAttrDataLength_1:
   \   000017                ; Setup parameters for call to function zclGetDataTypeLength
   \   000017   12....       LCALL   ??zclGetDataTypeLength?relay
   2153            }
   2154          
   2155            return ( dataLen );
   \                     ??zclGetAttrDataLength_2:
   \   00001A   02....       LJMP    ?Subroutine131 & 0xFFFF
   2156          }
   2157          
   2158          /*********************************************************************
   2159           * @fn      zclReadAttrData
   2160           *
   2161           * @brief   Read the attribute's current value into pAttrData.
   2162           *
   2163           * @param   pAttrData - where to put attribute data
   2164           * @param   pAttr - pointer to attribute
   2165           *
   2166           * @return Success
   2167           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2168          uint8 zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr )
   \                     zclReadAttrData:
   2169          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   2170            uint8 dataLen;
   2171              
   2172            dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
   \   000009   EC           MOV     A,R4
   \   00000A   2406         ADD     A,#0x6
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   3400         ADDC    A,#0x0
   \   000010   FF           MOV     R7,A
   \   000011                ; Setup parameters for call to function zclGetAttrDataLength
   \   000011   8E82         MOV     DPL,R6
   \   000013   8F83         MOV     DPH,R7
   \   000015   12....       LCALL   ??Subroutine162_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_275:
   \   000018   8C82         MOV     DPL,R4
   \   00001A   8D83         MOV     DPH,R5
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   12....       LCALL   ?Subroutine106 & 0xFFFF
   2173            osal_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
   \                     ??CrossCallReturnLabel_262:
   \   000021                ; Setup parameters for call to function osal_memcpy
   \   000021   8E82         MOV     DPL,R6
   \   000023   8F83         MOV     DPH,R7
   \   000025   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   000028   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00002B   EA           MOV     A,R2
   \   00002C   FC           MOV     R4,A
   \   00002D   7D00         MOV     R5,#0x0
   \   00002F   AA..         MOV     R2,?V0 + 0
   \   000031   AB..         MOV     R3,?V0 + 1
   \   000033   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_202:
   \   000036   12....       LCALL   ?DEALLOC_XSTACK8
   2174              
   2175            return ( ZCL_STATUS_SUCCESS );
   \   000039   7900         MOV     R1,#0x0
   \   00003B   02....       LJMP    ?Subroutine143 & 0xFFFF
   2176          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine106:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine160_0
   \   000002                ; // Fall through to label ??Subroutine160_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine160_0:
   \   000000   12....       LCALL   ?Subroutine124 & 0xFFFF
   \                     ??CrossCallReturnLabel_267:
   \   000003   FA           MOV     R2,A
   \   000004   22           RET
   2177          
   2178          #ifdef ZCL_WRITE
   2179          /*********************************************************************
   2180           * @fn      zclWriteAttrData
   2181           *
   2182           * @brief   Write the received data.
   2183           *
   2184           * @param   pAttr - where to write data to
   2185           * @param   pWriteRec - data to be written
   2186           *
   2187           * @return  Successful if data was written
   2188           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2189          static uint8 zclWriteAttrData( zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec )
   \                     zclWriteAttrData:
   2190          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
   2191            uint8 len;
   2192          
   2193            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   00000D   8E82         MOV     DPL,R6
   \   00000F   8F83         MOV     DPH,R7
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   A2E1         MOV     C,0xE0 /* A   */.1
   \   000019   504B         JNC     ??zclWriteAttrData_0
   2194            {
   2195              if ( zcl_ValidateAttrDataCB && !zcl_ValidateAttrDataCB( pAttr, pWriteRec ) )
   \   00001B   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   7002         JNZ     ??zclWriteAttrData_1
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \                     ??zclWriteAttrData_1:
   \   000023   6010         JZ      ??zclWriteAttrData_2
   \   000025                ; Setup parameters for indirect call
   \   000025   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   000028   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   00002B   12....       LCALL   ?CALL_IND
   \   00002E   E9           MOV     A,R1
   \   00002F   7004         JNZ     ??zclWriteAttrData_2
   2196                return ( ZCL_STATUS_INVALID_VALUE );
   \   000031   7987         MOV     R1,#-0x79
   \   000033   8033         SJMP    ??zclWriteAttrData_3
   2197              
   2198              len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
   \                     ??zclWriteAttrData_2:
   \   000035   E5..         MOV     A,?V0 + 0
   \   000037   2403         ADD     A,#0x3
   \   000039   F5..         MOV     ?V0 + 0,A
   \   00003B   E5..         MOV     A,?V0 + 1
   \   00003D   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_279:
   \   000040   8E82         MOV     DPL,R6
   \   000042   8F83         MOV     DPH,R7
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   12....       LCALL   ?Subroutine31 & 0xFFFF
   2199              osal_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
   \                     ??CrossCallReturnLabel_204:
   \   00004B   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00004E   EA           MOV     A,R2
   \   00004F   FC           MOV     R4,A
   \   000050   7D00         MOV     R5,#0x0
   \   000052   8E82         MOV     DPL,R6
   \   000054   8F83         MOV     DPH,R7
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   00005F   12....       LCALL   ?DEALLOC_XSTACK8
   2200              return ( ZCL_STATUS_SUCCESS );
   \   000062   7900         MOV     R1,#0x0
   \   000064   8002         SJMP    ??zclWriteAttrData_3
   2201            }
   2202              
   2203            return ( ZCL_STATUS_READ_ONLY );
   \                     ??zclWriteAttrData_0:
   \   000066   7988         MOV     R1,#-0x78
   \                     ??zclWriteAttrData_3:
   \   000068   02....       LJMP    ?Subroutine144 & 0xFFFF
   2204          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   12....       LCALL   ?Subroutine117 & 0xFFFF
   \                     ??CrossCallReturnLabel_179:
   \   000003                REQUIRE ??Subroutine162_0
   \   000003                ; // Fall through to label ??Subroutine162_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine136:
   \   000000   75..00       MOV     ?V0 + 2,#0x0
   \   000003   78..         MOV     R0,#?V0 + 0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_169:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine110:
   \   000000   12....       LCALL   ?Subroutine126 & 0xFFFF
   \                     ??CrossCallReturnLabel_360:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_286:
   \   000003   02....       LJMP    ?Subroutine135 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   12....       LCALL   ??Subroutine160_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_264:
   \   000003                ; Setup parameters for call to function osal_memcpy
   \   000003                ; Setup parameters for call to function osal_memcpy
   \   000003   85..82       MOV     DPL,?V0 + 0
   \   000006   85..83       MOV     DPH,?V0 + 1
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F5..         MOV     ?V0 + 0,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F5..         MOV     ?V0 + 1,A
   \   000010   02....       LJMP    ?Subroutine136 & 0xFFFF
   2205          #endif // ZCL_WRITE
   2206          
   2207          #ifdef ZCL_READ
   2208          /*********************************************************************
   2209           * @fn      zclParseInReadCmd
   2210           *
   2211           * @brief   Parse the "Profile" Read Commands
   2212           *
   2213           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2214           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2215           *
   2216           * @param   pCmd - pointer to incoming data to parse
   2217           *
   2218           * @return  pointer to the parsed command structure
   2219           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2220          void *zclParseInReadCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadCmd:
   2221          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   2222            zclReadCmd_t *readCmd;
   2223            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine47 & 0xFFFF
   2224            
   2225            readCmd = (zclReadCmd_t *)osal_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
   \                     ??CrossCallReturnLabel_318:
   \   000008   12....       LCALL   ?Subroutine49 & 0xFFFF
   2226            if ( readCmd != NULL )
   \                     ??CrossCallReturnLabel_78:
   \   00000B   7001         JNZ     ??zclParseInReadCmd_0
   \   00000D   EB           MOV     A,R3
   \                     ??zclParseInReadCmd_0:
   \   00000E   6045         JZ      ??zclParseInReadCmd_1
   2227            {
   2228              uint8 i;
   2229              
   2230              readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
   \   000010   85..82       MOV     DPL,?V0 + 0
   \   000013   85..83       MOV     DPH,?V0 + 1
   \   000016   E0           MOVX    A,@DPTR
   \   000017   C3           CLR     C
   \   000018   13           RRC     A
   \   000019   8A82         MOV     DPL,R2
   \   00001B   8B83         MOV     DPH,R3
   \   00001D   F0           MOVX    @DPTR,A
   2231              for ( i = 0; i < readCmd->numAttr; i++ )
   \   00001E   75..00       MOV     ?V0 + 0,#0x0
   \   000021   8026         SJMP    ??zclParseInReadCmd_2
   2232              {
   2233                readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadCmd_3:
   \   000023   8E82         MOV     DPL,R6
   \   000025   8F83         MOV     DPH,R7
   \   000027   E0           MOVX    A,@DPTR
   \   000028   FC           MOV     R4,A
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F9           MOV     R1,A
   \   00002C   E4           CLR     A
   \   00002D   2C           ADD     A,R4
   \   00002E   E9           MOV     A,R1
   \   00002F   FD           MOV     R5,A
   \   000030   E5..         MOV     A,?V0 + 0
   \   000032   33           RLC     A
   \   000033   F8           MOV     R0,A
   \   000034   E4           CLR     A
   \   000035   33           RLC     A
   \   000036   F9           MOV     R1,A
   \   000037   EA           MOV     A,R2
   \   000038   28           ADD     A,R0
   \   000039   F582         MOV     DPL,A
   \   00003B   EB           MOV     A,R3
   \   00003C   39           ADDC    A,R1
   \   00003D   F583         MOV     DPH,A
   \   00003F   A3           INC     DPTR
   \   000040   EC           MOV     A,R4
   \   000041   F0           MOVX    @DPTR,A
   \   000042   A3           INC     DPTR
   \   000043   ED           MOV     A,R5
   \   000044   12....       LCALL   ?Subroutine13 & 0xFFFF
   2234                pBuf += 2;
   2235              }
   \                     ??CrossCallReturnLabel_21:
   \   000047   05..         INC     ?V0 + 0
   \                     ??zclParseInReadCmd_2:
   \   000049   8A82         MOV     DPL,R2
   \   00004B   8B83         MOV     DPH,R3
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   FC           MOV     R4,A
   \   00004F   E5..         MOV     A,?V0 + 0
   \   000051   C3           CLR     C
   \   000052   9C           SUBB    A,R4
   \   000053   40CE         JC      ??zclParseInReadCmd_3
   2236            }
   2237          
   2238            return ( (void *)readCmd );
   \                     ??zclParseInReadCmd_1:
   \   000055   02....       LJMP    ?Subroutine132 & 0xFFFF
   2239          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine165_0:
   \   000000   FA           MOV     R2,A
   \   000001   E4           CLR     A
   \   000002   3400         ADDC    A,#0x0
   \   000004                REQUIRE ?Subroutine140
   \   000004                ; // Fall through to label ?Subroutine140

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine140:
   \   000000   FB           MOV     R3,A
   \   000001   12....       LCALL   ??osal_mem_alloc?relay
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006                REQUIRE ??Subroutine166_0
   \   000006                ; // Fall through to label ??Subroutine166_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   8582..       MOV     ?V0 + 0,DPL
   \   000008   8583..       MOV     ?V0 + 1,DPH
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F8           MOV     R0,A
   \   00000D   7401         MOV     A,#0x1
   \   00000F   28           ADD     A,R0
   \   000010   12....       LCALL   ??Subroutine165_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_312:
   \   000013   EA           MOV     A,R2
   \   000014   22           RET
   2240          
   2241          /*********************************************************************
   2242           * @fn      zclParseInReadRspCmd
   2243           *
   2244           * @brief   Parse the "Profile" Read Response Commands
   2245           *
   2246           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2247           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2248           *
   2249           * @param   pCmd - pointer to incoming data to parse
   2250           *
   2251           * @return  pointer to the parsed command structure
   2252           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine142:
   \   000000   7402         MOV     A,#0x2
   \   000002   12....       LCALL   ?XSTACK_DISP0_8
   \   000005   12....       LCALL   ??Subroutine162_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_281:
   \   000008                REQUIRE ??Subroutine151_0
   \   000008                ; // Fall through to label ??Subroutine151_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   E9           MOV     A,R1
   \   000001   F5..         MOV     ?V0 + 0,A
   \   000003   FC           MOV     R4,A
   \   000004   7D00         MOV     R5,#0x0
   \   000006   AA..         MOV     R2,?V0 + 6
   \   000008   AB..         MOV     R3,?V0 + 7
   \   00000A                REQUIRE ?Subroutine135
   \   00000A                ; // Fall through to label ?Subroutine135

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2253          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadRspCmd:
   2254          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   12....       LCALL   ?Subroutine1 & 0xFFFF
   2255            zclReadRspCmd_t *readRspCmd;
   2256            zclReadRspStatus_t *statusRec;
   2257            uint8 *pBuf = pCmd->pData;
   2258            uint8 *dataPtr;
   2259            uint8 numAttr = 0;
   2260            uint8 hdrLen;
   2261            uint8 dataLen = 0;
   \                     ??CrossCallReturnLabel_0:
   \   00000D   801B         SJMP    ??zclParseInReadRspCmd_0
   2262            uint8 attrDataLen;
   2263            uint8 dataType;
   2264            uint8 status;
   2265            uint8 i;
   2266            
   2267            // find out the number of attributes and the length of attribute data
   2268            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2269            {
   2270              numAttr++;
   \                     ??zclParseInReadRspCmd_1:
   \   00000F   12....       LCALL   ?Subroutine84 & 0xFFFF
   2271          
   2272              pBuf += 2; // move pass attribute id
   2273              
   2274              status = *pBuf++;  
   \                     ??CrossCallReturnLabel_194:
   \   000012   A3           INC     DPTR
   \   000013   AE82         MOV     R6,DPL
   \   000015   AF83         MOV     R7,DPH
   2275              if ( status == ZCL_STATUS_SUCCESS )
   \   000017   7011         JNZ     ??zclParseInReadRspCmd_0
   2276              {
   2277                dataType = *pBuf++;
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F9           MOV     R1,A
   \   00001B   A3           INC     DPTR
   \   00001C   0E           INC     R6
   \   00001D   12....       LCALL   ?Subroutine82 & 0xFFFF
   2278          
   2279                attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   2280                pBuf += attrDataLen; // move pass attribute data
   2281                
   2282                // add padding if needed
   2283                if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_138:
   \   000020   5002         JNC     ??zclParseInReadRspCmd_2
   2284                  attrDataLen++;
   \   000022   05..         INC     ?V0 + 4
   2285                dataLen += attrDataLen;
   \                     ??zclParseInReadRspCmd_2:
   \   000024   E5..         MOV     A,?V0 + 4
   \   000026   25..         ADD     A,?V0 + 2
   \   000028   F5..         MOV     ?V0 + 2,A
   2286              }
   2287            }
   \                     ??zclParseInReadRspCmd_0:
   \   00002A   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_306:
   \   00002D   40E0         JC      ??zclParseInReadRspCmd_1
   2288            
   2289            // calculate the length of the response header
   2290            hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) );
   \   00002F   75F006       MOV     B,#0x6
   \   000032   12....       LCALL   ?Subroutine87 & 0xFFFF
   2291            
   2292            readRspCmd = (zclReadRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   \                     ??CrossCallReturnLabel_142:
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   12....       LCALL   ?Subroutine15 & 0xFFFF
   2293            if ( readRspCmd != NULL )
   \                     ??CrossCallReturnLabel_25:
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   7002         JNZ     ??zclParseInReadRspCmd_3
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \                     ??zclParseInReadRspCmd_3:
   \   000043   606B         JZ      ??zclParseInReadRspCmd_4
   2294            {
   2295              pBuf = pCmd->pData;
   \   000045   85..82       MOV     DPL,?V0 + 6
   \   000048   85..83       MOV     DPH,?V0 + 7
   \   00004B   12....       LCALL   ??Subroutine166_0 & 0xFFFF
   2296              dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
   \                     ??CrossCallReturnLabel_315:
   \   00004E   7402         MOV     A,#0x2
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   12....       LCALL   ?Subroutine56 & 0xFFFF
   2297                  
   2298              readRspCmd->numAttr = numAttr;
   \                     ??CrossCallReturnLabel_91:
   \   000056   12....       LCALL   ?XSTACK_DISP0_8
   \   000059   12....       LCALL   ?Subroutine48 & 0xFFFF
   2299              for ( i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_76:
   \   00005C   804B         SJMP    ??zclParseInReadRspCmd_5
   2300              {
   2301                statusRec = &(readRspCmd->attrList[i]);
   \                     ??zclParseInReadRspCmd_6:
   \   00005E   E5..         MOV     A,?V0 + 5
   \   000060   75F006       MOV     B,#0x6
   \   000063   A4           MUL     AB
   \   000064   F8           MOV     R0,A
   \   000065   A9F0         MOV     R1,B
   \   000067   7402         MOV     A,#0x2
   \   000069   12....       LCALL   ?XSTACK_DISP0_8
   \   00006C   12....       LCALL   ?Subroutine0 & 0xFFFF
   2302                
   2303                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2304                pBuf += 2;
   2305                
   2306                statusRec->status = *pBuf++;
   \                     ??CrossCallReturnLabel_192:
   \   00006F   C0E0         PUSH    A
   \   000071   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_293:
   \   000074   A3           INC     DPTR
   \   000075   D0E0         POP     A
   \   000077   12....       LCALL   ??Subroutine155_0 & 0xFFFF
   2307                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??CrossCallReturnLabel_240:
   \   00007A   702B         JNZ     ??CrossCallReturnLabel_271
   2308                {
   2309                  statusRec->dataType = *pBuf++;
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   F9           MOV     R1,A
   \   00007E   85..82       MOV     DPL,?XSP + 0
   \   000081   85..83       MOV     DPH,?XSP + 1
   \   000084   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   000087   E9           MOV     A,R1
   \   000088   12....       LCALL   ??Subroutine168_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_327:
   \   00008B   0E           INC     R6
   \   00008C   AF83         MOV     R7,DPH
   2310          
   2311                  attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \   00008E                ; Setup parameters for call to function zclGetAttrDataLength
   \   00008E   12....       LCALL   ?Subroutine83 & 0xFFFF
   2312                  osal_memcpy( dataPtr, pBuf, attrDataLen);
   \                     ??CrossCallReturnLabel_205:
   \   000091   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000094   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_197:
   \   000097   12....       LCALL   ?DEALLOC_XSTACK8
   2313                  statusRec->data = dataPtr;
   \   00009A   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_294:
   \   00009D   12....       LCALL   ?Subroutine6 & 0xFFFF
   2314                  
   2315                  pBuf += attrDataLen; // move pass attribute data
   2316                  
   2317                  // advance attribute data pointer
   2318                  if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_10:
   \   0000A0   5002         JNC     ??zclParseInReadRspCmd_7
   2319                    attrDataLen++;
   \   0000A2   05..         INC     ?V0 + 4
   2320                  dataPtr += attrDataLen;
   \                     ??zclParseInReadRspCmd_7:
   \   0000A4   12....       LCALL   ?Subroutine88 & 0xFFFF
   2321                }
   2322              }
   \                     ??CrossCallReturnLabel_271:
   \   0000A7   05..         INC     ?V0 + 5
   \                     ??zclParseInReadRspCmd_5:
   \   0000A9   E5..         MOV     A,?V0 + 5
   \   0000AB   C3           CLR     C
   \   0000AC   95..         SUBB    A,?V0 + 3
   \   0000AE   40AE         JC      ??zclParseInReadRspCmd_6
   2323            }
   2324          
   2325            return ( (void *)readRspCmd );
   \                     ??zclParseInReadRspCmd_4:
   \   0000B0   02....       LJMP    ?Subroutine142 & 0xFFFF
   2326          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine88:
   \   000000   85....       MOV     ?V0 + 0,?V0 + 4
   \   000003                REQUIRE ?Subroutine139
   \   000003                REQUIRE ??Subroutine161_0
   \   000003                ; // Fall through to label ??Subroutine161_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine161_0:
   \   000000   E5..         MOV     A,?V0 + 6
   \   000002   25..         ADD     A,?V0 + 0
   \   000004   F5..         MOV     ?V0 + 6,A
   \   000006   E5..         MOV     A,?V0 + 7
   \   000008                REQUIRE ?Subroutine139
   \   000008                ; // Fall through to label ?Subroutine139

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine139:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F5..         MOV     ?V0 + 7,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine163_0
   \   000006                ; // Fall through to label ??Subroutine163_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   12....       LCALL   ?Subroutine109 & 0xFFFF
   \                     ??CrossCallReturnLabel_299:
   \   000009                REQUIRE ??Subroutine164_0
   \   000009                ; // Fall through to label ??Subroutine164_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine164_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   85..82       MOV     DPL,?V0 + 6
   \   000005   85..83       MOV     DPH,?V0 + 7
   \   000008   E0           MOVX    A,@DPTR
   \   000009   28           ADD     A,R0
   \   00000A   F8           MOV     R0,A
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   3400         ADDC    A,#0x0
   \   00000F   F9           MOV     R1,A
   \   000010   C3           CLR     C
   \   000011   EE           MOV     A,R6
   \   000012   98           SUBB    A,R0
   \   000013   EF           MOV     A,R7
   \   000014   99           SUBB    A,R1
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine87:
   \   000000   E5..         MOV     A,?V0 + 3
   \   000002   A4           MUL     AB
   \   000003   04           INC     A
   \   000004   FA           MOV     R2,A
   \   000005   8A82         MOV     DPL,R2
   \   000007   8582..       MOV     ?V0 + 0,DPL
   \   00000A                ; Setup parameters for call to function osal_mem_alloc
   \   00000A                ; Setup parameters for call to function osal_mem_alloc
   \   00000A   85....       MOV     ?V0 + 4,?V0 + 2
   \   00000D   E5..         MOV     A,?V0 + 4
   \   00000F   12....       LCALL   ?Subroutine115 & 0xFFFF
   \                     ??CrossCallReturnLabel_310:
   \   000012   7402         MOV     A,#0x2
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine115:
   \   000000   25..         ADD     A,?V0 + 0
   \   000002                REQUIRE ?Subroutine140
   \   000002                REQUIRE ??Subroutine165_0
   \   000002                ; // Fall through to label ??Subroutine165_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   05..         INC     ?V0 + 3
   \   000002   12....       LCALL   ?Subroutine120 & 0xFFFF
   \                     ??CrossCallReturnLabel_183:
   \   000005                REQUIRE ?Subroutine134
   \   000005                ; // Fall through to label ?Subroutine134

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   EE           MOV     A,R6
   \   000001   FA           MOV     R2,A
   \   000002   EF           MOV     A,R7
   \   000003   FB           MOV     R3,A
   \   000004   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000007   E9           MOV     A,R1
   \   000008   F5..         MOV     ?V0 + 4,A
   \   00000A                ; Setup parameters for call to function osal_memcpy
   \   00000A                ; Setup parameters for call to function osal_memcpy
   \   00000A   8E..         MOV     ?V0 + 0,R6
   \   00000C   8F..         MOV     ?V0 + 1,R7
   \   00000E                REQUIRE ?Subroutine136
   \   00000E                ; // Fall through to label ?Subroutine136

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   AF83         MOV     R7,DPH
   \   000002                ; Setup parameters for call to function zclGetAttrDataLength
   \   000002                ; Setup parameters for call to function zclGetAttrDataLength
   \   000002   EE           MOV     A,R6
   \   000003   FA           MOV     R2,A
   \   000004   EF           MOV     A,R7
   \   000005   FB           MOV     R3,A
   \   000006   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000009   E9           MOV     A,R1
   \   00000A   F5..         MOV     ?V0 + 4,A
   \   00000C   F5..         MOV     ?V0 + 0,A
   \   00000E   EE           MOV     A,R6
   \   00000F   25..         ADD     A,?V0 + 0
   \   000011   FE           MOV     R6,A
   \   000012   EF           MOV     A,R7
   \   000013   3400         ADDC    A,#0x0
   \   000015   FF           MOV     R7,A
   \   000016   E9           MOV     A,R1
   \   000017   A2E0         MOV     C,0xE0 /* A   */.0
   \   000019   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   12....       LCALL   ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_269:
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_168:
   \   000003   E5..         MOV     A,?V0 + 3
   \   000005   F0           MOVX    @DPTR,A
   \   000006   75..00       MOV     ?V0 + 5,#0x0
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   7402         MOV     A,#0x2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   E5..         MOV     A,?V0 + 6
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   E5..         MOV     A,?V0 + 7
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   EE           MOV     A,R6
   \   00000B   25..         ADD     A,?V0 + 0
   \   00000D   FE           MOV     R6,A
   \   00000E   EF           MOV     A,R7
   \   00000F   3400         ADDC    A,#0x0
   \   000011   FF           MOV     R7,A
   \   000012   E5..         MOV     A,?V0 + 4
   \   000014   A2E0         MOV     C,0xE0 /* A   */.0
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   12....       LCALL   ?Subroutine121 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   2402         ADD     A,#0x2
   \   00000C   F5..         MOV     ?V0 + 6,A
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   12....       LCALL   ?Subroutine119 & 0xFFFF
   \                     ??CrossCallReturnLabel_181:
   \   000013   E0           MOVX    A,@DPTR
   \   000014   FE           MOV     R6,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   FF           MOV     R7,A
   \   000018   75..00       MOV     ?V0 + 3,#0x0
   \   00001B   75..00       MOV     ?V0 + 2,#0x0
   \   00001E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_161:
   \   000003   A882         MOV     R0,DPL
   \   000005   A983         MOV     R1,DPH
   \   000007   85..82       MOV     DPL,?XSP + 0
   \   00000A   85..83       MOV     DPH,?XSP + 1
   \   00000D   E8           MOV     A,R0
   \   00000E   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_190:
   \   000011   FA           MOV     R2,A
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   FB           MOV     R3,A
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   00001E   EA           MOV     A,R2
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   A3           INC     DPTR
   \   000021   EB           MOV     A,R3
   \   000022   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_155:
   \   000025   02....       LJMP    ?Subroutine134 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine120:
   \   000000   12....       LCALL   ?Subroutine128 & 0xFFFF
   \                     ??CrossCallReturnLabel_187:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine119:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F5..         MOV     ?V0 + 7,A
   \   000004   85..82       MOV     DPL,?V0 + 6
   \   000007   F583         MOV     DPH,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine104:
   \   000000   12....       LCALL   ?Subroutine123 & 0xFFFF
   \                     ??CrossCallReturnLabel_185:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine111:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   25..         ADD     A,?V0 + 0
   \   000003   F5..         MOV     ?V0 + 6,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   02....       LJMP    ?Subroutine139 & 0xFFFF
   2327          #endif // ZCL_READ
   2328          
   2329          #ifdef ZCL_WRITE
   2330          /*********************************************************************
   2331           * @fn      zclParseInWriteCmd
   2332           *
   2333           * @brief   Parse the "Profile" Write, Write Undivided and Write No
   2334           *          Response Commands
   2335           *
   2336           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2337           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2338           * 
   2339           * @param   pCmd - pointer to incoming data to parse
   2340           *
   2341           * @return  pointer to the parsed command structure
   2342           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2343          void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteCmd:
   2344          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   12....       LCALL   ?Subroutine1 & 0xFFFF
   2345            zclWriteCmd_t *writeCmd;
   2346            zclWriteRec_t *statusRec;
   2347            uint8 *pBuf = pCmd->pData;
   2348            uint8 attrDataLen;
   2349            uint8 *dataPtr;
   2350            uint8 numAttr = 0;
   2351            uint8 hdrLen;
   2352            uint8 dataLen = 0;
   \                     ??CrossCallReturnLabel_1:
   \   00000D   8014         SJMP    ??zclParseInWriteCmd_0
   2353            uint8 dataType;
   2354            uint8 i;
   2355          
   2356            // find out the number of attributes and the length of attribute data
   2357            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2358            {
   2359              numAttr++;
   \                     ??zclParseInWriteCmd_1:
   \   00000F   12....       LCALL   ?Subroutine84 & 0xFFFF
   2360          
   2361              pBuf += 2; // move pass attribute id
   2362          
   2363              dataType = *pBuf++;
   \                     ??CrossCallReturnLabel_195:
   \   000012   F9           MOV     R1,A
   \   000013   A3           INC     DPTR
   \   000014   AE82         MOV     R6,DPL
   \   000016   12....       LCALL   ?Subroutine82 & 0xFFFF
   2364          
   2365              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   2366              pBuf += attrDataLen; // move pass attribute data
   2367                
   2368              // add padding if needed
   2369              if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_139:
   \   000019   5002         JNC     ??zclParseInWriteCmd_2
   2370                attrDataLen++;
   \   00001B   05..         INC     ?V0 + 4
   2371              dataLen += attrDataLen;
   \                     ??zclParseInWriteCmd_2:
   \   00001D   E5..         MOV     A,?V0 + 4
   \   00001F   25..         ADD     A,?V0 + 2
   \   000021   F5..         MOV     ?V0 + 2,A
   2372            }
   \                     ??zclParseInWriteCmd_0:
   \   000023   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_307:
   \   000026   40E7         JC      ??zclParseInWriteCmd_1
   2373            
   2374            // calculate the length of the response header
   2375            hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) );
   \   000028   75F005       MOV     B,#0x5
   \   00002B   12....       LCALL   ?Subroutine87 & 0xFFFF
   2376            
   2377            writeCmd = (zclWriteCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   \                     ??CrossCallReturnLabel_143:
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   12....       LCALL   ?Subroutine15 & 0xFFFF
   2378            if ( writeCmd != NULL )
   \                     ??CrossCallReturnLabel_26:
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   E0           MOVX    A,@DPTR
   \   000038   7002         JNZ     ??zclParseInWriteCmd_3
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \                     ??zclParseInWriteCmd_3:
   \   00003C   6059         JZ      ??zclParseInWriteCmd_4
   2379            {
   2380              pBuf = pCmd->pData;
   \   00003E   85..82       MOV     DPL,?V0 + 6
   \   000041   85..83       MOV     DPH,?V0 + 7
   \   000044   12....       LCALL   ??Subroutine166_0 & 0xFFFF
   2381              dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
   \                     ??CrossCallReturnLabel_316:
   \   000047   7402         MOV     A,#0x2
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   12....       LCALL   ?Subroutine56 & 0xFFFF
   2382          
   2383              writeCmd->numAttr = numAttr;
   \                     ??CrossCallReturnLabel_92:
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   12....       LCALL   ?Subroutine48 & 0xFFFF
   2384              for ( i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_77:
   \   000055   8039         SJMP    ??zclParseInWriteCmd_5
   2385              {
   2386                statusRec = &(writeCmd->attrList[i]);
   \                     ??zclParseInWriteCmd_6:
   \   000057   E5..         MOV     A,?V0 + 5
   \   000059   75F005       MOV     B,#0x5
   \   00005C   A4           MUL     AB
   \   00005D   F8           MOV     R0,A
   \   00005E   A9F0         MOV     R1,B
   \   000060   7402         MOV     A,#0x2
   \   000062   12....       LCALL   ?XSTACK_DISP0_8
   \   000065   12....       LCALL   ?Subroutine0 & 0xFFFF
   2387                
   2388                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2389                pBuf += 2;
   2390                statusRec->dataType = *pBuf++;
   \                     ??CrossCallReturnLabel_193:
   \   000068   F9           MOV     R1,A
   \   000069   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_295:
   \   00006C   12....       LCALL   ?Subroutine10 & 0xFFFF
   2391          
   2392                attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \                     ??CrossCallReturnLabel_241:
   \   00006F                ; Setup parameters for call to function zclGetAttrDataLength
   \   00006F   12....       LCALL   ?Subroutine83 & 0xFFFF
   2393                osal_memcpy( dataPtr, pBuf, attrDataLen);
   \                     ??CrossCallReturnLabel_206:
   \   000072   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000075   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_198:
   \   000078   12....       LCALL   ?DEALLOC_XSTACK8
   2394                statusRec->attrData = dataPtr;
   \   00007B   85..82       MOV     DPL,?XSP + 0
   \   00007E   85..83       MOV     DPH,?XSP + 1
   \   000081   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   000084   12....       LCALL   ?Subroutine6 & 0xFFFF
   2395                
   2396                pBuf += attrDataLen; // move pass attribute data
   2397                  
   2398                // advance attribute data pointer
   2399                if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_11:
   \   000087   5002         JNC     ??zclParseInWriteCmd_7
   2400                  attrDataLen++;
   \   000089   05..         INC     ?V0 + 4
   2401                dataPtr += attrDataLen;
   \                     ??zclParseInWriteCmd_7:
   \   00008B   12....       LCALL   ?Subroutine88 & 0xFFFF
   2402              }
   \                     ??CrossCallReturnLabel_272:
   \   00008E   05..         INC     ?V0 + 5
   \                     ??zclParseInWriteCmd_5:
   \   000090   E5..         MOV     A,?V0 + 5
   \   000092   C3           CLR     C
   \   000093   95..         SUBB    A,?V0 + 3
   \   000095   40C0         JC      ??zclParseInWriteCmd_6
   2403            }
   2404            
   2405            return ( (void *)writeCmd );
   \                     ??zclParseInWriteCmd_4:
   \   000097   02....       LJMP    ?Subroutine142 & 0xFFFF
   2406          }
   2407          
   2408          /*********************************************************************
   2409           * @fn      zclParseInWriteRspCmd
   2410           *
   2411           * @brief   Parse the "Profile" Write Response Commands
   2412           *
   2413           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2414           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2415           *
   2416           * @param   pCmd - pointer to incoming data to parse
   2417           *
   2418           * @return  pointer to the parsed command structure
   2419           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2420          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteRspCmd:
   2421          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   2422            zclWriteRspCmd_t *writeRspCmd;
   2423            uint8 *pBuf = pCmd->pData;
   \   000005   EA           MOV     A,R2
   \   000006   2402         ADD     A,#0x2
   \   000008   F5..         MOV     ?V0 + 6,A
   \   00000A   EB           MOV     A,R3
   \   00000B   12....       LCALL   ?Subroutine119 & 0xFFFF
   \                     ??CrossCallReturnLabel_180:
   \   00000E   12....       LCALL   ??Subroutine166_0 & 0xFFFF
   2424            uint8 i = 0;
   \                     ??CrossCallReturnLabel_317:
   \   000011   75..00       MOV     ?V0 + 2,#0x0
   2425          
   2426            writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
   \   000014   12....       LCALL   ?Subroutine49 & 0xFFFF
   2427            if ( writeRspCmd != NULL )
   \                     ??CrossCallReturnLabel_79:
   \   000017   7001         JNZ     ??zclParseInWriteRspCmd_0
   \   000019   EB           MOV     A,R3
   \                     ??zclParseInWriteRspCmd_0:
   \   00001A   6058         JZ      ??zclParseInWriteRspCmd_1
   2428            {
   2429              if ( pCmd->dataLen == 1 )
   \   00001C   85..82       MOV     DPL,?V0 + 0
   \   00001F   85..83       MOV     DPH,?V0 + 1
   \   000022   E0           MOVX    A,@DPTR
   \   000023   6401         XRL     A,#0x1
   \   000025   703B         JNZ     ??CrossCallReturnLabel_182
   2430              {
   2431                // special case when all writes were successfull
   2432                writeRspCmd->attrList[i++].status = *pBuf;
   \   000027   12....       LCALL   ?Subroutine66 & 0xFFFF
   2433              }
   \                     ??CrossCallReturnLabel_324:
   \   00002A   A3           INC     DPTR
   \   00002B   F0           MOVX    @DPTR,A
   \   00002C   75..01       MOV     ?V0 + 2,#0x1
   \   00002F   803C         SJMP    ??zclParseInWriteRspCmd_2
   2434              else
   2435              {
   2436                while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2437                {
   2438                  writeRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInWriteRspCmd_3:
   \   000031   E5..         MOV     A,?V0 + 2
   \   000033   75F003       MOV     B,#0x3
   \   000036   A4           MUL     AB
   \   000037   F8           MOV     R0,A
   \   000038   A9F0         MOV     R1,B
   \   00003A   EA           MOV     A,R2
   \   00003B   28           ADD     A,R0
   \   00003C   F8           MOV     R0,A
   \   00003D   EB           MOV     A,R3
   \   00003E   39           ADDC    A,R1
   \   00003F   F9           MOV     R1,A
   \   000040   8E82         MOV     DPL,R6
   \   000042   8F83         MOV     DPH,R7
   \   000044   E0           MOVX    A,@DPTR
   \   000045   8882         MOV     DPL,R0
   \   000047   8983         MOV     DPH,R1
   \   000049   12....       LCALL   ?Subroutine9 & 0xFFFF
   2439                  writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_19:
   \   00004C   F5..         MOV     ?V0 + 4,A
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   FD           MOV     R5,A
   \   000051   E5..         MOV     A,?V0 + 4
   \   000053   8882         MOV     DPL,R0
   \   000055   8983         MOV     DPH,R1
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   F0           MOVX    @DPTR,A
   \   00005A   A3           INC     DPTR
   \   00005B   ED           MOV     A,R5
   \   00005C   F0           MOVX    @DPTR,A
   \   00005D   05..         INC     ?V0 + 2
   2440                  pBuf += 2;
   \   00005F   12....       LCALL   ?Subroutine120 & 0xFFFF
   2441                }
   \                     ??CrossCallReturnLabel_182:
   \   000062   85..82       MOV     DPL,?V0 + 0
   \   000065   85..83       MOV     DPH,?V0 + 1
   \   000068   12....       LCALL   ??Subroutine164_0 & 0xFFFF
   2442              }
   \                     ??CrossCallReturnLabel_305:
   \   00006B   40C4         JC      ??zclParseInWriteRspCmd_3
   2443              
   2444              writeRspCmd->numAttr = i; 
   \                     ??zclParseInWriteRspCmd_2:
   \   00006D   8A82         MOV     DPL,R2
   \   00006F   8B83         MOV     DPH,R3
   \   000071   E5..         MOV     A,?V0 + 2
   \   000073   F0           MOVX    @DPTR,A
   2445            }
   2446          
   2447            return ( (void *)writeRspCmd );
   \                     ??zclParseInWriteRspCmd_1:
   \   000074   02....       LJMP    ??Subroutine153_0 & 0xFFFF
   2448          }
   2449          #endif // ZCL_WRITE
   2450          
   2451          #ifdef ZCL_REPORT
   2452          /*********************************************************************
   2453           * @fn      zclParseInConfigReportCmd
   2454           *
   2455           * @brief   Parse the "Profile" Configure Reporting Command
   2456           *
   2457           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2458           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2459           *
   2460           * @param   pCmd - pointer to incoming data to parse
   2461           *
   2462           * @return  pointer to the parsed command structure
   2463           */
   2464          void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
   2465          {
   2466            zclCfgReportCmd_t *cfgReportCmd;
   2467            zclCfgReportRec_t *reportRec;
   2468            uint8 *pBuf = pCmd->pData;
   2469            uint8 *dataPtr;
   2470            uint8 numAttr = 0;
   2471            uint8 direction;
   2472            uint8 dataType;
   2473            uint8 hdrLen;
   2474            uint8 dataLen = 0;
   2475            uint8 reportChangeLen; // length of Reportable Change field
   2476            uint8 i;
   2477            
   2478            // Calculate the length of the Request command
   2479            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2480            {
   2481              numAttr++;
   2482              
   2483              direction = *pBuf++;
   2484              pBuf += 2; // move pass the attribute ID
   2485              
   2486              // Is there a Reportable Change field?
   2487              if ( direction == ZCL_SEND_ATTR_REPORTS )
   2488              {
   2489                dataType = *pBuf++;
   2490                pBuf += 4; // move pass the Min and Max Reporting Intervals
   2491          
   2492                // For attributes of 'discrete' data types this field is omitted
   2493                if ( zclAnalogDataType( dataType ) )
   2494                {
   2495                  reportChangeLen = zclGetDataTypeLength( dataType );
   2496                  pBuf += reportChangeLen;
   2497                  
   2498                  // add padding if needed
   2499                  if ( PADDING_NEEDED( reportChangeLen ) )
   2500                    reportChangeLen++;
   2501                  dataLen += reportChangeLen;
   2502                }
   2503              }
   2504              else
   2505              {
   2506                pBuf += 2; // move pass the Timeout Period
   2507              }
   2508            } // while loop
   2509          
   2510            hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
   2511            
   2512            cfgReportCmd = (zclCfgReportCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2513            if ( cfgReportCmd != NULL )
   2514            { 
   2515              pBuf = pCmd->pData;
   2516              dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
   2517              
   2518              cfgReportCmd->numAttr = numAttr;
   2519              for ( i = 0; i < numAttr; i++ )
   2520              {
   2521                reportRec = &(cfgReportCmd->attrList[i]);
   2522                
   2523                osal_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
   2524                  
   2525                reportRec->direction = *pBuf++;
   2526                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2527                pBuf += 2;
   2528                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   2529                {
   2530                  // Attribute to be reported
   2531                  reportRec->dataType = *pBuf++;
   2532                  reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2533                  pBuf += 2;
   2534                  reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2535                  pBuf += 2;
   2536          
   2537                  // For attributes of 'discrete' data types this field is omitted
   2538                  if ( zclAnalogDataType( reportRec->dataType ) )
   2539                  {
   2540                    zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
   2541                    reportRec->reportableChange = dataPtr;
   2542                    
   2543                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
   2544                    pBuf += reportChangeLen;
   2545                    
   2546                    // advance attribute data pointer
   2547                    if ( PADDING_NEEDED( reportChangeLen ) )
   2548                      reportChangeLen++;
   2549                    dataPtr += reportChangeLen;
   2550                  }
   2551                }
   2552                else
   2553                {
   2554                  // Attribute reports to be received
   2555                  reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   2556                  pBuf += 2;
   2557                }
   2558              } // while loop
   2559            }
   2560            
   2561            return ( (void *)cfgReportCmd );
   2562          }
   2563          
   2564          /*********************************************************************
   2565           * @fn      zclParseInConfigReportRspCmd
   2566           *
   2567           * @brief   Parse the "Profile" Configure Reporting Response Command
   2568           *
   2569           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2570           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2571           *
   2572           * @param   pCmd - pointer to incoming data to parse
   2573           *
   2574           * @return  pointer to the parsed command structure
   2575           */
   2576          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
   2577          {
   2578            zclCfgReportRspCmd_t *cfgReportRspCmd;
   2579            uint8 *pBuf = pCmd->pData;
   2580            uint8 numAttr;
   2581            uint8 i; 
   2582            
   2583            numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
   2584            
   2585            cfgReportRspCmd = (zclCfgReportRspCmd_t *)osal_mem_alloc( sizeof( zclCfgReportRspCmd_t ) 
   2586                                                      + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
   2587            if ( cfgReportRspCmd != NULL )
   2588            {
   2589              cfgReportRspCmd->numAttr = numAttr;
   2590              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   2591              {
   2592                cfgReportRspCmd->attrList[i].status = *pBuf++;
   2593                cfgReportRspCmd->attrList[i].direction = *pBuf++;
   2594                cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2595                pBuf += 2;
   2596              }
   2597            }
   2598          
   2599            return ( (void *)cfgReportRspCmd );  
   2600          }
   2601          
   2602          /*********************************************************************
   2603           * @fn      zclParseInReadReportCfgCmd
   2604           *
   2605           * @brief   Parse the "Profile" Read Reporting Configuration Command
   2606           *
   2607           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2608           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2609           *
   2610           * @param   pCmd - pointer to incoming data to parse
   2611           *
   2612           * @return  pointer to the parsed command structure
   2613           */
   2614          void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
   2615          {
   2616            zclReadReportCfgCmd_t *readReportCfgCmd;
   2617            uint8 *pBuf = pCmd->pData;
   2618            uint8 numAttr;
   2619            uint8 i;
   2620            
   2621            numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
   2622            
   2623            readReportCfgCmd = (zclReadReportCfgCmd_t *)osal_mem_alloc( sizeof( zclReadReportCfgCmd_t ) 
   2624                                                            + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
   2625            if ( readReportCfgCmd != NULL )
   2626            {
   2627              readReportCfgCmd->numAttr = numAttr;
   2628              for ( i = 0; i < readReportCfgCmd->numAttr; i++)
   2629              {
   2630                readReportCfgCmd->attrList[i].direction = *pBuf++;;
   2631                readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2632                pBuf += 2;
   2633              }
   2634            }
   2635            
   2636            return ( (void *)readReportCfgCmd );
   2637          }
   2638          
   2639          /*********************************************************************
   2640           * @fn      zclParseInReadReportCfgRspCmd
   2641           *
   2642           * @brief   Parse the "Profile" Read Reporting Configuration Response Command
   2643           *
   2644           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2645           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2646           *
   2647           * @param   pCmd - pointer to incoming data to parse
   2648           *
   2649           * @return  pointer to the parsed command structure
   2650           */
   2651          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
   2652          {
   2653            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   2654            zclReportCfgRspRec_t *reportRspRec;
   2655            uint8 reportChangeLen;
   2656            uint8 *pBuf = pCmd->pData;
   2657            uint8 *dataPtr;
   2658            uint8 numAttr = 0;
   2659            uint8 hdrLen;
   2660            uint8 dataLen = 0;
   2661            uint8 status;
   2662            uint8 direction;
   2663            uint8 dataType;
   2664            uint8 i;
   2665            
   2666            // Calculate the length of the response command
   2667            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2668            { 
   2669              numAttr++;
   2670              
   2671              status = *pBuf++;
   2672              direction = *pBuf++; 
   2673              pBuf += 2; // move pass the attribute ID
   2674              
   2675              if ( status == ZCL_STATUS_SUCCESS )
   2676              {
   2677                if ( direction == ZCL_SEND_ATTR_REPORTS )
   2678                {
   2679                  dataType = *pBuf++;
   2680                  pBuf += 4; // move pass the Min and Max Reporting Intervals
   2681           
   2682                  // For attributes of 'discrete' data types this field is omitted
   2683                  if ( zclAnalogDataType( dataType ) )
   2684                  {
   2685                    reportChangeLen = zclGetDataTypeLength( dataType );
   2686                    pBuf += reportChangeLen;
   2687                    
   2688                    // add padding if needed
   2689                    if ( PADDING_NEEDED( reportChangeLen ) )
   2690                      reportChangeLen++;
   2691                    dataLen += reportChangeLen;
   2692                  }
   2693                }
   2694                else
   2695                {
   2696                  pBuf += 2; // move pass the Timeout field
   2697                }
   2698              }
   2699            } // while loop
   2700            
   2701            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
   2702            
   2703            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2704            if ( readReportCfgRspCmd != NULL )
   2705            {
   2706              pBuf = pCmd->pData;
   2707              dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   2708              
   2709              readReportCfgRspCmd->numAttr = numAttr;
   2710              for ( i = 0; i < numAttr; i++ )
   2711              {
   2712                reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   2713                
   2714                reportRspRec->status = *pBuf++;
   2715                reportRspRec->direction = *pBuf++;
   2716                reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2717                pBuf += 2;
   2718           
   2719                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   2720                {
   2721                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   2722                  {
   2723                    reportRspRec->dataType = *pBuf++;
   2724                    reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2725                    pBuf += 2;
   2726                    reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2727                    pBuf += 2;
   2728          
   2729                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   2730                    {
   2731                      zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
   2732                      reportRspRec->reportableChange = dataPtr;
   2733                      
   2734                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType ); 
   2735                      pBuf += reportChangeLen;
   2736                      
   2737                      // advance attribute data pointer
   2738                      if ( PADDING_NEEDED( reportChangeLen ) )
   2739                        reportChangeLen++;
   2740                      dataPtr += reportChangeLen;
   2741                    }
   2742                  }
   2743                  else
   2744                  {
   2745                    reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   2746                    pBuf += 2;
   2747                  }
   2748                }
   2749              } 
   2750            }
   2751            
   2752            return ( (void *)readReportCfgRspCmd );
   2753          }
   2754          
   2755          /*********************************************************************
   2756           * @fn      zclParseInReportCmd
   2757           *
   2758           * @brief   Parse the "Profile" Report Command
   2759           *
   2760           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2761           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2762           *
   2763           * @param   pCmd - pointer to incoming data to parse
   2764           *
   2765           * @return  pointer to the parsed command structure
   2766           */
   2767          void *zclParseInReportCmd( zclParseCmd_t *pCmd )
   2768          {
   2769            zclReportCmd_t *reportCmd;
   2770            zclReport_t *reportRec;
   2771            uint8 *pBuf = pCmd->pData;
   2772            uint8 attrDataLen;
   2773            uint8 *dataPtr;
   2774            uint8 numAttr = 0;
   2775            uint8 hdrLen;
   2776            uint8 dataLen = 0;
   2777            uint8 dataType;
   2778            uint8 i;
   2779          
   2780            // find out the number of attributes and the length of attribute data
   2781            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2782            {
   2783              numAttr++;
   2784          
   2785              pBuf += 2; // move pass attribute id
   2786          
   2787              dataType = *pBuf++;
   2788          
   2789              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   2790              pBuf += attrDataLen; // move pass attribute data
   2791                
   2792              // add padding if needed
   2793              if ( PADDING_NEEDED( attrDataLen ) )
   2794                attrDataLen++;
   2795              dataLen += attrDataLen;
   2796            }
   2797            
   2798            hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
   2799            
   2800            reportCmd = (zclReportCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2801            if (reportCmd != NULL )
   2802            {
   2803              pBuf = pCmd->pData;
   2804              dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
   2805              
   2806              reportCmd->numAttr = numAttr;
   2807              for ( i = 0; i < numAttr; i++ )
   2808              {
   2809                reportRec = &(reportCmd->attrList[i]);
   2810                
   2811                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2812                pBuf += 2;
   2813                reportRec->dataType = *pBuf++;
   2814          
   2815                attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );  
   2816                osal_memcpy( dataPtr, pBuf, attrDataLen );
   2817                reportRec->attrData = dataPtr;
   2818                
   2819                pBuf += attrDataLen; // move pass attribute data
   2820                
   2821                // advance attribute data pointer
   2822                if ( PADDING_NEEDED( attrDataLen ) )
   2823                  attrDataLen++;
   2824                dataPtr += attrDataLen;
   2825              }
   2826            }
   2827            
   2828            return ( (void *)reportCmd );
   2829          }
   2830          #endif // ZCL_REPORT
   2831          
   2832          /*********************************************************************
   2833           * @fn      zclParseInDefaultRspCmd
   2834           *
   2835           * @brief   Parse the "Profile" Default Response Command
   2836           *
   2837           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2838           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2839           *
   2840           * @param   pCmd - pointer to incoming data to parse
   2841           *
   2842           * @return  pointer to the parsed command structure
   2843           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2844          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDefaultRspCmd:
   2845          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2846            zclDefaultRspCmd_t *defaultRspCmd;
   2847            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine47 & 0xFFFF
   2848          
   2849            defaultRspCmd = (zclDefaultRspCmd_t *)osal_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
   \                     ??CrossCallReturnLabel_319:
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008   7A02         MOV     R2,#0x2
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   12....       LCALL   ??osal_mem_alloc?relay
   2850            if ( defaultRspCmd != NULL )
   \   00000F   EA           MOV     A,R2
   \   000010   7001         JNZ     ??zclParseInDefaultRspCmd_0
   \   000012   EB           MOV     A,R3
   \                     ??zclParseInDefaultRspCmd_0:
   \   000013   600D         JZ      ??zclParseInDefaultRspCmd_1
   2851            {
   2852              defaultRspCmd->commandID = *pBuf++;
   \   000015   8E82         MOV     DPL,R6
   \   000017   8F83         MOV     DPH,R7
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   12....       LCALL   ?Subroutine11 & 0xFFFF
   2853              defaultRspCmd->statusCode = *pBuf;
   \                     ??CrossCallReturnLabel_328:
   \   00001D   12....       LCALL   ??Subroutine167_0 & 0xFFFF
   2854            }
   \                     ??CrossCallReturnLabel_322:
   \   000020   A3           INC     DPTR
   \   000021   F0           MOVX    @DPTR,A
   2855          
   2856            return ( (void *)defaultRspCmd );
   \                     ??zclParseInDefaultRspCmd_1:
   \   000022   02....       LJMP    ?Subroutine141 & 0xFFFF
   2857          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004                REQUIRE ??Subroutine168_0
   \   000004                ; // Fall through to label ??Subroutine168_0
   2858          
   2859          #ifdef ZCL_DISCOVER
   2860          /*********************************************************************
   2861           * @fn      zclParseInDiscCmd
   2862           *
   2863           * @brief   Parse the "Profile" Discovery Commands
   2864           *
   2865           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2866           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2867           *
   2868           * @param   pCmd - pointer to incoming data to parse
   2869           *
   2870           * @return  pointer to the parsed command structure
   2871           */
   2872          void *zclParseInDiscCmd( zclParseCmd_t *pCmd )
   2873          {
   2874            zclDiscoverCmd_t *discoverCmd;
   2875            uint8 *pBuf = pCmd->pData;
   2876          
   2877            discoverCmd = (zclDiscoverCmd_t *)osal_mem_alloc( sizeof ( zclDiscoverCmd_t ) );
   2878            if ( discoverCmd != NULL )
   2879            {
   2880              discoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
   2881              pBuf += 2;
   2882              discoverCmd->maxAttrIDs = *pBuf;
   2883            }
   2884          
   2885            return ( (void *)discoverCmd );
   2886          }
   2887          
   2888          /*********************************************************************
   2889           * @fn      zclParseInDiscRspCmd
   2890           *
   2891           * @brief   Parse the "Profile" Discovery Response Commands
   2892           *
   2893           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2894           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2895           *
   2896           * @param   pCmd - pointer to incoming data to parse
   2897           *
   2898           * @return  pointer to the parsed command structure
   2899           */
   2900          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   2901          static void *zclParseInDiscRspCmd( zclParseCmd_t *pCmd )
   2902          {
   2903            zclDiscoverRspCmd_t *discoverRspCmd;
   2904            uint8 *pBuf = pCmd->pData;
   2905            uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
   2906            uint8 i;
   2907          
   2908            discoverRspCmd = (zclDiscoverRspCmd_t *)osal_mem_alloc( sizeof ( zclDiscoverRspCmd_t ) 
   2909                                                           + ( numAttr * sizeof(zclDiscoverInfo_t) ) );
   2910            if ( discoverRspCmd != NULL )
   2911            {
   2912              discoverRspCmd->discComplete = *pBuf++;
   2913              discoverRspCmd->numAttr = numAttr;
   2914              
   2915              for ( i = 0; i < numAttr; i++ )
   2916              {
   2917                discoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2918                pBuf += 2;
   2919                discoverRspCmd->attrList[i].dataType = *pBuf++;;
   2920              }
   2921            }
   2922          
   2923            return ( (void *)discoverRspCmd );
   2924          }
   2925          #endif // ZCL_DISCOVER
   2926          
   2927          #ifdef ZCL_READ
   2928          /*********************************************************************
   2929           * @fn      zclProcessInReadCmd
   2930           *
   2931           * @brief   Process the "Profile" Read Command
   2932           *
   2933           * @param   pInMsg - incoming message to process
   2934           *
   2935           * @return  TRUE if command processed. FALSE, otherwise.
   2936           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   12....       LCALL   ?Subroutine108 & 0xFFFF
   \                     ??CrossCallReturnLabel_384:
   \   000003                REQUIRE ??Subroutine154_0
   \   000003                ; // Fall through to label ??Subroutine154_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2937          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInReadCmd:
   2938          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine15 & 0xFFFF
   2939            zclReadCmd_t *readCmd;
   2940            zclReadRspCmd_t *readRspCmd;
   2941            zclReadRspStatus_t *statusRec;
   2942            zclAttrRec_t attrRec;
   2943            uint8 len;
   2944            uint8 i;
   2945            
   2946            readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
   \                     ??CrossCallReturnLabel_27:
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   E0           MOVX    A,@DPTR
   \   000016   240B         ADD     A,#0xb
   \   000018   F8           MOV     R0,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   12....       LCALL   ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_254:
   \   00001E   12....       LCALL   ??Subroutine170_0 & 0xFFFF
   2947            
   2948            // calculate the length of the response status record
   2949            len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
   2950            
   2951            readRspCmd = osal_mem_alloc( len );
   \                     ??CrossCallReturnLabel_345:
   \   000021                ; Setup parameters for call to function osal_mem_alloc
   \   000021   75F006       MOV     B,#0x6
   \   000024   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_351:
   \   000027   A4           MUL     AB
   \   000028   04           INC     A
   \   000029   FA           MOV     R2,A
   \   00002A   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   2952            if ( readRspCmd == NULL )
   \                     ??CrossCallReturnLabel_219:
   \   00002D   7001         JNZ     ??zclProcessInReadCmd_0
   \   00002F   EB           MOV     A,R3
   \                     ??zclProcessInReadCmd_0:
   \   000030   7005         JNZ     ??zclProcessInReadCmd_1
   2953              return FALSE; // EMBEDDED RETURN
   \   000032   7900         MOV     R1,#0x0
   \   000034   02....       LJMP    ??zclProcessInReadCmd_2 & 0xFFFF
   2954          
   2955            readRspCmd->numAttr = readCmd->numAttr;
   \                     ??zclProcessInReadCmd_1:
   \   000037   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_352:
   \   00003A   8A82         MOV     DPL,R2
   \   00003C   8B83         MOV     DPH,R3
   \   00003E   F0           MOVX    @DPTR,A
   2956            for (i = 0; i < readCmd->numAttr; i++)
   \   00003F   7E00         MOV     R6,#0x0
   \   000041   800C         SJMP    ??zclProcessInReadCmd_3
   2957            {
   2958              statusRec = &(readRspCmd->attrList[i]);
   2959              
   2960              statusRec->attrID = readCmd->attrID[i];
   2961              
   2962              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, readCmd->attrID[i], &attrRec ) )
   2963              {
   2964                statusRec->data = attrRec.attr.dataPtr;
   2965                statusRec->status = ZCL_STATUS_SUCCESS;
   2966                statusRec->dataType = attrRec.attr.dataType;
   2967              }
   2968              else
   2969              {
   2970                statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??zclProcessInReadCmd_4:
   \   000043   7486         MOV     A,#-0x7a
   \   000045   85..82       MOV     DPL,?V0 + 0
   \   000048   85..83       MOV     DPH,?V0 + 1
   \                     ??zclProcessInReadCmd_5:
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   F0           MOVX    @DPTR,A
   2971              }
   \   00004E   0E           INC     R6
   \                     ??zclProcessInReadCmd_3:
   \   00004F   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_353:
   \   000052   FA           MOV     R2,A
   \   000053   EE           MOV     A,R6
   \   000054   C3           CLR     C
   \   000055   9A           SUBB    A,R2
   \   000056   507E         JNC     ??zclProcessInReadCmd_6
   \   000058   8E82         MOV     DPL,R6
   \   00005A   A882         MOV     R0,DPL
   \   00005C   E8           MOV     A,R0
   \   00005D   75F006       MOV     B,#0x6
   \   000060   A4           MUL     AB
   \   000061   FA           MOV     R2,A
   \   000062   ABF0         MOV     R3,B
   \   000064   E5..         MOV     A,?V0 + 6
   \   000066   2A           ADD     A,R2
   \   000067   F582         MOV     DPL,A
   \   000069   E5..         MOV     A,?V0 + 7
   \   00006B   3B           ADDC    A,R3
   \   00006C   F583         MOV     DPH,A
   \   00006E   A3           INC     DPTR
   \   00006F   8582..       MOV     ?V0 + 0,DPL
   \   000072   8583..       MOV     ?V0 + 1,DPH
   \   000075   E8           MOV     A,R0
   \   000076   C3           CLR     C
   \   000077   33           RLC     A
   \   000078   F8           MOV     R0,A
   \   000079   E4           CLR     A
   \   00007A   33           RLC     A
   \   00007B   F9           MOV     R1,A
   \   00007C   85..82       MOV     DPL,?XSP + 0
   \   00007F   85..83       MOV     DPH,?XSP + 1
   \   000082   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   000085   AA82         MOV     R2,DPL
   \   000087   AB83         MOV     R3,DPH
   \   000089   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   00008C   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   00008F   12....       LCALL   ?XSTACK_DISP0_8
   \   000092   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000095                ; Setup parameters for call to function zclFindAttrRec
   \   000095   7404         MOV     A,#0x4
   \   000097   12....       LCALL   ?XSTACK_DISP0_8
   \   00009A   8582..       MOV     ?V0 + 4,DPL
   \   00009D   8583..       MOV     ?V0 + 5,DPH
   \   0000A0   78..         MOV     R0,#?V0 + 4
   \   0000A2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A5   8A82         MOV     DPL,R2
   \   0000A7   8B83         MOV     DPH,R3
   \   0000A9   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_208:
   \   0000AC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AF   E9           MOV     A,R1
   \   0000B0   6091         JZ      ??zclProcessInReadCmd_4
   \   0000B2   740A         MOV     A,#0xa
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   0000BA   A3           INC     DPTR
   \   0000BB   A3           INC     DPTR
   \   0000BC   A3           INC     DPTR
   \   0000BD   A3           INC     DPTR
   \   0000BE   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_340:
   \   0000C1   E4           CLR     A
   \   0000C2   85..82       MOV     DPL,?V0 + 0
   \   0000C5   85..83       MOV     DPH,?V0 + 1
   \   0000C8   A3           INC     DPTR
   \   0000C9   A3           INC     DPTR
   \   0000CA   F0           MOVX    @DPTR,A
   \   0000CB   7408         MOV     A,#0x8
   \   0000CD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D0   12....       LCALL   ?Subroutine78 & 0xFFFF
   2972            }
   \                     ??CrossCallReturnLabel_135:
   \   0000D3   02....       LJMP    ??zclProcessInReadCmd_5 & 0xFFFF
   2973            
   2974            // Build and send Read Response command
   2975            zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,
   2976                             readRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   2977                             true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInReadCmd_6:
   \   0000D6   7402         MOV     A,#0x2
   \   0000D8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DB   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   0000DE                ; Setup parameters for call to function zcl_SendReadRsp
   \   0000DE   7402         MOV     A,#0x2
   \   0000E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E3   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_237:
   \   0000E6   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000E9   75..01       MOV     ?V0 + 0,#0x1
   \   0000EC   78..         MOV     R0,#?V0 + 0
   \   0000EE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000F1   78..         MOV     R0,#?V0 + 0
   \   0000F3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000F6   78..         MOV     R0,#?V0 + 6
   \   0000F8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FB   85..82       MOV     DPL,?V0 + 2
   \   0000FE   85..83       MOV     DPH,?V0 + 3
   \   000101   A3           INC     DPTR
   \   000102   A3           INC     DPTR
   \   000103   A3           INC     DPTR
   \   000104   A3           INC     DPTR
   \   000105   12....       LCALL   ??Subroutine174_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_367:
   \   000108   E5..         MOV     A,?V0 + 2
   \   00010A   2406         ADD     A,#0x6
   \   00010C   FA           MOV     R2,A
   \   00010D   E5..         MOV     A,?V0 + 3
   \   00010F   3400         ADDC    A,#0x0
   \   000111   FB           MOV     R3,A
   \   000112   12....       LCALL   ?Subroutine118 & 0xFFFF
   \                     ??CrossCallReturnLabel_330:
   \   000115   12....       LCALL   ??zcl_SendReadRsp?relay
   \   000118   7405         MOV     A,#0x5
   \   00011A   12....       LCALL   ?DEALLOC_XSTACK8
   2978            osal_mem_free( readRspCmd );
   \   00011D                ; Setup parameters for call to function osal_mem_free
   \   00011D   AA..         MOV     R2,?V0 + 6
   \   00011F   AB..         MOV     R3,?V0 + 7
   \   000121   12....       LCALL   ??osal_mem_free?relay
   2979              
   2980            return TRUE;
   \   000124   7901         MOV     R1,#0x1
   \                     ??zclProcessInReadCmd_2:
   \   000126   740C         MOV     A,#0xc
   \   000128   02....       LJMP    ??Subroutine152_0 & 0xFFFF
   2981          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine118:
   \   000000   E5..         MOV     A,?V0 + 2
   \   000002   2414         ADD     A,#0x14
   \   000004   F582         MOV     DPL,A
   \   000006   E5..         MOV     A,?V0 + 3
   \   000008                REQUIRE ??Subroutine169_0
   \   000008                ; // Fall through to label ??Subroutine169_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine169_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F583         MOV     DPH,A
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F9           MOV     R1,A
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   12....       LCALL   ?Subroutine107 & 0xFFFF
   \                     ??CrossCallReturnLabel_333:
   \   000003   85..82       MOV     DPL,?V0 + 0
   \   000006   85..83       MOV     DPH,?V0 + 1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine170_0:
   \   000000   12....       LCALL   ?Subroutine107 & 0xFFFF
   \                     ??CrossCallReturnLabel_336:
   \   000003   85..82       MOV     DPL,?XSP + 0
   \   000006   85..83       MOV     DPH,?XSP + 1
   \   000009                REQUIRE ??Subroutine171_0
   \   000009                ; // Fall through to label ??Subroutine171_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_163:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine173_0
   \   000006                ; // Fall through to label ??Subroutine173_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   7402         MOV     A,#0x2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_355:
   \   000003   F5..         MOV     ?V0 + 2,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F5..         MOV     ?V0 + 3,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine137:
   \   000000   12....       LCALL   ??zclFindAttrRec?relay
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   12....       LCALL   ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_372:
   \   000003   85..82       MOV     DPL,?V0 + 2
   \   000006   85..83       MOV     DPH,?V0 + 3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_282:
   \   000010   12....       LCALL   ?Subroutine118 & 0xFFFF
   \                     ??CrossCallReturnLabel_331:
   \   000013   80..         SJMP    ?Subroutine137

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine108:
   \   000000   A3           INC     DPTR
   \   000001   E0           MOVX    A,@DPTR
   \   000002   F583         MOV     DPH,A
   \   000004   8882         MOV     DPL,R0
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   02....       LJMP    ?Subroutine138 & 0xFFFF
   2982          #endif // ZCL_READ
   2983          
   2984          #ifdef ZCL_WRITE
   2985          /*********************************************************************
   2986           * @fn      processInWriteCmd
   2987           *
   2988           * @brief   Process the "Profile" Write and Write No Response Commands
   2989           *
   2990           * @param   pInMsg - incoming message to process
   2991           *
   2992           * @return  TRUE if command processed. FALSE, otherwise.
   2993           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2994          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteCmd:
   2995          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV     A,#-0x10
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine16 & 0xFFFF
   2996            zclWriteCmd_t *writeCmd;
   2997            zclWriteRec_t *statusRec;
   2998            zclWriteRspCmd_t *writeRspCmd;
   2999            zclAttrRec_t attrRec;
   3000            uint8 sendRsp = FALSE;
   \                     ??CrossCallReturnLabel_32:
   \   000012   7F00         MOV     R7,#0x0
   3001            uint8 status;
   3002            uint8 i, j = 0;
   \   000014   7E00         MOV     R6,#0x0
   3003          
   3004            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   000016   7402         MOV     A,#0x2
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   00001E   7404         MOV     A,#0x4
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   12....       LCALL   ?Subroutine8 & 0xFFFF
   3005            if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE )
   \                     ??CrossCallReturnLabel_14:
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_380:
   \   00002D   A3           INC     DPTR
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   6402         XRL     A,#0x2
   \   000031   7018         JNZ     ??zclProcessInWriteCmd_0
   3006            {
   3007              // We need to send a response back - allocate space for it
   3008              writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof( zclWriteRspCmd_t ) 
   3009                      + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
   \   000033                ; Setup parameters for call to function osal_mem_alloc
   \   000033   7404         MOV     A,#0x4
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_308:
   \   00003B   8A..         MOV     ?V0 + 0,R2
   \   00003D   8B..         MOV     ?V0 + 1,R3
   3010              if ( writeRspCmd == NULL )
   \   00003F   EA           MOV     A,R2
   \   000040   7001         JNZ     ??zclProcessInWriteCmd_1
   \   000042   EB           MOV     A,R3
   \                     ??zclProcessInWriteCmd_1:
   \   000043   7005         JNZ     ??zclProcessInWriteCmd_2
   3011                return FALSE; // EMBEDDED RETURN
   \   000045   7900         MOV     R1,#0x0
   \   000047   02....       LJMP    ??zclProcessInWriteCmd_3 & 0xFFFF
   3012              sendRsp = TRUE;
   \                     ??zclProcessInWriteCmd_2:
   \   00004A   0F           INC     R7
   3013            }
   3014            
   3015            for (i = 0; i < writeCmd->numAttr; i++)
   \                     ??zclProcessInWriteCmd_0:
   \   00004B   8E..         MOV     ?V0 + 4,R6
   \   00004D   8023         SJMP    ??zclProcessInWriteCmd_4
   3016            {
   3017              statusRec = &(writeCmd->attrList[i]);
   3018              
   3019              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) )
   3020              {
   3021                if ( statusRec->dataType == attrRec.attr.dataType )
   3022                {
   3023                  status = zclWriteAttrData( &attrRec, statusRec );
   3024          
   3025                  // If successful, a write attribute status record shall NOT be generated
   3026                  if ( sendRsp && status != ZCL_STATUS_SUCCESS )
   3027                  {
   3028                    // Attribute is read only - move on to the next write attribute record
   3029                    writeRspCmd->attrList[j].status = status;
   3030                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3031                  }
   3032                }
   3033                else
   3034                {
   3035                  // Attribute data type is incorrect - move on to the next write attribute record
   3036                  if ( sendRsp )
   3037                  {
   3038                    writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   3039                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3040                  }
   3041                }
   3042              }
   3043              else
   3044              {
   3045                // Attribute is not supported - move on to the next write attribute record
   3046                if ( sendRsp )
   \                     ??zclProcessInWriteCmd_5:
   \   00004F   EF           MOV     A,R7
   \   000050   601E         JZ      ??zclProcessInWriteCmd_6
   3047                {
   3048                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   000052   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_296:
   \   000055   7486         MOV     A,#-0x7a
   \                     ??zclProcessInWriteCmd_7:
   \   000057   F0           MOVX    @DPTR,A
   3049                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   \   000058   85..82       MOV     DPL,?V0 + 6
   \   00005B   85..83       MOV     DPH,?V0 + 7
   \   00005E   12....       LCALL   ?Subroutine73 & 0xFFFF
   3050                }
   3051              }
   \                     ??CrossCallReturnLabel_126:
   \   000061   85..82       MOV     DPL,?XSP + 0
   \   000064   85..83       MOV     DPH,?XSP + 1
   \   000067   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_341:
   \   00006F   0E           INC     R6
   \                     ??zclProcessInWriteCmd_6:
   \   000070   05..         INC     ?V0 + 4
   \                     ??zclProcessInWriteCmd_4:
   \   000072   7404         MOV     A,#0x4
   \   000074   12....       LCALL   ?XSTACK_DISP0_8
   \   000077   12....       LCALL   ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_349:
   \   00007A   FA           MOV     R2,A
   \   00007B   E5..         MOV     A,?V0 + 4
   \   00007D   C3           CLR     C
   \   00007E   9A           SUBB    A,R2
   \   00007F   4003         JC      $+5
   \   000081   02....       LJMP    ??zclProcessInWriteCmd_8 & 0xFFFF
   \   000084   E5..         MOV     A,?V0 + 4
   \   000086   75F005       MOV     B,#0x5
   \   000089   A4           MUL     AB
   \   00008A   F8           MOV     R0,A
   \   00008B   A9F0         MOV     R1,B
   \   00008D   7404         MOV     A,#0x4
   \   00008F   12....       LCALL   ?XSTACK_DISP0_8
   \   000092   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   000095   8582..       MOV     ?V0 + 6,DPL
   \   000098   8583..       MOV     ?V0 + 7,DPH
   \   00009B   EE           MOV     A,R6
   \   00009C   75F003       MOV     B,#0x3
   \   00009F   A4           MUL     AB
   \   0000A0   F8           MOV     R0,A
   \   0000A1   A9F0         MOV     R1,B
   \   0000A3   E5..         MOV     A,?V0 + 0
   \   0000A5   28           ADD     A,R0
   \   0000A6   F8           MOV     R0,A
   \   0000A7   E5..         MOV     A,?V0 + 1
   \   0000A9   39           ADDC    A,R1
   \   0000AA   F9           MOV     R1,A
   \   0000AB   85..82       MOV     DPL,?XSP + 0
   \   0000AE   85..83       MOV     DPH,?XSP + 1
   \   0000B1   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   12....       LCALL   ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_350:
   \   0000BA   F8           MOV     R0,A
   \   0000BB   A3           INC     DPTR
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   F9           MOV     R1,A
   \   0000BE   7406         MOV     A,#0x6
   \   0000C0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C3   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_342:
   \   0000C6                ; Setup parameters for call to function zclFindAttrRec
   \   0000C6   7408         MOV     A,#0x8
   \   0000C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CB   8582..       MOV     ?V0 + 2,DPL
   \   0000CE   8583..       MOV     ?V0 + 3,DPH
   \   0000D1   78..         MOV     R0,#?V0 + 2
   \   0000D3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000D6   85..82       MOV     DPL,?V0 + 6
   \   0000D9   85..83       MOV     DPH,?V0 + 7
   \   0000DC   12....       LCALL   ??Subroutine174_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_368:
   \   0000DF   7408         MOV     A,#0x8
   \   0000E1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E4   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   0000E7   FA           MOV     R2,A
   \   0000E8   A3           INC     DPTR
   \   0000E9   E0           MOVX    A,@DPTR
   \   0000EA   FB           MOV     R3,A
   \   0000EB   7408         MOV     A,#0x8
   \   0000ED   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F0   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_209:
   \   0000F3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F6   E9           MOV     A,R1
   \   0000F7   7003         JNZ     $+5
   \   0000F9   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   \   0000FC   85..82       MOV     DPL,?V0 + 6
   \   0000FF   85..83       MOV     DPH,?V0 + 7
   \   000102   A3           INC     DPTR
   \   000103   A3           INC     DPTR
   \   000104   E0           MOVX    A,@DPTR
   \   000105   FA           MOV     R2,A
   \   000106   740C         MOV     A,#0xc
   \   000108   12....       LCALL   ?XSTACK_DISP0_8
   \   00010B   E0           MOVX    A,@DPTR
   \   00010C   6A           XRL     A,R2
   \   00010D   7025         JNZ     ??zclProcessInWriteCmd_9
   \   00010F                ; Setup parameters for call to function zclWriteAttrData
   \   00010F   AC..         MOV     R4,?V0 + 6
   \   000111   AD..         MOV     R5,?V0 + 7
   \   000113   7408         MOV     A,#0x8
   \   000115   12....       LCALL   ?XSTACK_DISP0_8
   \   000118   AA82         MOV     R2,DPL
   \   00011A   AB83         MOV     R3,DPH
   \   00011C   12....       LCALL   ??zclWriteAttrData?relay
   \   00011F   E9           MOV     A,R1
   \   000120   FA           MOV     R2,A
   \   000121   EF           MOV     A,R7
   \   000122   7003         JNZ     $+5
   \   000124   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   \   000127   EA           MOV     A,R2
   \   000128   7003         JNZ     $+5
   \   00012A   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   \   00012D   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_297:
   \   000130   E9           MOV     A,R1
   \   000131   02....       LJMP    ??zclProcessInWriteCmd_7 & 0xFFFF
   \                     ??zclProcessInWriteCmd_9:
   \   000134   EF           MOV     A,R7
   \   000135   7003         JNZ     $+5
   \   000137   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   \   00013A   12....       LCALL   ?Subroutine61 & 0xFFFF
   3052            } // for loop
   \                     ??CrossCallReturnLabel_298:
   \   00013D   748D         MOV     A,#-0x73
   \   00013F   02....       LJMP    ??zclProcessInWriteCmd_7 & 0xFFFF
   3053          
   3054            if ( sendRsp )
   \                     ??zclProcessInWriteCmd_8:
   \   000142   EF           MOV     A,R7
   \   000143   604B         JZ      ??zclProcessInWriteCmd_10
   3055            {
   3056              writeRspCmd->numAttr = j;
   \   000145   EE           MOV     A,R6
   \   000146   85..82       MOV     DPL,?V0 + 0
   \   000149   85..83       MOV     DPH,?V0 + 1
   \   00014C   F0           MOVX    @DPTR,A
   3057              if ( writeRspCmd->numAttr == 0 )
   \   00014D   700C         JNZ     ??zclProcessInWriteCmd_11
   3058              {
   3059                // Since all records were written successful, include a single status record
   3060                // in the resonse command with the status field set to SUCCESS and the 
   3061                // attribute ID field omitted.
   3062                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   00014F   E4           CLR     A
   \   000150   A3           INC     DPTR
   \   000151   F0           MOVX    @DPTR,A
   3063                writeRspCmd->numAttr = 1;
   \   000152   7401         MOV     A,#0x1
   \   000154   85..82       MOV     DPL,?V0 + 0
   \   000157   85..83       MOV     DPH,?V0 + 1
   \   00015A   F0           MOVX    @DPTR,A
   3064              }
   3065              
   3066              zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3067                                pInMsg->msg->clusterId, writeRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR, 
   3068                                true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteCmd_11:
   \   00015B   7402         MOV     A,#0x2
   \   00015D   12....       LCALL   ?XSTACK_DISP0_8
   \   000160   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   000163   12....       LCALL   ?XSTACK_DISP0_8
   \   000166   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_379:
   \   000169   E0           MOVX    A,@DPTR
   \   00016A   F5..         MOV     ?V0 + 2,A
   \   00016C   78..         MOV     R0,#?V0 + 2
   \   00016E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000171   75..01       MOV     ?V0 + 2,#0x1
   \   000174   78..         MOV     R0,#?V0 + 2
   \   000176   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000179   78..         MOV     R0,#?V0 + 2
   \   00017B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00017E   78..         MOV     R0,#?V0 + 0
   \   000180   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000183   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000186   12....       LCALL   ?DEALLOC_XSTACK8
   3069              osal_mem_free( writeRspCmd );
   \   000189                ; Setup parameters for call to function osal_mem_free
   \   000189   AA..         MOV     R2,?V0 + 0
   \   00018B   AB..         MOV     R3,?V0 + 1
   \   00018D   12....       LCALL   ??osal_mem_free?relay
   3070            }
   3071            
   3072            return TRUE; 
   \                     ??zclProcessInWriteCmd_10:
   \   000190   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteCmd_3:
   \   000192   7410         MOV     A,#0x10
   \   000194   02....       LJMP    ??Subroutine152_0 & 0xFFFF
   3073          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_357:
   \   000003   FE           MOV     R6,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   FF           MOV     R7,A
   \   000007                ; Setup parameters for call to function zcl_SendWriteRsp
   \   000007                ; Setup parameters for call to function zcl_SendWriteRsp
   \   000007   7402         MOV     A,#0x2
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   240B         ADD     A,#0xb
   \   000003   12....       LCALL   ?Subroutine114 & 0xFFFF
   \                     ??CrossCallReturnLabel_172:
   \   000006   12....       LCALL   ?Subroutine107 & 0xFFFF
   \                     ??CrossCallReturnLabel_332:
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_356:
   \   000003   75F003       MOV     B,#0x3
   \   000006   A4           MUL     AB
   \   000007   F8           MOV     R0,A
   \   000008   A9F0         MOV     R1,B
   \   00000A   7401         MOV     A,#0x1
   \   00000C   28           ADD     A,R0
   \   00000D   FA           MOV     R2,A
   \   00000E   E4           CLR     A
   \   00000F   39           ADDC    A,R1
   \   000010   02....       LJMP    ?Subroutine140 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   12....       LCALL   ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_373:
   \   00000B   EE           MOV     A,R6
   \   00000C   2406         ADD     A,#0x6
   \   00000E   FA           MOV     R2,A
   \   00000F   EF           MOV     A,R7
   \   000010   3400         ADDC    A,#0x0
   \   000012   FB           MOV     R3,A
   \   000013   EE           MOV     A,R6
   \   000014   2414         ADD     A,#0x14
   \   000016   F582         MOV     DPL,A
   \   000018   EF           MOV     A,R7
   \   000019   12....       LCALL   ??Subroutine169_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_329:
   \   00001C   12....       LCALL   ??zcl_SendWriteRsp?relay
   \   00001F   7405         MOV     A,#0x5
   \   000021   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_164:
   \   000003                REQUIRE ?Subroutine137
   \   000003                ; // Fall through to label ?Subroutine137

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_158:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   F8           MOV     R0,A
   \   000001                REQUIRE ??Subroutine176_0
   \   000001                ; // Fall through to label ??Subroutine176_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine176_0:
   \   000000   12....       LCALL   ?Subroutine108 & 0xFFFF
   \                     ??CrossCallReturnLabel_385:
   \   000003   22           RET
   3074          
   3075          /*********************************************************************
   3076           * @fn      zclRevertWriteUndividedCmd
   3077           *
   3078           * @brief   Revert the "Profile" Write Undevided Command
   3079           *
   3080           * @param   pInMsg - incoming message to process
   3081           * @param   curWriteRec - old data
   3082           * @param   numAttr - number of attributes to be reverted
   3083           *
   3084           * @return  none
   3085           */
   3086          static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg, 
   3087                                              zclWriteRec_t *curWriteRec, uint16 numAttr )
   3088          {
   3089            zclWriteRec_t *statusRec;
   3090            zclAttrRec_t attrRec;
   3091            uint8 dataLen;
   3092            uint8 i;
   3093          
   3094            statusRec = curWriteRec;
   3095            for (i = 0; i < numAttr; i++)
   3096            {
   3097              statusRec = &(curWriteRec[i]);
   3098              
   3099              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) )
   3100                break; // should never happen
   3101           
   3102              // Just copy the old data back - no need to validate the data
   3103              dataLen = zclGetAttrDataLength( attrRec.attr.dataType, statusRec->attrData );
   3104              osal_memcpy( attrRec.attr.dataPtr, statusRec->attrData, dataLen );
   3105            } // for loop
   3106          }
   3107          
   3108          /*********************************************************************
   3109           * @fn      zclProcessInWriteUndividedCmd
   3110           *
   3111           * @brief   Process the "Profile" Write Undivided Command
   3112           *
   3113           * @param   pInMsg - incoming message to process
   3114           *
   3115           * @return  TRUE if command processed. FALSE, otherwise.
   3116           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_167:
   \   000003                REQUIRE ??Subroutine170_0
   \   000003                ; // Fall through to label ??Subroutine170_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   85..82       MOV     DPL,?V0 + 0
   \   000003   85..83       MOV     DPH,?V0 + 1
   \   000006                REQUIRE ??Subroutine174_0
   \   000006                ; // Fall through to label ??Subroutine174_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3117          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteUndividedCmd:
   3118          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 26
   \   000005   74E6         MOV     A,#-0x1a
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine16 & 0xFFFF
   3119            zclWriteCmd_t *writeCmd;
   3120            zclWriteRec_t *statusRec;
   3121            zclWriteRec_t *curWriteRec;
   3122            zclWriteRec_t *curStatusRec;
   3123            zclWriteRspCmd_t *writeRspCmd;
   3124            zclAttrRec_t attrRec;
   3125            uint8 *curDataPtr;
   3126            uint8 hdrLen;
   3127            uint8 dataLen;
   3128            uint8 curLen = 0;
   \                     ??CrossCallReturnLabel_33:
   \   000012   75..00       MOV     ?V0 + 6,#0x0
   3129            uint8 status;
   3130            uint8 i, j = 0;
   \   000015   7E00         MOV     R6,#0x0
   3131          
   3132            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   000017   7402         MOV     A,#0x2
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   00001F   7406         MOV     A,#0x6
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   3133            
   3134            // Allocate space for Write Response Command
   3135            writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof( zclWriteRspCmd_t ) 
   3136                             + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
   \                     ??CrossCallReturnLabel_343:
   \   000027                ; Setup parameters for call to function osal_mem_alloc
   \   000027   7406         MOV     A,#0x6
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_309:
   \   00002F   8A..         MOV     ?V0 + 4,R2
   \   000031   8B..         MOV     ?V0 + 5,R3
   3137            if ( writeRspCmd == NULL )
   \   000033   EA           MOV     A,R2
   \   000034   7001         JNZ     ??zclProcessInWriteUndividedCmd_0
   \   000036   EB           MOV     A,R3
   \                     ??zclProcessInWriteUndividedCmd_0:
   \   000037   7005         JNZ     ??zclProcessInWriteUndividedCmd_1
   3138              return FALSE; // EMBEDDED RETURN
   \                     ??zclProcessInWriteUndividedCmd_2:
   \   000039   7900         MOV     R1,#0x0
   \   00003B   02....       LJMP    ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   3139            
   3140            // If any attribute cannot be written, no attribute values are changed. Hence,
   3141            // make sure all the attributes are supported and writable
   3142            for (i = 0; i < writeCmd->numAttr; i++)
   \                     ??zclProcessInWriteUndividedCmd_1:
   \   00003E   7F00         MOV     R7,#0x0
   \   000040   801C         SJMP    ??zclProcessInWriteUndividedCmd_4
   3143            {
   3144              statusRec = &(writeCmd->attrList[i]);
   3145              
   3146              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) )
   3147              {
   3148                // Attribute is not supported - stop here
   3149                writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   3150                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3151                break;
   3152              }
   3153              
   3154              if ( statusRec->dataType != attrRec.attr.dataType )
   3155              {
   3156                // Attribute data type is incorrect - stope here
   3157                writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   3158                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3159                break;
   3160              }
   3161              
   3162              if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) )
   3163              {
   3164                // Attribute is not writable - stop here
   3165                writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
   3166                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3167                break;
   3168              }
   3169              
   3170              dataLen = zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   \                     ??zclProcessInWriteUndividedCmd_5:
   \   000042                ; Setup parameters for call to function zclGetAttrDataLength
   \   000042   85..82       MOV     DPL,?V0 + 0
   \   000045   85..83       MOV     DPH,?V0 + 1
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   12....       LCALL   ??Subroutine162_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_276:
   \   00004E   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000051   E9           MOV     A,R1
   \   000052   FA           MOV     R2,A
   3171              
   3172              // add padding if needed
   3173              if ( PADDING_NEEDED( dataLen ) )
   \   000053   A2E0         MOV     C,0xE0 /* A   */.0
   \   000055   5001         JNC     ??zclProcessInWriteUndividedCmd_6
   3174                dataLen++;
   \   000057   0A           INC     R2
   3175              curLen += dataLen;
   \                     ??zclProcessInWriteUndividedCmd_6:
   \   000058   EA           MOV     A,R2
   \   000059   25..         ADD     A,?V0 + 6
   \   00005B   F5..         MOV     ?V0 + 6,A
   \   00005D   0F           INC     R7
   \                     ??zclProcessInWriteUndividedCmd_4:
   \   00005E   7406         MOV     A,#0x6
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   000066   4003         JC      $+5
   \   000068   02....       LJMP    ??zclProcessInWriteUndividedCmd_7 & 0xFFFF
   \   00006B   EF           MOV     A,R7
   \   00006C   75F005       MOV     B,#0x5
   \   00006F   A4           MUL     AB
   \   000070   F8           MOV     R0,A
   \   000071   A9F0         MOV     R1,B
   \   000073   7406         MOV     A,#0x6
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   00007B   7402         MOV     A,#0x2
   \   00007D   12....       LCALL   ?XSTACK_DISP0_8
   \   000080   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_346:
   \   000083                ; Setup parameters for call to function zclFindAttrRec
   \   000083   740A         MOV     A,#0xa
   \   000085   12....       LCALL   ?XSTACK_DISP0_8
   \   000088   8582..       MOV     ?V0 + 2,DPL
   \   00008B   8583..       MOV     ?V0 + 3,DPH
   \   00008E   78..         MOV     R0,#?V0 + 2
   \   000090   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000093   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_370:
   \   000096   7402         MOV     A,#0x2
   \   000098   12....       LCALL   ?XSTACK_DISP0_8
   \   00009B   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   00009E   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A1   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_210:
   \   0000A4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A7   E9           MOV     A,R1
   \   0000A8   7004         JNZ     ??zclProcessInWriteUndividedCmd_8
   \   0000AA   7486         MOV     A,#-0x7a
   \   0000AC   8026         SJMP    ??zclProcessInWriteUndividedCmd_9
   \                     ??zclProcessInWriteUndividedCmd_8:
   \   0000AE   85..82       MOV     DPL,?V0 + 0
   \   0000B1   85..83       MOV     DPH,?V0 + 1
   \   0000B4   A3           INC     DPTR
   \   0000B5   A3           INC     DPTR
   \   0000B6   E0           MOVX    A,@DPTR
   \   0000B7   F9           MOV     R1,A
   \   0000B8   740E         MOV     A,#0xe
   \   0000BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BD   E0           MOVX    A,@DPTR
   \   0000BE   69           XRL     A,R1
   \   0000BF   6004         JZ      ??zclProcessInWriteUndividedCmd_10
   \   0000C1   748D         MOV     A,#-0x73
   \   0000C3   800F         SJMP    ??zclProcessInWriteUndividedCmd_9
   \                     ??zclProcessInWriteUndividedCmd_10:
   \   0000C5   740F         MOV     A,#0xf
   \   0000C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CA   E0           MOVX    A,@DPTR
   \   0000CB   A2E1         MOV     C,0xE0 /* A   */.1
   \   0000CD   5003         JNC     $+5
   \   0000CF   02....       LJMP    ??zclProcessInWriteUndividedCmd_5 & 0xFFFF
   \   0000D2   7488         MOV     A,#-0x78
   \                     ??zclProcessInWriteUndividedCmd_9:
   \   0000D4   85..82       MOV     DPL,?V0 + 4
   \   0000D7   85..83       MOV     DPH,?V0 + 5
   \   0000DA   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_376:
   \   0000DD   F8           MOV     R0,A
   \   0000DE   A3           INC     DPTR
   \   0000DF   E0           MOVX    A,@DPTR
   \   0000E0   F9           MOV     R1,A
   \   0000E1   85..82       MOV     DPL,?V0 + 4
   \   0000E4   85..83       MOV     DPH,?V0 + 5
   \   0000E7   A3           INC     DPTR
   \   0000E8   A3           INC     DPTR
   \   0000E9   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_344:
   \   0000EC   0E           INC     R6
   3176            } // for loop
   3177            
   3178            writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_7:
   \   0000ED   EE           MOV     A,R6
   \   0000EE   85..82       MOV     DPL,?V0 + 4
   \   0000F1   85..83       MOV     DPH,?V0 + 5
   \   0000F4   F0           MOVX    @DPTR,A
   3179            if ( writeRspCmd->numAttr == 0 ) // All attributes can be written
   \   0000F5   6003         JZ      $+5
   \   0000F7   02....       LJMP    ??CrossCallReturnLabel_129 & 0xFFFF
   3180            {
   3181              // calculate the length of the current data header
   3182              hdrLen = j * sizeof( zclWriteRec_t );
   \   0000FA   75F005       MOV     B,#0x5
   \   0000FD   A4           MUL     AB
   \   0000FE   FA           MOV     R2,A
   3183            
   3184              // Allocate space to keep a copy of the current data
   3185              curWriteRec = (zclWriteRec_t *) osal_mem_alloc( hdrLen + curLen ); 
   \   0000FF   8A82         MOV     DPL,R2
   \   000101   8582..       MOV     ?V0 + 0,DPL
   \   000104                ; Setup parameters for call to function osal_mem_alloc
   \   000104   E5..         MOV     A,?V0 + 6
   \   000106   12....       LCALL   ?Subroutine115 & 0xFFFF
   \                     ??CrossCallReturnLabel_311:
   \   000109   7404         MOV     A,#0x4
   \   00010B   12....       LCALL   ?XSTACK_DISP0_8
   \   00010E   12....       LCALL   ?Subroutine16 & 0xFFFF
   3186              if ( curWriteRec == NULL )
   \                     ??CrossCallReturnLabel_34:
   \   000111   7404         MOV     A,#0x4
   \   000113   12....       LCALL   ?XSTACK_DISP0_8
   \   000116   E0           MOVX    A,@DPTR
   \   000117   7002         JNZ     ??zclProcessInWriteUndividedCmd_11
   \   000119   A3           INC     DPTR
   \   00011A   E0           MOVX    A,@DPTR
   \                     ??zclProcessInWriteUndividedCmd_11:
   \   00011B   700A         JNZ     ??zclProcessInWriteUndividedCmd_12
   3187              {
   3188                osal_mem_free(writeRspCmd );
   \   00011D                ; Setup parameters for call to function osal_mem_free
   \   00011D   AA..         MOV     R2,?V0 + 4
   \   00011F   AB..         MOV     R3,?V0 + 5
   \   000121   12....       LCALL   ??osal_mem_free?relay
   3189                return FALSE; // EMBEDDED RETURN
   \   000124   02....       LJMP    ??zclProcessInWriteUndividedCmd_2 & 0xFFFF
   3190              }
   3191          
   3192              curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
   \                     ??zclProcessInWriteUndividedCmd_12:
   \   000127   7404         MOV     A,#0x4
   \   000129   12....       LCALL   ?XSTACK_DISP0_8
   \   00012C   12....       LCALL   ?Subroutine111 & 0xFFFF
   3193              
   3194              // Write the new data over
   3195              for (i = 0; i < writeCmd->numAttr; i++)
   \                     ??CrossCallReturnLabel_268:
   \   00012F   7F00         MOV     R7,#0x0
   \   000131   8020         SJMP    ??zclProcessInWriteUndividedCmd_13
   3196              {
   3197                statusRec = &(writeCmd->attrList[i]);
   3198                curStatusRec = &(curWriteRec[i]);
   3199              
   3200                if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) )
   3201                  break; // should never happen
   3202          
   3203                // Keep a copy of the current data before before writing the new data over
   3204                curStatusRec->attrID = statusRec->attrID;
   3205                zclReadAttrData( curDataPtr, &attrRec );
   3206                curStatusRec->attrData = curDataPtr;
   3207                
   3208                status = zclWriteAttrData( &attrRec, statusRec );
   3209                   
   3210                // If successful, a write attribute status record shall NOT be generated
   3211                if ( status != ZCL_STATUS_SUCCESS )
   3212                {
   3213                  writeRspCmd->attrList[j].status = status;
   3214                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3215                    
   3216                  // Since this write failed, we need to revert all the pervious writes
   3217                  zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
   3218                  break;
   3219                }
   3220                
   3221                dataLen = zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   \                     ??zclProcessInWriteUndividedCmd_14:
   \   000133                ; Setup parameters for call to function zclGetAttrDataLength
   \   000133   85..82       MOV     DPL,?V0 + 0
   \   000136   85..83       MOV     DPH,?V0 + 1
   \   000139   A3           INC     DPTR
   \   00013A   A3           INC     DPTR
   \   00013B   A3           INC     DPTR
   \   00013C   12....       LCALL   ??Subroutine162_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_277:
   \   00013F   85..82       MOV     DPL,?V0 + 0
   \   000142   85..83       MOV     DPH,?V0 + 1
   \   000145   12....       LCALL   ?Subroutine106 & 0xFFFF
   3222                
   3223                // add padding if needed
   3224                if ( PADDING_NEEDED( dataLen ) )
   \                     ??CrossCallReturnLabel_263:
   \   000148   A2E0         MOV     C,0xE0 /* A   */.0
   \   00014A   5001         JNC     ??zclProcessInWriteUndividedCmd_15
   3225                  dataLen++;
   \   00014C   0A           INC     R2
   3226                curDataPtr += dataLen;
   \                     ??zclProcessInWriteUndividedCmd_15:
   \   00014D   8A..         MOV     ?V0 + 0,R2
   \   00014F   12....       LCALL   ??Subroutine161_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_270:
   \   000152   0F           INC     R7
   \                     ??zclProcessInWriteUndividedCmd_13:
   \   000153   7406         MOV     A,#0x6
   \   000155   12....       LCALL   ?XSTACK_DISP0_8
   \   000158   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   00015B   4003         JC      $+5
   \   00015D   02....       LJMP    ??zclProcessInWriteUndividedCmd_16 & 0xFFFF
   \   000160   EF           MOV     A,R7
   \   000161   75F005       MOV     B,#0x5
   \   000164   A4           MUL     AB
   \   000165   F8           MOV     R0,A
   \   000166   A9F0         MOV     R1,B
   \   000168   7406         MOV     A,#0x6
   \   00016A   12....       LCALL   ?XSTACK_DISP0_8
   \   00016D   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   000170   7404         MOV     A,#0x4
   \   000172   12....       LCALL   ?XSTACK_DISP0_8
   \   000175   E0           MOVX    A,@DPTR
   \   000176   28           ADD     A,R0
   \   000177   F8           MOV     R0,A
   \   000178   A3           INC     DPTR
   \   000179   E0           MOVX    A,@DPTR
   \   00017A   39           ADDC    A,R1
   \   00017B   F9           MOV     R1,A
   \   00017C   7408         MOV     A,#0x8
   \   00017E   12....       LCALL   ?XSTACK_DISP0_8
   \   000181   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000184   12....       LCALL   ?XSTACK_DISP0_8
   \   000187   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_347:
   \   00018A                ; Setup parameters for call to function zclFindAttrRec
   \   00018A   740A         MOV     A,#0xa
   \   00018C   12....       LCALL   ?XSTACK_DISP0_8
   \   00018F   8582..       MOV     ?V0 + 2,DPL
   \   000192   8583..       MOV     ?V0 + 3,DPH
   \   000195   78..         MOV     R0,#?V0 + 2
   \   000197   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00019A   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_371:
   \   00019D   7402         MOV     A,#0x2
   \   00019F   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A2   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   0001A5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A8   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   0001AB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001AE   E9           MOV     A,R1
   \   0001AF   7003         JNZ     $+5
   \   0001B1   02....       LJMP    ??zclProcessInWriteUndividedCmd_16 & 0xFFFF
   \   0001B4   85..82       MOV     DPL,?V0 + 0
   \   0001B7   85..83       MOV     DPH,?V0 + 1
   \   0001BA   12....       LCALL   ??Subroutine162_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_278:
   \   0001BD   7408         MOV     A,#0x8
   \   0001BF   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C2   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   0001C5   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   0001C8                ; Setup parameters for call to function zclReadAttrData
   \   0001C8   740A         MOV     A,#0xa
   \   0001CA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CD   AC82         MOV     R4,DPL
   \   0001CF   AD83         MOV     R5,DPH
   \   0001D1   AA..         MOV     R2,?V0 + 6
   \   0001D3   AB..         MOV     R3,?V0 + 7
   \   0001D5   12....       LCALL   ??zclReadAttrData?relay
   \   0001D8   7408         MOV     A,#0x8
   \   0001DA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DD   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   0001E0   E5..         MOV     A,?V0 + 6
   \   0001E2   F0           MOVX    @DPTR,A
   \   0001E3   A3           INC     DPTR
   \   0001E4   E5..         MOV     A,?V0 + 7
   \   0001E6   F0           MOVX    @DPTR,A
   \   0001E7                ; Setup parameters for call to function zclWriteAttrData
   \   0001E7   AC..         MOV     R4,?V0 + 0
   \   0001E9   AD..         MOV     R5,?V0 + 1
   \   0001EB   740A         MOV     A,#0xa
   \   0001ED   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F0   AA82         MOV     R2,DPL
   \   0001F2   AB83         MOV     R3,DPH
   \   0001F4   12....       LCALL   ??zclWriteAttrData?relay
   \   0001F7   E9           MOV     A,R1
   \   0001F8   FB           MOV     R3,A
   \   0001F9   7003         JNZ     $+5
   \   0001FB   02....       LJMP    ??zclProcessInWriteUndividedCmd_14 & 0xFFFF
   \   0001FE   EE           MOV     A,R6
   \   0001FF   75F003       MOV     B,#0x3
   \   000202   A4           MUL     AB
   \   000203   F8           MOV     R0,A
   \   000204   A9F0         MOV     R1,B
   \   000206   E5..         MOV     A,?V0 + 4
   \   000208   28           ADD     A,R0
   \   000209   F8           MOV     R0,A
   \   00020A   E5..         MOV     A,?V0 + 5
   \   00020C   39           ADDC    A,R1
   \   00020D   F9           MOV     R1,A
   \   00020E   EB           MOV     A,R3
   \   00020F   8882         MOV     DPL,R0
   \   000211   8983         MOV     DPH,R1
   \   000213   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_377:
   \   000216   FA           MOV     R2,A
   \   000217   A3           INC     DPTR
   \   000218   E0           MOVX    A,@DPTR
   \   000219   FB           MOV     R3,A
   \   00021A   8882         MOV     DPL,R0
   \   00021C   8983         MOV     DPH,R1
   \   00021E   A3           INC     DPTR
   \   00021F   A3           INC     DPTR
   \   000220   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000223   0E           INC     R6
   \   000224   EF           MOV     A,R7
   \   000225   85..82       MOV     DPL,?XSP + 0
   \   000228   85..83       MOV     DPH,?XSP + 1
   \   00022B   F0           MOVX    @DPTR,A
   \   00022C   A3           INC     DPTR
   \   00022D   E4           CLR     A
   \   00022E   F0           MOVX    @DPTR,A
   \   00022F   FF           MOV     R7,A
   \   000230   8026         SJMP    ??zclProcessInWriteUndividedCmd_17
   3227              } // for loop
   \                     ??zclProcessInWriteUndividedCmd_18:
   \   000232   E5..         MOV     A,?V0 + 6
   \   000234   2403         ADD     A,#0x3
   \   000236   F5..         MOV     ?V0 + 0,A
   \   000238   E5..         MOV     A,?V0 + 7
   \   00023A   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_280:
   \   00023D   7416         MOV     A,#0x16
   \   00023F   12....       LCALL   ?XSTACK_DISP0_8
   \   000242   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_207:
   \   000245   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000248   EA           MOV     A,R2
   \   000249   FC           MOV     R4,A
   \   00024A   7D00         MOV     R5,#0x0
   \   00024C   741B         MOV     A,#0x1b
   \   00024E   12....       LCALL   ?XSTACK_DISP0_8
   \   000251   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   000254   12....       LCALL   ?DEALLOC_XSTACK8
   \   000257   0F           INC     R7
   \                     ??zclProcessInWriteUndividedCmd_17:
   \   000258   8F..         MOV     ?V0 + 0,R7
   \   00025A   85..82       MOV     DPL,?XSP + 0
   \   00025D   85..83       MOV     DPH,?XSP + 1
   \   000260   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   000263   C3           CLR     C
   \   000264   E5..         MOV     A,?V0 + 0
   \   000266   98           SUBB    A,R0
   \   000267   E4           CLR     A
   \   000268   99           SUBB    A,R1
   \   000269   503D         JNC     ??zclProcessInWriteUndividedCmd_16
   \   00026B   EF           MOV     A,R7
   \   00026C   75F005       MOV     B,#0x5
   \   00026F   A4           MUL     AB
   \   000270   F8           MOV     R0,A
   \   000271   A9F0         MOV     R1,B
   \   000273   7404         MOV     A,#0x4
   \   000275   12....       LCALL   ?XSTACK_DISP0_8
   \   000278   E0           MOVX    A,@DPTR
   \   000279   28           ADD     A,R0
   \   00027A   F5..         MOV     ?V0 + 6,A
   \   00027C   A3           INC     DPTR
   \   00027D   E0           MOVX    A,@DPTR
   \   00027E   39           ADDC    A,R1
   \   00027F   F5..         MOV     ?V0 + 7,A
   \   000281   7402         MOV     A,#0x2
   \   000283   12....       LCALL   ?XSTACK_DISP0_8
   \   000286   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   000289                ; Setup parameters for call to function zclFindAttrRec
   \   000289   7412         MOV     A,#0x12
   \   00028B   12....       LCALL   ?XSTACK_DISP0_8
   \   00028E   8582..       MOV     ?V0 + 0,DPL
   \   000291   8583..       MOV     ?V0 + 1,DPH
   \   000294   78..         MOV     R0,#?V0 + 0
   \   000296   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000299   85..82       MOV     DPL,?V0 + 6
   \   00029C   85..83       MOV     DPH,?V0 + 7
   \   00029F   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_212:
   \   0002A2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002A5   E9           MOV     A,R1
   \   0002A6   708A         JNZ     ??zclProcessInWriteUndividedCmd_18
   3228            
   3229              writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_16:
   \   0002A8   EE           MOV     A,R6
   \   0002A9   85..82       MOV     DPL,?V0 + 4
   \   0002AC   85..83       MOV     DPH,?V0 + 5
   \   0002AF   F0           MOVX    @DPTR,A
   3230              if ( writeRspCmd->numAttr  == 0 )
   \   0002B0   700C         JNZ     ??zclProcessInWriteUndividedCmd_19
   3231              {
   3232                // Since all records were written successful, include a single status record
   3233                // in the resonse command with the status field set to SUCCESS and the 
   3234                // attribute ID field omitted.
   3235                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   0002B2   E4           CLR     A
   \   0002B3   A3           INC     DPTR
   \   0002B4   F0           MOVX    @DPTR,A
   3236                writeRspCmd->numAttr = 1;
   \   0002B5   7401         MOV     A,#0x1
   \   0002B7   85..82       MOV     DPL,?V0 + 4
   \   0002BA   85..83       MOV     DPH,?V0 + 5
   \   0002BD   F0           MOVX    @DPTR,A
   3237              }
   3238          
   3239              osal_mem_free( curWriteRec );
   \                     ??zclProcessInWriteUndividedCmd_19:
   \   0002BE                ; Setup parameters for call to function osal_mem_free
   \   0002BE   7404         MOV     A,#0x4
   \   0002C0   12....       LCALL   ?XSTACK_DISP0_8
   \   0002C3   12....       LCALL   ?Subroutine74 & 0xFFFF
   3240            }
   3241            
   3242            zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3243                              pInMsg->msg->clusterId, writeRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR, 
   3244                              true, pInMsg->hdr.transSeqNum );  
   \                     ??CrossCallReturnLabel_129:
   \   0002C6   7402         MOV     A,#0x2
   \   0002C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0002CB   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   0002CE   12....       LCALL   ?XSTACK_DISP0_8
   \   0002D1   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_238:
   \   0002D4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002D7   75..01       MOV     ?V0 + 0,#0x1
   \   0002DA   78..         MOV     R0,#?V0 + 0
   \   0002DC   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002DF   78..         MOV     R0,#?V0 + 0
   \   0002E1   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002E4   78..         MOV     R0,#?V0 + 4
   \   0002E6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002E9   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   0002EC   12....       LCALL   ?DEALLOC_XSTACK8
   3245            osal_mem_free( writeRspCmd );
   \   0002EF                ; Setup parameters for call to function osal_mem_free
   \   0002EF   AA..         MOV     R2,?V0 + 4
   \   0002F1   AB..         MOV     R3,?V0 + 5
   \   0002F3   12....       LCALL   ??osal_mem_free?relay
   3246           
   3247            return TRUE; 
   \   0002F6   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteUndividedCmd_3:
   \   0002F8   741A         MOV     A,#0x1a
   \   0002FA   02....       LJMP    ??Subroutine152_0 & 0xFFFF
   3248          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_358:
   \   000003   FA           MOV     R2,A
   \   000004   EF           MOV     A,R7
   \   000005   C3           CLR     C
   \   000006   9A           SUBB    A,R2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_162:
   \   000003   8582..       MOV     ?V0 + 0,DPL
   \   000006   8583..       MOV     ?V0 + 1,DPH
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   000003   FA           MOV     R2,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   FB           MOV     R3,A
   \   000007   7402         MOV     A,#0x2
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine175_0
   \   000001                ; // Fall through to label ??Subroutine175_0
   3249          #endif // ZCL_WRITE
   3250          
   3251          #ifdef ZCL_DISCOVER
   3252          /*********************************************************************
   3253           * @fn      zclProcessInDiscCmd
   3254           *
   3255           * @brief   Process the "Profile" Discover Command
   3256           *
   3257           * @param   pInMsg - incoming message to process
   3258           *
   3259           * @return  TRUE if command processed. FALSE, otherwise.
   3260           */
   3261          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
   3262          {
   3263            zclDiscoverCmd_t *discoverCmd;
   3264            zclDiscoverRspCmd_t *discoverRspCmd;
   3265            uint8 discComplete = TRUE;
   3266            zclAttrRec_t attrRec;
   3267            uint16 attrID;
   3268            uint8 i;
   3269            
   3270            discoverCmd = (zclDiscoverCmd_t *)pInMsg->attrCmd;
   3271            
   3272            // Find out the number of attributes supported within the specified range
   3273            for ( i = 0, attrID = discoverCmd->startAttr; i < discoverCmd->maxAttrIDs; i++, attrID++ )
   3274            {
   3275              if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   3276                break;
   3277            }
   3278            
   3279            // Allocate space for the response command
   3280            discoverRspCmd = (zclDiscoverRspCmd_t *)osal_mem_alloc( sizeof (zclDiscoverRspCmd_t) 
   3281                                                                   + sizeof ( zclDiscoverInfo_t ) * i );
   3282            if ( discoverRspCmd == NULL )
   3283              return FALSE; // EMEDDED RETURN
   3284            
   3285            discoverRspCmd->numAttr = i;
   3286            if ( discoverRspCmd->numAttr != 0 )
   3287            {
   3288              for ( i = 0, attrID = discoverCmd->startAttr; i < discoverRspCmd->numAttr; i++, attrID++ )
   3289              {
   3290                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   3291                  break; // Attribute not supported
   3292                
   3293                discoverRspCmd->attrList[i].attrID = attrRec.attr.attrId;
   3294                discoverRspCmd->attrList[i].dataType = attrRec.attr.dataType;
   3295              }
   3296              
   3297              // Are there more attributes to be discovered?
   3298              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   3299                discComplete = FALSE;
   3300            }
   3301            
   3302            discoverRspCmd->discComplete = discComplete;
   3303            zcl_SendDiscoverRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr, 
   3304                                    pInMsg->msg->clusterId, discoverRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR, 
   3305                                    true, pInMsg->hdr.transSeqNum );
   3306            osal_mem_free( discoverRspCmd );
   3307            
   3308            return TRUE;
   3309          }
   3310          #endif // ZCL_DISCOVER
   3311          
   3312          /*********************************************************************
   3313           * @fn      zclSendMsg
   3314           *
   3315           * @brief   Send an incoming message to the Application
   3316           *
   3317           * @param   pInMsg - incoming message to process
   3318           *
   3319           * @return  TRUE
   3320           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3321          static uint8 zclSendMsg( zclIncoming_t *pInMsg )
   \                     zclSendMsg:
   3322          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   3323            zclIncomingMsg_t *pCmd;
   3324              
   3325            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000009   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   64FF         XRL     A,#0xff
   \   00000F   7005         JNZ     ??zclSendMsg_0
   3326              return ( TRUE );
   \                     ??zclSendMsg_1:
   \   000011   7901         MOV     R1,#0x1
   \   000013   02....       LJMP    ?Subroutine141 & 0xFFFF
   3327            
   3328            pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
   \                     ??zclSendMsg_0:
   \   000016                ; Setup parameters for call to function osal_msg_allocate
   \   000016   7A18         MOV     R2,#0x18
   \   000018   7B00         MOV     R3,#0x0
   \   00001A   12....       LCALL   ??osal_msg_allocate?relay
   3329            if ( pCmd != NULL )
   \   00001D   EA           MOV     A,R2
   \   00001E   7001         JNZ     ??zclSendMsg_2
   \   000020   EB           MOV     A,R3
   \                     ??zclSendMsg_2:
   \   000021   60EE         JZ      ??zclSendMsg_1
   3330            {
   3331              // fill in the message
   3332              pCmd->hdr.event = ZCL_INCOMING_MSG;
   \   000023   7434         MOV     A,#0x34
   \   000025   12....       LCALL   ?Subroutine11 & 0xFFFF
   3333              pCmd->zclHdr    = pInMsg->hdr;
   \                     ??CrossCallReturnLabel_325:
   \   000028   A3           INC     DPTR
   \   000029   EA           MOV     A,R2
   \   00002A   2402         ADD     A,#0x2
   \   00002C   FC           MOV     R4,A
   \   00002D   EB           MOV     A,R3
   \   00002E   3400         ADDC    A,#0x0
   \   000030   FD           MOV     R5,A
   \   000031   7406         MOV     A,#0x6
   \   000033   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   3334              pCmd->clusterId = pInMsg->msg->clusterId;
   \   000036   8E82         MOV     DPL,R6
   \   000038   8F83         MOV     DPH,R7
   \   00003A   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   00003D   F8           MOV     R0,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F9           MOV     R1,A
   \   000041   8A82         MOV     DPL,R2
   \   000043   8B83         MOV     DPH,R3
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   E8           MOV     A,R0
   \   00004E   12....       LCALL   ?Subroutine18 & 0xFFFF
   3335              pCmd->srcAddr   = pInMsg->msg->srcAddr;
   \                     ??CrossCallReturnLabel_38:
   \   000051   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_381:
   \   000054   EA           MOV     A,R2
   \   000055   240A         ADD     A,#0xa
   \   000057   FC           MOV     R4,A
   \   000058   EB           MOV     A,R3
   \   000059   3400         ADDC    A,#0x0
   \   00005B   FD           MOV     R5,A
   \   00005C   740C         MOV     A,#0xc
   \   00005E   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   3336              pCmd->attrCmd   = pInMsg->attrCmd;
   \   000061   EE           MOV     A,R6
   \   000062   240B         ADD     A,#0xb
   \   000064   F8           MOV     R0,A
   \   000065   EF           MOV     A,R7
   \   000066   12....       LCALL   ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_255:
   \   000069   12....       LCALL   ??Subroutine174_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_369:
   \   00006C   EA           MOV     A,R2
   \   00006D   2416         ADD     A,#0x16
   \   00006F   F582         MOV     DPL,A
   \   000071   EB           MOV     A,R3
   \   000072   3400         ADDC    A,#0x0
   \   000074   F583         MOV     DPH,A
   \   000076   EC           MOV     A,R4
   \   000077   F0           MOVX    @DPTR,A
   \   000078   A3           INC     DPTR
   \   000079   ED           MOV     A,R5
   \   00007A   12....       LCALL   ?Subroutine122 & 0xFFFF
   3337              
   3338              // Application will free the attrCmd buffer
   3339              pInMsg->attrCmd = NULL;
   \                     ??CrossCallReturnLabel_252:
   \   00007D   E4           CLR     A
   \   00007E   F0           MOVX    @DPTR,A
   \   00007F   A3           INC     DPTR
   \   000080   F0           MOVX    @DPTR,A
   3340              
   3341              /* send message through task message */
   3342              osal_msg_send( zcl_RegisteredMsgTaskID, (uint8 *)pCmd );
   \   000081                ; Setup parameters for call to function osal_msg_send
   \   000081   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   000084   E0           MOVX    A,@DPTR
   \   000085   F9           MOV     R1,A
   \   000086   12....       LCALL   ??osal_msg_send?relay
   \   000089   8086         SJMP    ??zclSendMsg_1
   3343            }
   3344            
   3345            return ( TRUE );
   3346          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zcl_RegisteredMsgTaskID>`:
   \   000000   FF           DB 255

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_event_loop?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_event_loop

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerPlugin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerPlugin

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerAttrList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerAttrList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerClusterOptionList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerClusterOptionList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerValidateAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerValidateAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerForMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerForMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_DeviceOperational?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_DeviceOperational

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendCommand?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendCommand

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReadRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendWriteRequest?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendWriteRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendDefaultRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessMessageMSG?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessMessageMSG

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseHdr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclBuildHdr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclBuildHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindAttrRec?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRec

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindClusterOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetClusterOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSetSecurityOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSetSecurityOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSerializeData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSerializeData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetDataTypeLength?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetDataTypeLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetAttrDataLength?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclReadAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclWriteAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInWriteCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInWriteRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInDefaultRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInReadCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInWriteCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInWriteUndividedCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteUndividedCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSendMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSendMsg
   3347          
   3348          /*********************************************************************
   3349          *********************************************************************/

   Maximum stack usage in bytes:

     Function                      ISTACK PSTACK XSTACK
     --------                      ------ ------ ------
     zclBuildHdr                       1      0     50
     zclFindAttrRec                    1      0     60
     zclFindClusterOption              1      0     21
     zclGetAttrDataLength              2      0     42
       -> zclGetDataTypeLength         4      0      0
     zclGetClusterOption               0      0     48
       -> zclFindClusterOption         0      0     20
     zclGetDataTypeLength              2      0      0
     zclParseHdr                       1      0     47
       -> osal_memset                  0      0     24
     zclParseInDefaultRspCmd           1      0     10
       -> osal_mem_alloc               0      0     20
     zclParseInReadCmd                 1      0     12
       -> osal_mem_alloc               0      0     24
     zclParseInReadRspCmd              1      0     23
       -> zclGetAttrDataLength         0      0     40
       -> osal_mem_alloc               0      0     40
       -> zclGetAttrDataLength         0      0     40
       -> osal_memcpy                  0      0     46
     zclParseInWriteCmd                1      0     23
       -> zclGetAttrDataLength         0      0     40
       -> osal_mem_alloc               0      0     40
       -> zclGetAttrDataLength         0      0     40
       -> osal_memcpy                  0      0     46
     zclParseInWriteRspCmd             1      0     16
       -> osal_mem_alloc               0      0     32
     zclProcessInReadCmd               1      0     33
       -> osal_mem_alloc               0      0     56
       -> zclFindAttrRec               0      0     60
       -> zcl_SendReadRsp              0      0     66
       -> osal_mem_free                0      0     56
     zclProcessInWriteCmd              1      0     37
       -> osal_mem_alloc               0      0     64
       -> zclFindAttrRec               0      0     68
       -> zclWriteAttrData             0      0     64
       -> zcl_SendWriteRsp             0      0     74
       -> osal_mem_free                0      0     64
     zclProcessInWriteUndividedCmd     1      0     47
       -> osal_mem_alloc               0      0     84
       -> zclGetAttrDataLength         0      0     84
       -> zclFindAttrRec               0      0     88
       -> osal_mem_alloc               0      0     84
       -> osal_mem_free                0      0     84
       -> zclGetAttrDataLength         0      0     84
       -> zclFindAttrRec               0      0     88
       -> zclReadAttrData              0      0     84
       -> zclWriteAttrData             0      0     84
       -> zclGetAttrDataLength         0      0     84
       -> osal_memcpy                  0      0     90
       -> zclFindAttrRec               0      0     88
       -> osal_mem_free                0      0     84
       -> zcl_SendWriteRsp             0      0     94
       -> osal_mem_free                0      0     84
     zclProcessMessageMSG              1      0     52
       -> zclParseHdr                  0      0     70
       -> afFindEndPointDesc           0      0     70
       -> zcl_DeviceOperational        0      0     74
       -> zclGetClusterOption          0      0     70
       -> zclSetSecurityOption         0      0     70
       -> zcl_SendDefaultRspCmd        0      0     80
       -> zclSetSecurityOption         0      0     70
       -> osal_mem_free                0      0     70
       -> zcl_SendDefaultRspCmd        0      0     80
     zclReadAttrData                   0      0     60
       -> zclGetAttrDataLength         0      0     30
       -> osal_memcpy                  0      0     36
     zclSendMsg                        1      0     10
       -> osal_msg_allocate            0      0     20
       -> osal_msg_send                0      0     20
     zclSerializeData                  1      0     36
       -> osal_buffer_uint32           0      0     32
       -> osal_memcpy                  0      0     30
       -> osal_memcpy                  0      0     30
       -> osal_memcpy                  0      0     30
       -> osal_memcpy                  0      0     30
     zclSetSecurityOption              0      0     45
       -> zclFindClusterOption         0      0     20
     zclWriteAttrData                  0      0     56
       -> zclGetAttrDataLength         0      0     22
       -> osal_memcpy                  0      0     28
     zcl_DeviceOperational             1      0     61
       -> zclFindAttrRec               0      0     42
       -> zclReadAttrData              0      0     38
     zcl_Init                          2      0      0
     zcl_SendCommand                   1      0     77
       -> osal_memcpy                  0      0     82
       -> afFindEndPointDesc           0      0     76
       -> zclGetClusterOption          0      0     76
       -> osal_memset                  0      0     76
       -> zcl_DeviceOperational        0      0     80
       -> osal_mem_alloc               0      0     76
       -> zclBuildHdr                  0      0     82
       -> osal_memcpy                  0      0     82
       -> AF_DataRequest               0      0     94
       -> osal_mem_free                0      0     76
     zcl_SendDefaultRspCmd             1      0     64
       -> zcl_SendCommand              0      0     48
     zcl_SendRead                      1      0     34
       -> osal_mem_alloc               0      0     38
       -> zcl_SendCommand              0      0     58
       -> osal_mem_free                0      0     38
     zcl_SendReadRsp                   1      0     63
       -> zclGetAttrDataLength         0      0     40
       -> osal_mem_alloc               0      0     40
       -> zclSerializeData             0      0     40
       -> zclGetAttrDataLength         0      0     40
       -> zcl_SendCommand              0      0     60
       -> osal_mem_free                0      0     40
     zcl_SendWriteRequest              1      0     36
       -> zclGetAttrDataLength         0      0     40
       -> osal_mem_alloc               0      0     40
       -> zclSerializeData             0      0     40
       -> zclGetAttrDataLength         0      0     40
       -> zcl_SendCommand              0      0     60
       -> osal_mem_free                0      0     40
     zcl_SendWriteRsp                  1      0     77
       -> osal_mem_alloc               0      0     40
       -> zcl_SendCommand              0      0     60
       -> osal_mem_free                0      0     40
     zcl_event_loop                    0      0     12
       -> osal_msg_receive             0      0     24
       -> zclProcessMessageMSG         0      0     24
       -> osal_msg_deallocate          0      0     24
       -> osal_msg_receive             0      0     24
       -> osal_msg_send                0      0     24
     zcl_registerAttrList              1      0     12
       -> osal_mem_alloc               0      0     24
     zcl_registerClusterOptionList     1      0     12
       -> osal_mem_alloc               0      0     24
     zcl_registerForMsg                2      0      0
     zcl_registerPlugin                0      0     16
       -> osal_mem_alloc               0      0     28
     zcl_registerValidateAttrData      2      0      0


   Segment part sizes:

     Function/Label                             Bytes
     --------------                             -----
     zcl_TaskID                                    1
     zcl_RegisteredMsgTaskID                       1
     zcl_ValidateAttrDataCB                        2
     zcl_SeqNum                                    1
     plugins                                       2
     attrList                                      2
     clusterOptionList                             2
     zcl_TransID                                   1
     zclCmdTable                                  56
     zcl_Init                                     31
     ?Subroutine131                                7
     zcl_event_loop                              102
     ?Subroutine132                                5
     zcl_registerPlugin                          117
     ?Subroutine21                                 4
     ?Subroutine97                                 3
     ?Subroutine138                                5
     ?Subroutine71                                10
     ?Subroutine14                                 8
     ?Subroutine93                                16
     ?Subroutine122                                3
     ??Subroutine157_0                             5
     ?Subroutine100                                6
     zcl_registerAttrList                         60
     ?Subroutine81                                25
     ?Subroutine2                                 21
     zcl_registerClusterOptionList                60
     zcl_registerValidateAttrData                 14
     ?Subroutine16                                 6
     zcl_registerForMsg                           20
     zcl_DeviceOperational                       118
     ?Subroutine141                                5
     zcl_SendCommand                             533
     ?Subroutine59                                 6
     ??Subroutine152_0                             3
     ??Subroutine153_0                             5
     ?Subroutine73                                 4
     ?Subroutine135                                6
     ?Subroutine58                                13
     ??Subroutine163_0                             4
     ?Subroutine109                                4
     ?Subroutine125                                5
     ?Subroutine53                                 6
     ?Subroutine130                                9
     ??Subroutine171_0                             1
     ??Subroutine172_0                             5
     ??Subroutine174_0                             4
     ?Subroutine112                                6
     ?Subroutine107                                6
     zcl_SendRead                                248
     ?Subroutine143                                5
     ?Subroutine41                                 1
     ??Subroutine146_0                            11
     ?Subroutine116                                6
     ?Subroutine44                                 6
     ?Subroutine64                                12
     ?Subroutine7                                  4
     ?Subroutine92                                 9
     ?Subroutine121                                4
     ??Subroutine150_0                             8
     ?Subroutine126                                4
     ?Subroutine75                                 9
     ??Subroutine173_0                             4
     ?Subroutine101                                5
     zcl_SendReadRsp                             272
     ?Subroutine145                                5
     ?Subroutine79                                 2
     ??Subroutine147_0                            11
     ?Subroutine33                                15
     ?Subroutine98                                 3
     ??Subroutine148_0                            14
     ?Subroutine57                                 9
     ?Subroutine51                                 4
     ?Subroutine42                                 4
     ?Subroutine103                               10
     ?Subroutine124                                7
     ?Subroutine27                                 9
     ?Subroutine5                                 18
     ?Subroutine4                                 24
     ?Subroutine102                                1
     ??Subroutine149_0                            11
     ?Subroutine3                                 12
     ??Subroutine151_0                             2
     ??Subroutine154_0                             6
     ?Subroutine133                                3
     ?Subroutine123                                5
     ?Subroutine129                               11
     zcl_SendWriteRequest                        251
     ?Subroutine35                                 7
     zcl_SendWriteRsp                            253
     ??Subroutine162_0                             4
     ??Subroutine166_0                             6
     zcl_SendDefaultRspCmd                       153
     ?Subroutine113                                9
     zclProcessMessageMSG                       1012
     ?Subroutine89                                15
     ?Subroutine86                                14
     ?Subroutine76                                 7
     ?Subroutine70                                11
     ?Subroutine69                                 6
     ?Subroutine65                                12
     ?Subroutine60                                 6
     ?Subroutine50                                 8
     ?Subroutine40                                21
     ?Subroutine36                                10
     ?Subroutine34                                 9
     ?Subroutine90                                11
     ?Subroutine72                                 5
     ?Subroutine117                               10
     ?Subroutine74                                 7
     ?Subroutine114                                4
     ?Subroutine127                                6
     ?Subroutine105                                9
     ?Subroutine99                                 8
     zclParseHdr                                 220
     ?Subroutine10                                 2
     ??Subroutine155_0                             4
     ?Subroutine95                                11
     ?Subroutine13                                 4
     ?Subroutine94                                 5
     ?Subroutine134                                6
     ?Subroutine128                               10
     ?Subroutine9                                  6
     ??Subroutine168_0                             7
     ?Subroutine78                                 9
     ??Subroutine175_0                             9
     ?Subroutine18                                 4
     ?Subroutine96                                 7
     zclBuildHdr                                 102
     ?Subroutine22                                 7
     ??Subroutine156_0                             5
     ?Subroutine20                                 1
     ??Subroutine158_0                             1
     ??Subroutine159_0                            10
     ?Subroutine12                                 8
     ??Subroutine167_0                             6
     zclFindAttrRec                              163
     ?Subroutine91                                10
     zclFindClusterOption                        121
     ?Subroutine144                                5
     zclGetClusterOption                          32
     zclSetSecurityOption                         46
     zclSerializeData                            283
     ?Subroutine23                                10
     ?Subroutine66                                 4
     zclGetDataTypeLength                        131
     zclGetAttrDataLength                         29
     zclReadAttrData                              62
     ?Subroutine106                                2
     ??Subroutine160_0                             5
     zclWriteAttrData                            107
     ?Subroutine77                                 3
     ?Subroutine136                                6
     ?Subroutine62                                 4
     ?Subroutine110                                4
     ?Subroutine68                                 6
     ?Subroutine31                                19
     zclParseInReadCmd                            88
     ??Subroutine165_0                             4
     ?Subroutine140                                5
     ?Subroutine47                                 6
     ?Subroutine49                                21
     ?Subroutine142                                8
     ?Subroutine80                                10
     zclParseInReadRspCmd                        179
     ?Subroutine88                                 3
     ??Subroutine161_0                             8
     ?Subroutine139                                5
     ?Subroutine61                                 6
     ?Subroutine25                                 9
     ??Subroutine164_0                            22
     ?Subroutine87                                21
     ?Subroutine115                                2
     ?Subroutine84                                 5
     ?Subroutine83                                14
     ?Subroutine82                                26
     ?Subroutine56                                 6
     ?Subroutine48                                10
     ?Subroutine15                                 8
     ?Subroutine6                                 23
     ?Subroutine1                                 31
     ?Subroutine0                                 40
     ?Subroutine120                                4
     ?Subroutine119                               10
     ?Subroutine104                                4
     ?Subroutine111                               10
     zclParseInWriteCmd                          154
     zclParseInWriteRspCmd                       119
     zclParseInDefaultRspCmd                      37
     ?Subroutine11                                 4
     ?Subroutine32                                 3
     zclProcessInReadCmd                         299
     ?Subroutine118                                8
     ??Subroutine169_0                             7
     ?Subroutine63                                10
     ??Subroutine170_0                             9
     ?Subroutine67                                 4
     ?Subroutine55                                 6
     ?Subroutine8                                  8
     ?Subroutine29                                10
     ?Subroutine137                                6
     ?Subroutine24                                21
     ?Subroutine108                               11
     zclProcessInWriteCmd                        407
     ?Subroutine46                                10
     ?Subroutine39                                10
     ?Subroutine30                                19
     ?Subroutine28                                34
     ?Subroutine26                                 3
     ?Subroutine52                                 4
     ?Subroutine38                                 1
     ??Subroutine176_0                             4
     ?Subroutine19                                 3
     ?Subroutine45                                 6
     zclProcessInWriteUndividedCmd               765
     ?Subroutine54                                 8
     ?Subroutine43                                10
     ?Subroutine37                                10
     ?Subroutine17                                 1
     zclSendMsg                                  139
     ?<Initializer for zcl_RegisteredMsgTaskID>    1
     ??zcl_Init?relay                              6
     ??zcl_event_loop?relay                        6
     ??zcl_registerPlugin?relay                    6
     ??zcl_registerAttrList?relay                  6
     ??zcl_registerClusterOptionList?relay         6
     ??zcl_registerValidateAttrData?relay          6
     ??zcl_registerForMsg?relay                    6
     ??zcl_DeviceOperational?relay                 6
     ??zcl_SendCommand?relay                       6
     ??zcl_SendRead?relay                          6
     ??zcl_SendReadRsp?relay                       6
     ??zcl_SendWriteRequest?relay                  6
     ??zcl_SendWriteRsp?relay                      6
     ??zcl_SendDefaultRspCmd?relay                 6
     ??zclProcessMessageMSG?relay                  6
     ??zclParseHdr?relay                           6
     ??zclBuildHdr?relay                           6
     ??zclFindAttrRec?relay                        6
     ??zclFindClusterOption?relay                  6
     ??zclGetClusterOption?relay                   6
     ??zclSetSecurityOption?relay                  6
     ??zclSerializeData?relay                      6
     ??zclGetDataTypeLength?relay                  6
     ??zclGetAttrDataLength?relay                  6
     ??zclReadAttrData?relay                       6
     ??zclWriteAttrData?relay                      6
     ??zclParseInReadCmd?relay                     6
     ??zclParseInReadRspCmd?relay                  6
     ??zclParseInWriteCmd?relay                    6
     ??zclParseInWriteRspCmd?relay                 6
     ??zclParseInDefaultRspCmd?relay               6
     ??zclProcessInReadCmd?relay                   6
     ??zclProcessInWriteCmd?relay                  6
     ??zclProcessInWriteUndividedCmd?relay         6
     ??zclSendMsg?relay                            6

 
 8 173 bytes in segment BANKED_CODE
   210 bytes in segment BANK_RELAYS
    56 bytes in segment CODE_C
     1 byte  in segment XDATA_I
     1 byte  in segment XDATA_ID
    11 bytes in segment XDATA_Z
 
 8 440 bytes of CODE  memory
    12 bytes of XDATA memory

Errors: none
Warnings: none
